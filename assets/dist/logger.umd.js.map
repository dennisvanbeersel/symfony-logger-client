{"version":3,"file":"logger.umd.js","sources":["../src/client.js","../src/breadcrumbs.js","../src/circuit-breaker.js","../src/storage-queue.js","../src/rate-limiter.js","../src/transport.js","../src/dom-serializer.js","../src/click-tracker.js","../src/replay-buffer.js","../src/error-detector.js","../src/session-manager.js","../src/storage-manager.js","../src/index.js"],"sourcesContent":["/**\n * Client for capturing errors and sending to platform\n *\n * ERROR-TRIGGERED SESSION REPLAY:\n * - When error detected, triggers replay buffer capture\n * - Sends buffered events (before/after error) to backend\n * - Links replay data to error for debugging\n *\n * RESILIENCE FEATURES:\n * - Beacon API for page unload events (ensures critical errors are sent)\n * - All error handling wrapped in try-catch\n * - Never crashes on logging errors\n */\nexport class Client {\n    /**\n     * @param {Object} config - Configuration options\n     * @param {Transport} transport - Transport layer for API communication\n     * @param {BreadcrumbCollector} breadcrumbs - Breadcrumb tracking\n     * @param {ErrorDetector|null} errorDetector - Error detector for replay capture (optional)\n     * @param {SessionManager|null} sessionManager - Session manager for session ID tracking (optional)\n     */\n    constructor(config, transport, breadcrumbs, errorDetector = null, sessionManager = null) {\n        this.config = config;\n        this.transport = transport;\n        this.breadcrumbs = breadcrumbs;\n        this.errorDetector = errorDetector;\n        this.sessionManager = sessionManager;\n        this.userContext = null;\n        this.tags = {};\n        this.extra = {};\n        this.pendingBeaconErrors = [];\n    }\n\n    /**\n   * Install global error handlers\n   *\n   * Processing order (critical for reliability):\n   * 1. Resurrect nuclear errors from previous page loads (localStorage)\n   * 2. Process buffered errors from current page load (window._appLoggerBuffer)\n   * 3. Install live error handlers for future errors\n   */\n    install() {\n        try {\n            // 1. Process \"resurrected\" errors first (from previous sessions)\n            //    These are catastrophic errors that broke JS execution\n            this.processResurrectedErrors();\n\n            // 2. Process any errors that were buffered before SDK loaded (current page)\n            this.processBufferedErrors();\n\n            // 3. Handle uncaught errors (live, from this point forward)\n            window.addEventListener('error', (event) => {\n                try {\n                    this.captureException(event.error || new Error(event.message), {\n                        extra: {\n                            filename: event.filename,\n                            lineno: event.lineno,\n                            colno: event.colno,\n                        },\n                    });\n                } catch (error) {\n                    // Never crash on error handling\n                    console.error('ApplicationLogger: Failed to capture error', error);\n                }\n            });\n\n            // Handle unhandled promise rejections\n            window.addEventListener('unhandledrejection', (event) => {\n                try {\n                    this.captureException(event.reason, {\n                        extra: {\n                            type: 'unhandledrejection',\n                        },\n                    });\n                } catch (error) {\n                    console.error('ApplicationLogger: Failed to capture rejection', error);\n                }\n            });\n\n            // Use Beacon API for page unload to ensure critical errors are sent\n            window.addEventListener('beforeunload', () => {\n                this.flushBeaconErrors();\n            });\n\n            // Also try on visibilitychange (for mobile)\n            document.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'hidden') {\n                    this.flushBeaconErrors();\n                }\n            });\n\n            // Track breadcrumbs\n            this.breadcrumbs.install();\n        } catch (error) {\n            // Installation failure should never crash the app\n            console.error('ApplicationLogger: Failed to install', error);\n        }\n    }\n\n    /**\n     * Process \"resurrected\" errors from previous page loads.\n     *\n     * The nuclear error trap (ultra-minimal inline script) captures catastrophic\n     * errors that break JavaScript execution and stores them to localStorage.\n     * On the NEXT page load (when things have \"normalized\"), we resurrect and\n     * send these errors.\n     *\n     * This handles the \"nuclear scenario\":\n     * - Syntax errors before SDK loads\n     * - Module import failures\n     * - Blocking runtime errors\n     * - Third-party script failures\n     *\n     * Flow:\n     * 1. Check localStorage for '_appLogger_nuclear'\n     * 2. Parse stored errors\n     * 3. Send each error to API with 'resurrected: true' flag\n     * 4. Clear localStorage after successful send\n     */\n    processResurrectedErrors() {\n        try {\n            const NUCLEAR_KEY = '_appLogger_nuclear';\n            const RESURRECTION_ATTEMPTS_KEY = '_appLogger_resurrection_attempts';\n            const MAX_ATTEMPTS = 5;\n            const MAX_AGE_MS = 24 * 60 * 60 * 1000; // 24 hours\n\n            // Check if we've tried too many times\n            const attempts = parseInt(localStorage.getItem(RESURRECTION_ATTEMPTS_KEY) || '0', 10);\n            if (attempts >= MAX_ATTEMPTS) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Max resurrection attempts reached, clearing nuclear errors');\n                }\n                localStorage.removeItem(NUCLEAR_KEY);\n                localStorage.removeItem(RESURRECTION_ATTEMPTS_KEY);\n                return;\n            }\n\n            // Try to load nuclear errors\n            const stored = localStorage.getItem(NUCLEAR_KEY);\n            if (!stored) {\n                // No errors to resurrect\n                return;\n            }\n\n            // Parse stored errors\n            let errors;\n            try {\n                errors = JSON.parse(stored);\n            } catch (parseError) {\n                // Corrupted data - clear it\n                if (this.config.debug) {\n                    console.error('ApplicationLogger: Failed to parse nuclear errors, clearing', parseError);\n                }\n                localStorage.removeItem(NUCLEAR_KEY);\n                return;\n            }\n\n            // Validate array\n            if (!Array.isArray(errors) || errors.length === 0) {\n                localStorage.removeItem(NUCLEAR_KEY);\n                return;\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Resurrecting ${errors.length} nuclear error(s) from previous session`);\n            }\n\n            // Filter out old errors (older than MAX_AGE)\n            const now = Date.now();\n            const validErrors = errors.filter(err => {\n                const age = now - (err.t || 0);\n                return age < MAX_AGE_MS;\n            });\n\n            if (validErrors.length === 0) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: All nuclear errors expired, clearing');\n                }\n                localStorage.removeItem(NUCLEAR_KEY);\n                return;\n            }\n\n            // Track successes and failures\n            let succeeded = 0;\n            let failed = 0;\n\n            // Send each error\n            for (const err of validErrors) {\n                try {\n                    // Reconstruct error message\n                    const message = err.m\n                        ? String(err.m)\n                        : 'Nuclear error (catastrophic JavaScript failure)';\n\n                    const error = new Error(message);\n                    error.name = 'NuclearError';\n\n                    // Calculate age\n                    const errorAge = now - (err.t || now);\n\n                    // Capture with resurrection context\n                    this.captureException(error, {\n                        extra: {\n                            resurrected: true,\n                            nuclear: true,\n                            resurrectTimestamp: now,\n                            originalTimestamp: err.t || 0,\n                            errorAge: Math.floor(errorAge / 1000), // seconds\n                            filename: err.f || 'unknown',\n                            lineno: err.l || 0,\n                            colno: err.c || 0,\n                            originalUrl: err.u || 'unknown',\n                            sessionGap: true, // Error from previous page load\n                        },\n                    });\n\n                    succeeded++;\n                } catch (sendError) {\n                    failed++;\n                    if (this.config.debug) {\n                        console.error('ApplicationLogger: Failed to resurrect nuclear error', sendError);\n                    }\n                }\n            }\n\n            // If all succeeded, clear localStorage\n            if (failed === 0) {\n                localStorage.removeItem(NUCLEAR_KEY);\n                localStorage.removeItem(RESURRECTION_ATTEMPTS_KEY);\n\n                if (this.config.debug) {\n                    console.warn(`ApplicationLogger: Successfully resurrected ${succeeded} nuclear error(s)`);\n                }\n            } else {\n                // Some failed - increment attempt counter\n                localStorage.setItem(RESURRECTION_ATTEMPTS_KEY, String(attempts + 1));\n\n                if (this.config.debug) {\n                    console.warn(`ApplicationLogger: Resurrection partial success (${succeeded} succeeded, ${failed} failed), will retry on next load`);\n                }\n            }\n        } catch (error) {\n            // Never crash on resurrection\n            console.error('ApplicationLogger: Failed to process resurrected errors', error);\n        }\n    }\n\n    /**\n     * Process errors that were buffered before SDK loaded.\n     *\n     * The early error buffer (window._appLoggerBuffer) captures errors that occur\n     * before the full SDK loads (during page parsing, module loading, etc.).\n     * This method processes those buffered errors and sends them to the API.\n     */\n    processBufferedErrors() {\n        try {\n            // Check if buffer exists and is valid\n            if (!window._appLoggerBuffer ||\n                !Array.isArray(window._appLoggerBuffer.errors)) {\n                return;\n            }\n\n            const buffered = window._appLoggerBuffer.errors;\n\n            // Nothing to process\n            if (buffered.length === 0) {\n                return;\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Processing ${buffered.length} buffered error(s)`);\n            }\n\n            // Clear buffer immediately to prevent reprocessing\n            window._appLoggerBuffer.errors = [];\n\n            // Track processing stats\n            let processed = 0;\n            let failed = 0;\n\n            // Process each buffered error\n            for (const item of buffered) {\n                try {\n                    // Validate item structure\n                    if (!item || typeof item !== 'object') {\n                        failed++;\n                        continue;\n                    }\n\n                    if (item.type === 'error') {\n                        // Reconstruct error object from buffered data\n                        const message = item.error && item.error.message\n                            ? String(item.error.message)\n                            : (item.message ? String(item.message) : 'Unknown buffered error');\n\n                        const error = new Error(message);\n\n                        // Restore error properties if available\n                        if (item.error && typeof item.error === 'object') {\n                            if (item.error.name) {\n                                error.name = String(item.error.name);\n                            }\n                            if (item.error.stack) {\n                                error.stack = String(item.error.stack);\n                            }\n                        }\n\n                        // Capture with buffered context\n                        this.captureException(error, {\n                            extra: {\n                                buffered: true,\n                                bufferedAt: item.timestamp || Date.now(),\n                                filename: item.filename || 'unknown',\n                                lineno: typeof item.lineno === 'number' ? item.lineno : 0,\n                                colno: typeof item.colno === 'number' ? item.colno : 0,\n                            },\n                        });\n\n                        processed++;\n                    } else if (item.type === 'rejection') {\n                        // Handle promise rejection\n                        const reason = item.reason;\n                        let error;\n\n                        if (reason && typeof reason === 'object') {\n                            const message = reason.message\n                                ? String(reason.message)\n                                : 'Unhandled promise rejection';\n\n                            error = new Error(message);\n                            error.name = reason.name ? String(reason.name) : 'UnhandledRejection';\n\n                            if (reason.stack) {\n                                error.stack = String(reason.stack);\n                            }\n                        } else {\n                            // Primitive value or null/undefined\n                            const message = (reason !== null && reason !== undefined)\n                                ? String(reason)\n                                : 'Unhandled promise rejection (undefined)';\n\n                            error = new Error(message);\n                            error.name = 'UnhandledRejection';\n                        }\n\n                        this.captureException(error, {\n                            extra: {\n                                buffered: true,\n                                bufferedAt: item.timestamp || Date.now(),\n                                type: 'unhandledrejection',\n                            },\n                        });\n\n                        processed++;\n                    } else {\n                        // Unknown item type\n                        if (this.config.debug) {\n                            console.warn('ApplicationLogger: Unknown buffered item type:', item.type);\n                        }\n                        failed++;\n                    }\n                } catch (itemError) {\n                    // Failed to process this specific item - continue with others\n                    failed++;\n                    if (this.config.debug) {\n                        console.error('ApplicationLogger: Failed to process buffered item', itemError);\n                    }\n                }\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Buffered errors processed (${processed} succeeded, ${failed} failed)`);\n            }\n        } catch (error) {\n            // Never crash on buffer processing\n            console.error('ApplicationLogger: Failed to process buffered errors', error);\n        }\n    }\n\n    /**\n     * Capture exception and trigger TWO-PHASE session replay if enabled\n     *\n     * TWO-PHASE ARCHITECTURE:\n     * Phase 1 (Immediate): Send error + pre-error buffer right away\n     * Phase 2 (Recovery): Continue recording, send recovery session separately\n     *\n     * Flow:\n     * 1. Build error payload\n     * 2. If session replay enabled:\n     *    a) Call errorDetector.handleError() to mark buffer and get events\n     *    b) Send error + pre-error replay immediately (don't wait)\n     *    c) Start recording recovery session (async, non-blocking)\n     * 3. If session replay disabled: send error only\n     */\n    async captureException(error, options = {}) {\n        try {\n            // Build error payload\n            const payload = this.buildPayload(error, 'error', options);\n\n            // TWO-PHASE SESSION REPLAY (with defensive null checks)\n            if (this.errorDetector && this.errorDetector.replayBuffer && this.errorDetector.sessionManager) {\n                try {\n                    // CRITICAL: Call handleError() to properly mark the buffer and get events\n                    // This method:\n                    // 1. Marks the current buffer position as \"error occurred\"\n                    // 2. Gets all buffered events (before error)\n                    // 3. Triggers the onErrorDetected callback\n                    // 4. Returns replay context with events\n                    const replayContext = await this.errorDetector.handleError(error, payload);\n\n                    // Defensive: Check if we got replay context with events\n                    let replayData = null;\n                    if (replayContext && replayContext.events && replayContext.events.length > 0) {\n                        // Filter to get only pre-error events\n                        const preErrorEvents = replayContext.events.filter(event =>\n                            event.phase === 'before_error' || event.phase === 'error',\n                        );\n\n                        if (preErrorEvents.length > 0) {\n                            replayData = {\n                                sessionId: replayContext.sessionId,\n                                events: preErrorEvents,\n                                phase: 'pre-error', // Mark as phase 1\n                            };\n\n                            if (this.config.debug) {\n                                console.warn('ApplicationLogger: Sending error with pre-error replay (phase 1)', {\n                                    totalEvents: replayContext.events.length,\n                                    preErrorEvents: preErrorEvents.length,\n                                    sessionId: replayData.sessionId,\n                                });\n                            }\n                        } else if (this.config.debug) {\n                            console.warn('ApplicationLogger: No pre-error events in buffer', {\n                                totalEvents: replayContext.events.length,\n                                bufferStats: this.errorDetector.replayBuffer.getStats(),\n                            });\n                        }\n                    } else if (this.config.debug) {\n                        console.warn('ApplicationLogger: No replay context from error detector', {\n                            hasContext: !!replayContext,\n                            hasEvents: !!(replayContext && replayContext.events),\n                            eventCount: replayContext?.events?.length || 0,\n                            bufferStats: this.errorDetector.replayBuffer.getStats(),\n                        });\n                    }\n\n                    // Send error + pre-error replay immediately\n                    await this.transport.send(payload, replayData);\n\n                    // Phase 2: Start recording recovery session (async, non-blocking)\n                    // This runs in the background and sends separately when complete\n                    // Defensive: Check method exists before calling\n                    if (typeof this.errorDetector.startRecoveryRecording === 'function') {\n                        this.errorDetector.startRecoveryRecording(error).catch(recoveryError => {\n                            if (this.config.debug) {\n                                console.error('ApplicationLogger: Recovery recording failed', recoveryError);\n                            }\n                        });\n                    }\n                } catch (replayError) {\n                    // If session replay fails, still send error without replay data\n                    if (this.config.debug) {\n                        console.error('ApplicationLogger: Session replay failed, sending error without replay', replayError);\n                    }\n                    await this.transport.send(payload);\n                }\n            } else {\n                // No session replay - send error only\n                if (this.config.debug && !this.errorDetector) {\n                    console.warn('ApplicationLogger: Session replay disabled (no error detector)');\n                }\n                await this.transport.send(payload);\n            }\n        } catch (captureError) {\n            // Never crash on error capture\n            console.error('Client: Failed to capture exception', captureError);\n        }\n    }\n\n    /**\n   * Capture message\n   */\n    captureMessage(message, level = 'info', options = {}) {\n        const payload = this.buildPayload(new Error(message), level, options);\n        this.transport.send(payload);\n    }\n\n    /**\n   * Build error payload matching API expectations\n   *\n   * API expects flat structure with snake_case field names:\n   * {type, message, file, line, stack_trace, level, environment, ...}\n   */\n    buildPayload(error, level, options = {}) {\n        try {\n            const stackTrace = this.parseStackTrace(error);\n            const firstFrame = stackTrace.length > 0 ? stackTrace[0] : null;\n\n            // Build payload matching exact API format\n            const payload = {\n                // Required fields (flat structure, not nested)\n                type: error.name || 'Error',\n                message: error.message || 'Unknown error',\n                file: firstFrame?.file || options.extra?.filename || 'unknown',\n                line: firstFrame?.line || options.extra?.lineno || 0,\n                stack_trace: stackTrace,\n\n                // Optional fields (snake_case to match API)\n                level: level || 'error',\n                source: 'frontend',\n                environment: this.config.environment || 'production',\n                release: this.config.release || null,\n                url: window.location.href,\n                http_method: this.detectHttpMethod(),\n                http_status_code: this.extractHttpStatusCode(error, options),\n                session_hash: this.getSessionHash(),\n                session_id: this.sessionManager ? this.sessionManager.getSessionId() : null,\n                timestamp: new Date().toISOString(),\n                runtime: `JavaScript ${this.getBrowserInfo()}`,\n                user_agent: navigator.userAgent,\n                breadcrumbs: this.breadcrumbs.get(),\n                context: { ...this.extra, ...options.extra },\n                tags: { ...this.tags, ...options.tags },\n            };\n\n            // Clean up null values to reduce payload size\n            return this.removeNullValues(payload);\n        } catch (error) {\n            // If payload building completely fails, return minimal payload\n            console.error('ApplicationLogger: Failed to build payload', error);\n            return {\n                type: 'Error',\n                message: 'Failed to build error payload',\n                file: 'unknown',\n                line: 0,\n                stack_trace: [],\n                level: 'error',\n            };\n        }\n    }\n\n    /**\n   * Parse error stack trace with cross-browser support\n   *\n   * Returns array of frames matching API format:\n   * [{file, line, function, class, column}, ...]\n   */\n    parseStackTrace(error) {\n        if (!error.stack) {\n            return [{\n                file: 'unknown',\n                line: 0,\n                function: 'unknown',\n            }];\n        }\n\n        try {\n            const lines = error.stack.split('\\n');\n            const frames = [];\n\n            for (const line of lines) {\n                const frame = this.parseStackLine(line.trim());\n                if (frame) {\n                    frames.push(frame);\n                }\n            }\n\n            return frames.length > 0 ? frames : [{\n                file: 'unknown',\n                line: 0,\n                function: 'unknown',\n            }];\n        } catch {\n            return [{\n                file: 'unknown',\n                line: 0,\n                function: 'unknown',\n            }];\n        }\n    }\n\n    /**\n   * Parse a single stack trace line (cross-browser)\n   *\n   * Handles formats from Chrome, Firefox, Safari, Edge\n   */\n    parseStackLine(line) {\n        if (!line) {\n            return null;\n        }\n\n        // Chrome/V8: \"at functionName (file.js:line:col)\"\n        let match = line.match(/at\\s+(.+?)\\s+\\((.+?):(\\d+):(\\d+)\\)/);\n        if (match) {\n            return {\n                function: match[1].trim(),\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Chrome/V8 anonymous: \"at file.js:line:col\"\n        match = line.match(/at\\s+(.+?):(\\d+):(\\d+)/);\n        if (match) {\n            return {\n                function: 'anonymous',\n                file: match[1],\n                line: parseInt(match[2], 10),\n                column: parseInt(match[3], 10),\n            };\n        }\n\n        // Firefox: \"functionName@file.js:line:col\"\n        match = line.match(/(.+?)@(.+?):(\\d+):(\\d+)/);\n        if (match) {\n            return {\n                function: match[1] || 'anonymous',\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Safari/Firefox (no column): \"functionName@file.js:line\"\n        match = line.match(/(?:(.+)@)?(.+?):(\\d+)$/);\n        if (match) {\n            return {\n                function: match[1] || 'anonymous',\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: null,\n            };\n        }\n\n        // Edge legacy: \"at functionName (file.js:line:col)\"\n        match = line.match(/at\\s+(.+?)\\s+\\[(.+?):(\\d+):(\\d+)\\]/);\n        if (match) {\n            return {\n                function: match[1].trim(),\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Could not parse this line\n        return null;\n    }\n\n    /**\n   * Detect HTTP method for current page load\n   */\n    detectHttpMethod() {\n        try {\n            // Try to detect from performance API\n            const navigation = performance.getEntriesByType('navigation')[0];\n            if (navigation && navigation.type) {\n                // Navigation types: navigate, reload, back_forward, prerender\n                return 'GET'; // Page loads are always GET\n            }\n        } catch {\n            // Performance API not available\n        }\n\n        // Default to GET (most common for page loads)\n        return 'GET';\n    }\n\n    /**\n     * Extract HTTP status code from error context.\n     *\n     * Attempts to extract status code from:\n     * 1. Error object's status property (fetch Response)\n     * 2. Options extra data (manually passed)\n     * 3. Error message parsing (e.g., \"HTTP 404 Not Found\")\n     *\n     * @param {Error} error - The error object\n     * @param {Object} options - Additional options passed to captureException\n     * @returns {number|null} HTTP status code or null if not available\n     */\n    extractHttpStatusCode(error, options = {}) {\n        try {\n            // Check if error has status property (fetch Response errors)\n            if (error.status && typeof error.status === 'number') {\n                return error.status;\n            }\n\n            // Check if status was passed in options\n            if (options.httpStatusCode && typeof options.httpStatusCode === 'number') {\n                return options.httpStatusCode;\n            }\n\n            // Check extra context for status code\n            if (options.extra?.http_status_code && typeof options.extra.http_status_code === 'number') {\n                return options.extra.http_status_code;\n            }\n\n            if (options.extra?.httpStatusCode && typeof options.extra.httpStatusCode === 'number') {\n                return options.extra.httpStatusCode;\n            }\n\n            // Try to parse status code from error message (e.g., \"HTTP 404 Not Found\")\n            if (error.message) {\n                const match = error.message.match(/HTTP\\s+(\\d{3})/i);\n                if (match) {\n                    const status = parseInt(match[1], 10);\n                    if (status >= 100 && status < 600) {\n                        return status;\n                    }\n                }\n            }\n\n            // No HTTP status code available\n            return null;\n        } catch {\n            // If extraction fails, return null\n            return null;\n        }\n    }\n\n    /**\n   * Get browser info from user agent\n   */\n    getBrowserInfo() {\n        const ua = navigator.userAgent;\n\n        if (ua.includes('Chrome') && !ua.includes('Edge')) {\n            return 'Chrome';\n        }\n        if (ua.includes('Firefox')) {\n            return 'Firefox';\n        }\n        if (ua.includes('Safari') && !ua.includes('Chrome')) {\n            return 'Safari';\n        }\n        if (ua.includes('Edge') || ua.includes('Edg/')) {\n            return 'Edge';\n        }\n        if (ua.includes('MSIE') || ua.includes('Trident/')) {\n            return 'IE';\n        }\n\n        return 'Unknown';\n    }\n\n    /**\n     * Get session hash for GDPR-compliant session tracking\n     *\n     * Priority:\n     * 1. Use sessionHash from config if provided by server (Symfony bundle)\n     * 2. Generate from sessionStorage if available\n     * 3. Return null (errors will be tracked without session linkage)\n     *\n     * @returns {string|null} SHA-256 hash of session ID (64 hex chars)\n     */\n    getSessionHash() {\n        try {\n            // 1. Check if server provided session hash (Symfony bundle sets this)\n            if (this.config.sessionHash) {\n                return this.config.sessionHash;\n            }\n\n            // 2. Try to get/generate from sessionStorage\n            if (typeof sessionStorage !== 'undefined') {\n                let sessionId = sessionStorage.getItem('_app_logger_session_id');\n\n                if (!sessionId) {\n                    // Generate new session ID for this browser session\n                    sessionId = this.generateSessionId();\n                    sessionStorage.setItem('_app_logger_session_id', sessionId);\n                }\n\n                // Generate SHA-256 hash synchronously (simple implementation)\n                return this.sha256(sessionId);\n            }\n\n            // 3. No session tracking available\n            return null;\n        } catch {\n            // If session tracking fails, return null (errors still captured)\n            return null;\n        }\n    }\n\n    /**\n     * Generate a unique session ID for client-side session tracking\n     *\n     * @returns {string} Random session ID\n     */\n    generateSessionId() {\n        // Use crypto.randomUUID if available (modern browsers)\n        if (crypto && crypto.randomUUID) {\n            return crypto.randomUUID();\n        }\n\n        // Fallback: Generate random string\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = Math.random() * 16 | 0;\n            const v = c === 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n\n    /**\n     * Simple synchronous SHA-256 implementation\n     *\n     * This is a simplified hash function for client-side session hashing.\n     * While not cryptographically secure for production use, it's sufficient\n     * for generating consistent session hashes for tracking purposes.\n     *\n     * @param {string} str - String to hash\n     * @returns {string} 64-character hexadecimal hash\n     */\n    sha256(str) {\n        // Simple djb2-like hash (not real SHA-256, but consistent and sufficient)\n        let hash = 5381;\n        for (let i = 0; i < str.length; i++) {\n            hash = ((hash << 5) + hash) + str.charCodeAt(i);\n        }\n\n        // Convert to hex and pad to 64 characters for consistency with PHP hash('sha256')\n        // This is a simplified version - for production, consider using Web Crypto API\n        const hex = Math.abs(hash).toString(16);\n        return hex.padStart(64, '0');\n    }\n\n    /**\n   * Remove null/undefined values from object to reduce payload size\n   */\n    removeNullValues(obj) {\n        const cleaned = {};\n\n        for (const [key, value] of Object.entries(obj)) {\n            if (value !== null && value !== undefined) {\n                cleaned[key] = value;\n            }\n        }\n\n        return cleaned;\n    }\n\n    setUser(user) {\n        this.userContext = user;\n    }\n\n    setTags(tags) {\n        this.tags = { ...this.tags, ...tags };\n    }\n\n    setExtra(extra) {\n        this.extra = { ...this.extra, ...extra };\n    }\n\n    /**\n     * Flush pending errors using Beacon API\n     * Called on page unload to ensure critical errors are sent\n     */\n    flushBeaconErrors() {\n        try {\n            // Check if Beacon API is available\n            if (!navigator.sendBeacon) {\n                return;\n            }\n\n            // Get transport stats to check for pending errors\n            const stats = this.transport.getStats();\n\n            if (stats.storedErrors === 0 && stats.queueSize === 0) {\n                return; // Nothing to flush\n            }\n\n            // Delegate to transport's beacon flush method\n            this.transport.flushWithBeacon();\n        } catch {\n            // Never crash on flush - but this is our last chance to send errors\n            // So we silently fail\n        }\n    }\n}\n","/**\n * Breadcrumb collector for tracking user actions\n *\n * ZERO-CONFIG ERROR CAPTURE:\n * When console.error() is called with an Error object, automatically\n * captures it and sends to API. This provides zero-config tracking for\n * the common pattern: .catch(err => console.error('Failed:', err))\n */\nexport class BreadcrumbCollector {\n    constructor(maxBreadcrumbs = 50, errorCaptureCallback = null) {\n        this.breadcrumbs = [];\n        this.maxBreadcrumbs = maxBreadcrumbs;\n        this.installed = false; // Track installation state\n        this.errorCaptureCallback = errorCaptureCallback; // Callback to capture errors automatically\n    }\n\n    /**\n   * Install automatic breadcrumb tracking (idempotent)\n   */\n    install() {\n        // Guard against multiple installations\n        if (this.installed) {\n            return;\n        }\n\n        this.installed = true;\n\n        // Track clicks\n        document.addEventListener('click', (event) => {\n            const target = event.target;\n            const tagName = target.tagName.toLowerCase();\n            let message = `Clicked ${tagName}`;\n\n            // Get className as string (handle SVG elements)\n            const getClassName = (element) => {\n                if (!element.className) return '';\n                // For SVG elements, className is an SVGAnimatedString\n                if (typeof element.className === 'object' && element.className.baseVal !== undefined) {\n                    return element.className.baseVal;\n                }\n                // For HTML elements, className is a string\n                return element.className;\n            };\n\n            const className = getClassName(target);\n\n            if (target.id) {\n                message += `#${target.id}`;\n            } else if (className) {\n                const firstClass = className.split(' ')[0];\n                if (firstClass) {\n                    message += `.${firstClass}`;\n                }\n            }\n\n            this.add({\n                type: 'ui',\n                category: 'click',\n                message,\n                data: {\n                    tag: tagName,\n                    id: target.id,\n                    class: className,\n                },\n            });\n        }, true);\n\n        // Track navigation\n        const originalPushState = history.pushState;\n        const originalReplaceState = history.replaceState;\n\n        history.pushState = (...args) => {\n            this.add({\n                type: 'navigation',\n                category: 'navigation',\n                message: `Navigated to ${args[2]}`,\n                data: { to: args[2] },\n            });\n            return originalPushState.apply(history, args);\n        };\n\n        history.replaceState = (...args) => {\n            this.add({\n                type: 'navigation',\n                category: 'navigation',\n                message: `Replaced state ${args[2]}`,\n                data: { to: args[2] },\n            });\n            return originalReplaceState.apply(history, args);\n        };\n\n        // Track console messages\n        this.wrapConsole();\n\n        // Track fetch requests\n        this.wrapFetch();\n    }\n\n    /**\n   * Add a breadcrumb\n   */\n    add(breadcrumb) {\n        this.breadcrumbs.push({\n            timestamp: new Date().toISOString(),\n            level: breadcrumb.level || 'info',\n            ...breadcrumb,\n        });\n\n        // Limit breadcrumbs\n        if (this.breadcrumbs.length > this.maxBreadcrumbs) {\n            this.breadcrumbs.shift();\n        }\n    }\n\n    /**\n   * Get all breadcrumbs\n   */\n    get() {\n        return this.breadcrumbs;\n    }\n\n    /**\n   * Clear breadcrumbs\n   */\n    clear() {\n        this.breadcrumbs = [];\n    }\n\n    /**\n   * Wrap console methods for breadcrumb tracking\n   *\n   * CRITICAL: Original console method is called FIRST to ensure console works\n   * even if breadcrumb tracking fails. Breadcrumb logic is wrapped in try-catch\n   * to prevent any failures from breaking console functionality.\n   *\n   * ZERO-CONFIG ERROR CAPTURE:\n   * When console.error() is called with an Error object, automatically captures\n   * it via errorCaptureCallback. This enables zero-config error tracking for the\n   * common pattern: .catch(err => console.error('message', err))\n   */\n    wrapConsole() {\n        const levels = ['log', 'info', 'warn', 'error', 'debug'];\n\n        levels.forEach(level => {\n            // eslint-disable-next-line no-console\n            const original = console[level];\n\n            // Safety check - ensure original is a function\n            if (typeof original !== 'function') {\n                return; // Skip this level if not a function\n            }\n\n            // eslint-disable-next-line no-console\n            console[level] = (...args) => {\n                // ZERO-CONFIG ERROR CAPTURE (BEFORE console output)\n                // Must happen BEFORE original.apply to avoid recursion issues\n                if (level === 'error' && this.errorCaptureCallback) {\n                    try {\n                        // Look for Error objects in arguments\n                        const errorObj = args.find(arg => arg instanceof Error);\n                        if (errorObj) {\n                            // Automatically capture this error\n                            if (typeof this.errorCaptureCallback === 'function') {\n                                this.errorCaptureCallback(errorObj, {\n                                    extra: {\n                                        consoleError: true,\n                                        consoleMessage: args.filter(arg => !(arg instanceof Error))\n                                            .map(arg => String(arg))\n                                            .join(' '),\n                                    },\n                                });\n                            }\n                        }\n                    } catch (captureError) {\n                        // Log the actual error instead of silently failing\n                        // Use native console to avoid recursion\n                        if (typeof original === 'function') {\n                            try {\n                                original.call(console, 'ApplicationLogger: Failed to auto-capture error:', captureError);\n                            } catch {\n                                // Absolute last resort - do nothing\n                            }\n                        }\n                    }\n                }\n\n                let result;\n\n                // Call original console method\n                try {\n                    result = original.apply(console, args);\n                } catch {\n                    // Native console threw (very rare) - fail silently\n                    // Don't rethrow - would break all console calls\n                }\n\n                // Then try to add breadcrumb (wrapped in try-catch)\n                try {\n                    // Safely serialize arguments to prevent:\n                    // - toString() errors\n                    // - Circular reference errors\n                    // - Non-serializable objects (DOM nodes, functions)\n                    const safeArgs = args.map(arg => {\n                        if (arg === null) return 'null';\n                        if (arg === undefined) return 'undefined';\n\n                        // Special handling for Error objects\n                        if (arg instanceof Error) {\n                            return `${arg.name}: ${arg.message}`;\n                        }\n\n                        // Handle objects (try JSON serialization, fallback to string)\n                        if (typeof arg === 'object') {\n                            try {\n                                return JSON.stringify(arg);\n                            } catch {\n                                // Circular reference or non-serializable\n                                return Object.prototype.toString.call(arg);\n                            }\n                        }\n\n                        // Primitives\n                        return String(arg);\n                    });\n\n                    this.add({\n                        type: 'console',\n                        category: 'console',\n                        message: safeArgs.join(' '),\n                        level: level === 'log' ? 'info' : level,\n                        data: { arguments: safeArgs },\n                    });\n                } catch {\n                    // Never crash breadcrumb tracking\n                    // Don't use console.error here to avoid infinite recursion\n                    // Silently fail - breadcrumb loss is better than breaking console\n                }\n\n                return result;\n            };\n        });\n    }\n\n    /**\n   * Wrap fetch for HTTP request breadcrumbs\n   */\n    wrapFetch() {\n        const originalFetch = window.fetch;\n\n        window.fetch = async (...args) => {\n            const url = typeof args[0] === 'string' ? args[0] : args[0].url;\n            const method = args[1]?.method || 'GET';\n            const startTime = Date.now();\n\n            try {\n                const response = await originalFetch.apply(window, args);\n                const duration = Date.now() - startTime;\n\n                this.add({\n                    type: 'http',\n                    category: 'fetch',\n                    message: `${method} ${url}`,\n                    data: {\n                        url,\n                        method,\n                        status_code: response.status,\n                        duration,\n                    },\n                    level: response.ok ? 'info' : 'warning',\n                });\n\n                return response;\n            } catch (error) {\n                const duration = Date.now() - startTime;\n\n                this.add({\n                    type: 'http',\n                    category: 'fetch',\n                    message: `${method} ${url} failed`,\n                    data: {\n                        url,\n                        method,\n                        error: error.message,\n                        duration,\n                    },\n                    level: 'error',\n                });\n\n                throw error;\n            }\n        };\n    }\n}\n","/**\n * Circuit Breaker for JavaScript\n *\n * Implements the circuit breaker pattern to prevent repeated calls to a failing service.\n * Uses sessionStorage to persist state across page reloads within the same session.\n *\n * States:\n * - CLOSED: Normal operation, requests go through\n * - OPEN: Service is down, requests are blocked immediately\n * - HALF_OPEN: Testing if service has recovered\n */\nexport class CircuitBreaker {\n    static STATE_CLOSED = 'closed';\n    static STATE_OPEN = 'open';\n    static STATE_HALF_OPEN = 'half_open';\n\n    constructor(config = {}) {\n        this.failureThreshold = config.failureThreshold || 5;\n        this.timeout = config.timeout || 60000; // 60 seconds in milliseconds\n        this.storageKey = 'app_logger_circuit_breaker';\n\n        this.loadState();\n    }\n\n    /**\n     * Check if circuit is open (service down, reject requests)\n     */\n    isOpen() {\n        // Check if we should transition from OPEN to HALF_OPEN\n        if (this.state === CircuitBreaker.STATE_OPEN && this.shouldAttemptReset()) {\n            this.halfOpen();\n        }\n\n        return this.state === CircuitBreaker.STATE_OPEN;\n    }\n\n    /**\n     * Check if circuit is in half-open state\n     */\n    isHalfOpen() {\n        return this.state === CircuitBreaker.STATE_HALF_OPEN;\n    }\n\n    /**\n     * Record a successful request\n     */\n    recordSuccess() {\n        if (this.state === CircuitBreaker.STATE_HALF_OPEN) {\n            // Success in half-open = circuit closes (service recovered)\n            this.close();\n        } else if (this.state === CircuitBreaker.STATE_CLOSED) {\n            // Reset failure count on success\n            this.failureCount = 0;\n            this.saveState();\n        }\n    }\n\n    /**\n     * Record a failed request\n     */\n    recordFailure() {\n        if (this.state === CircuitBreaker.STATE_HALF_OPEN) {\n            // Failure in half-open = circuit opens again\n            this.open();\n        } else if (this.state === CircuitBreaker.STATE_CLOSED) {\n            this.failureCount++;\n\n            if (this.failureCount >= this.failureThreshold) {\n                this.open();\n            } else {\n                this.saveState();\n            }\n        }\n    }\n\n    /**\n     * Get current state for monitoring/debugging\n     */\n    getState() {\n        return {\n            state: this.state,\n            failureCount: this.failureCount,\n            openedAt: this.openedAt,\n        };\n    }\n\n    /**\n     * Manually reset circuit breaker\n     */\n    reset() {\n        this.close();\n    }\n\n    /**\n     * Transition to CLOSED state\n     */\n    close() {\n        this.state = CircuitBreaker.STATE_CLOSED;\n        this.failureCount = 0;\n        this.openedAt = null;\n        this.saveState();\n    }\n\n    /**\n     * Transition to OPEN state\n     */\n    open() {\n        this.state = CircuitBreaker.STATE_OPEN;\n        this.openedAt = Date.now();\n        this.saveState();\n    }\n\n    /**\n     * Transition to HALF_OPEN state\n     */\n    halfOpen() {\n        this.state = CircuitBreaker.STATE_HALF_OPEN;\n        this.saveState();\n    }\n\n    /**\n     * Check if enough time has passed to attempt reset\n     */\n    shouldAttemptReset() {\n        if (!this.openedAt) {\n            return false;\n        }\n\n        return (Date.now() - this.openedAt) >= this.timeout;\n    }\n\n    /**\n     * Load state from sessionStorage\n     */\n    loadState() {\n        try {\n            const stored = sessionStorage.getItem(this.storageKey);\n\n            if (stored) {\n                const state = JSON.parse(stored);\n                this.state = state.state || CircuitBreaker.STATE_CLOSED;\n                this.failureCount = state.failureCount || 0;\n                this.openedAt = state.openedAt || null;\n            } else {\n                this.state = CircuitBreaker.STATE_CLOSED;\n                this.failureCount = 0;\n                this.openedAt = null;\n            }\n        } catch {\n            // If storage fails, default to closed state\n            this.state = CircuitBreaker.STATE_CLOSED;\n            this.failureCount = 0;\n            this.openedAt = null;\n        }\n    }\n\n    /**\n     * Save state to sessionStorage\n     */\n    saveState() {\n        try {\n            const state = {\n                state: this.state,\n                failureCount: this.failureCount,\n                openedAt: this.openedAt,\n            };\n\n            sessionStorage.setItem(this.storageKey, JSON.stringify(state));\n        } catch {\n            // Storage failure should never crash the app\n            // Circuit breaker still works in-memory for this page\n        }\n    }\n}\n","/**\n * Local Storage Queue\n *\n * Buffers failed error submissions in localStorage for later retry.\n * Used when the API is unreachable or circuit breaker is open.\n *\n * Features:\n * - FIFO queue with size limits\n * - Automatic expiration of old errors\n * - Safe storage operations (never crash on quota exceeded)\n */\nexport class StorageQueue {\n    constructor(config = {}) {\n        this.storageKey = 'app_logger_queue';\n        this.maxSize = config.maxSize || 50; // Max errors to store\n        this.maxAge = config.maxAge || 86400000; // 24 hours in milliseconds\n    }\n\n    /**\n     * Add an error to the queue\n     */\n    enqueue(payload) {\n        try {\n            const queue = this.getQueue();\n\n            // Add timestamp for expiration\n            const item = {\n                payload,\n                timestamp: Date.now(),\n            };\n\n            queue.push(item);\n\n            // Limit queue size (FIFO - remove oldest)\n            if (queue.length > this.maxSize) {\n                queue.shift();\n            }\n\n            this.saveQueue(queue);\n        } catch (error) {\n            // Storage failures should never crash the app\n            // Common causes: quota exceeded, private browsing mode\n            console.warn('ApplicationLogger: Failed to queue error', error);\n        }\n    }\n\n    /**\n     * Get next error from queue (FIFO)\n     */\n    dequeue() {\n        try {\n            const queue = this.getQueue();\n\n            if (queue.length === 0) {\n                return null;\n            }\n\n            const item = queue.shift();\n            this.saveQueue(queue);\n\n            return item.payload;\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Get all queued errors\n     */\n    getAll() {\n        const queue = this.getQueue();\n        return queue.map(item => item.payload);\n    }\n\n    /**\n     * Get queue size\n     */\n    size() {\n        const queue = this.getQueue();\n        return queue.length;\n    }\n\n    /**\n     * Clear the queue\n     */\n    clear() {\n        try {\n            localStorage.removeItem(this.storageKey);\n        } catch {\n            // Ignore\n        }\n    }\n\n    /**\n     * Get queue from localStorage with expiration cleanup\n     */\n    getQueue() {\n        try {\n            const stored = localStorage.getItem(this.storageKey);\n\n            if (!stored) {\n                return [];\n            }\n\n            const queue = JSON.parse(stored);\n\n            if (!Array.isArray(queue)) {\n                return [];\n            }\n\n            // Remove expired items\n            const now = Date.now();\n            const filtered = queue.filter(item => {\n                return item.timestamp && (now - item.timestamp) < this.maxAge;\n            });\n\n            // If we removed expired items, save the cleaned queue\n            if (filtered.length !== queue.length) {\n                this.saveQueue(filtered);\n            }\n\n            return filtered;\n        } catch {\n            return [];\n        }\n    }\n\n    /**\n     * Save queue to localStorage\n     */\n    saveQueue(queue) {\n        try {\n            localStorage.setItem(this.storageKey, JSON.stringify(queue));\n        } catch (error) {\n            // Handle quota exceeded or other storage errors\n            if (error.name === 'QuotaExceededError') {\n                // Try to make space by removing oldest items\n                const halfSize = Math.floor(queue.length / 2);\n                const trimmed = queue.slice(-halfSize);\n\n                try {\n                    localStorage.setItem(this.storageKey, JSON.stringify(trimmed));\n                } catch {\n                    // If still failing, clear the queue\n                    this.clear();\n                }\n            }\n        }\n    }\n}\n","/**\n * Rate Limiter\n *\n * Prevents error storms by limiting the number of errors sent per minute.\n * Uses token bucket algorithm for smooth rate limiting.\n *\n * This is critical for resilience - prevents overwhelming the API\n * and consuming excessive bandwidth during error cascades.\n */\nexport class RateLimiter {\n    constructor(config = {}) {\n        this.maxTokens = config.maxTokens || 10; // Max errors per window\n        this.refillRate = config.refillRate || 1; // Tokens per second\n        this.tokens = this.maxTokens;\n        this.lastRefill = Date.now();\n    }\n\n    /**\n     * Check if request is allowed\n     */\n    isAllowed() {\n        this.refillTokens();\n        return this.tokens > 0;\n    }\n\n    /**\n     * Consume a token (record an error sent)\n     */\n    consume() {\n        if (!this.isAllowed()) {\n            return false;\n        }\n\n        this.tokens--;\n        return true;\n    }\n\n    /**\n     * Refill tokens based on time elapsed\n     */\n    refillTokens() {\n        const now = Date.now();\n        const elapsed = (now - this.lastRefill) / 1000; // Convert to seconds\n        const tokensToAdd = Math.floor(elapsed * this.refillRate);\n\n        if (tokensToAdd > 0) {\n            this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);\n            this.lastRefill = now;\n        }\n    }\n\n    /**\n     * Get current token count (for debugging)\n     */\n    getTokens() {\n        this.refillTokens();\n        return this.tokens;\n    }\n\n    /**\n     * Reset rate limiter\n     */\n    reset() {\n        this.tokens = this.maxTokens;\n        this.lastRefill = Date.now();\n    }\n}\n","import { CircuitBreaker } from './circuit-breaker.js';\nimport { StorageQueue } from './storage-queue.js';\nimport { RateLimiter } from './rate-limiter.js';\n\n/**\n * Transport layer for sending errors to the platform\n *\n * RESILIENCE FEATURES:\n * - 3-second timeout with AbortController\n * - Circuit breaker prevents repeated calls to failing service\n * - Smart retry with exponential backoff\n * - Local storage queue for offline errors\n * - Rate limiting to prevent error storms\n * - Deduplication to avoid duplicate errors\n */\nexport class Transport {\n    constructor(config) {\n        this.config = config;\n        this.apiKey = config.apiKey; // Store API key separately (not in DSN)\n        this.dsn = this.parseDsn(config.dsn);\n        this.queue = [];\n        this.sending = false;\n\n        // Initialize resilience components\n        this.circuitBreaker = new CircuitBreaker({\n            failureThreshold: 5,\n            timeout: 60000, // 60 seconds\n        });\n\n        this.storageQueue = new StorageQueue({\n            maxSize: 50,\n            maxAge: 86400000, // 24 hours\n        });\n\n        this.rateLimiter = new RateLimiter({\n            maxTokens: 10, // Max 10 errors per minute\n            refillRate: 0.167, // Refill ~10 tokens per minute\n        });\n\n        // Deduplication cache\n        this.recentErrors = new Map();\n        this.deduplicationWindow = 5000; // 5 seconds\n\n        // Try to flush stored errors on init\n        this.flushStoredErrors();\n    }\n\n    /**\n   * Parse DSN into components\n   *\n   * DSN format: {protocol}://{host}/{projectId}\n   * Example: https://localhost:8111/b6d8ed85-c0af-4c02-b6bb-bfb0f3609b37\n   *\n   * Note: API key is NOT in the DSN. It's passed separately via config.apiKey.\n   */\n    parseDsn(dsn) {\n        if (!dsn) {\n            throw new Error('DSN is required');\n        }\n\n        try {\n            const url = new URL(dsn);\n            const projectId = url.pathname.replace(/^\\//, ''); // Remove leading slash\n\n            if (!projectId) {\n                throw new Error('DSN must include a project ID in the path');\n            }\n\n            return {\n                protocol: url.protocol.replace(':', ''),\n                host: url.host,\n                projectId: projectId,\n                endpoint: `${url.protocol}//${url.host}/api/errors/ingest`,\n            };\n        } catch (error) {\n            throw new Error(`Invalid DSN format: ${error.message}. Expected: https://host/project-id`);\n        }\n    }\n\n    /**\n   * Send error payload to platform\n   *\n   * @param {Object} payload - Error payload\n   * @param {Object|null} replayData - Optional session replay data\n   * @param {string} replayData.sessionId - Session ID from SessionManager\n   * @param {Array} replayData.events - Buffered events (before + after error)\n   */\n    async send(payload, replayData = null) {\n        try {\n            // Merge replay data into payload if provided\n            let enhancedPayload = payload;\n            if (replayData) {\n                enhancedPayload = {\n                    ...payload,\n                    replay_session_id: replayData.sessionId,\n                    replay_data: replayData.events,\n                };\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Sending error with replay data', {\n                        sessionId: replayData.sessionId,\n                        eventCount: replayData.events?.length || 0,\n                    });\n                }\n            }\n\n            // Scrub sensitive data\n            const scrubbedPayload = this.scrubSensitiveData(enhancedPayload);\n\n            // Check for duplicates\n            if (this.isDuplicate(scrubbedPayload)) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Duplicate error ignored');\n                }\n                return;\n            }\n\n            // Check rate limit\n            if (!this.rateLimiter.consume()) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Rate limit exceeded, error queued');\n                }\n                this.storageQueue.enqueue(scrubbedPayload);\n                return;\n            }\n\n            // Add to queue\n            this.queue.push(scrubbedPayload);\n\n            // Process queue\n            if (!this.sending) {\n                await this.processQueue();\n            }\n        } catch (error) {\n            // Never crash on send errors\n            console.error('ApplicationLogger: Send failed', error);\n        }\n    }\n\n    /**\n     * Send recovery session (Phase 2 of two-phase session replay)\n     *\n     * This is sent separately after the initial error + pre-error data.\n     * Recovery sessions show user actions AFTER the error occurred.\n     *\n     * @param {Object} recoveryPayload - Recovery session payload\n     * @param {string} recoveryPayload.sessionId - Session ID\n     * @param {Array} recoveryPayload.events - Recovery events (after error)\n     * @param {string} [recoveryPayload.capturedAt] - ISO 8601 timestamp\n     * @param {string} [recoveryPayload.url] - Current URL\n     * @param {boolean} [useBeacon=false] - Use sendBeacon API for reliable unload transmission\n     */\n    async sendRecoverySession(recoveryPayload, useBeacon = false) {\n        try {\n            // Use dedicated recovery session endpoint\n            const endpoint = `${this.dsn.protocol}://${this.dsn.host}/api/errors/recovery-session`;\n\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Sending recovery session', {\n                    sessionId: recoveryPayload.sessionId,\n                    eventCount: recoveryPayload.events?.length || 0,\n                    method: useBeacon ? 'sendBeacon' : 'fetch',\n                });\n            }\n\n            // Use sendBeacon for page unload (synchronous, guaranteed delivery)\n            if (useBeacon && navigator.sendBeacon) {\n                const blob = new Blob([JSON.stringify(recoveryPayload)], {\n                    type: 'application/json',\n                });\n\n                const sent = navigator.sendBeacon(endpoint, blob);\n\n                if (sent) {\n                    if (this.config.debug) {\n                        console.warn('ApplicationLogger: Recovery session queued via sendBeacon');\n                    }\n                    return { success: true, method: 'beacon' };\n                } else {\n                    throw new Error('sendBeacon failed (queue full or too large)');\n                }\n            }\n\n            // Fallback to fetch (normal case)\n            // Create AbortController for timeout\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), 5000); // 5-second timeout (longer for recovery)\n\n            const response = await fetch(endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey,\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify(recoveryPayload),\n                signal: controller.signal,\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                throw new Error(`Recovery session send failed: ${response.status}`);\n            }\n\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Recovery session sent successfully');\n            }\n\n            return response.json();\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to send recovery session', error);\n\n            // Store in queue for retry (best effort)\n            try {\n                this.storageQueue.enqueue({\n                    type: 'recovery',\n                    payload: recoveryPayload,\n                });\n            } catch (queueError) {\n                console.error('ApplicationLogger: Failed to queue recovery session', queueError);\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n   * Process queued errors\n   */\n    async processQueue() {\n        if (this.queue.length === 0 || this.sending) {\n            return;\n        }\n\n        this.sending = true;\n\n        while (this.queue.length > 0) {\n            const payload = this.queue.shift();\n\n            try {\n                await this.sendToApi(payload);\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Error sent successfully');\n                }\n            } catch {\n                // Error already handled in sendToApi\n                // Don't re-queue here as sendToApi handles storage\n            }\n        }\n\n        this.sending = false;\n    }\n\n    /**\n   * Send payload to API with timeout and retry\n   */\n    async sendToApi(payload, attempt = 0) {\n        // Check circuit breaker\n        if (this.circuitBreaker.isOpen()) {\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Circuit breaker is open, error queued to storage');\n            }\n            this.storageQueue.enqueue(payload);\n            return;\n        }\n\n        // Create AbortController for timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 3000); // 3-second timeout\n\n        try {\n            const response = await fetch(this.dsn.endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey, // Use separate API key, not from DSN\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify(payload),\n                signal: controller.signal,\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n\n            // Success!\n            this.circuitBreaker.recordSuccess();\n\n            // Try to flush stored errors on success\n            this.flushStoredErrors();\n\n            return response.json();\n        } catch (error) {\n            clearTimeout(timeoutId);\n\n            // Handle timeout\n            if (error.name === 'AbortError') {\n                this.circuitBreaker.recordFailure();\n\n                if (this.config.debug) {\n                    console.error('ApplicationLogger: Request timeout');\n                }\n\n                this.storageQueue.enqueue(payload);\n                return;\n            }\n\n            // Handle network errors with retry\n            if (attempt < 2) {\n                // Exponential backoff: 1s, 2s\n                const delay = Math.pow(2, attempt) * 1000;\n                await this.delay(delay);\n\n                return this.sendToApi(payload, attempt + 1);\n            }\n\n            // Max retries reached\n            this.circuitBreaker.recordFailure();\n\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Max retries reached', error);\n            }\n\n            this.storageQueue.enqueue(payload);\n        }\n    }\n\n    /**\n   * Check if error is a duplicate\n   */\n    isDuplicate(payload) {\n        try {\n            // Create hash from error signature\n            const signature = JSON.stringify({\n                type: payload.exception?.type,\n                message: payload.exception?.value,\n                stack: payload.exception?.stacktrace?.frames?.slice(0, 3), // Top 3 frames\n            });\n\n            const hash = this.simpleHash(signature);\n\n            // Check if we've seen this recently\n            if (this.recentErrors.has(hash)) {\n                return true;\n            }\n\n            // Add to recent errors\n            this.recentErrors.set(hash, Date.now());\n\n            // Clean up old entries\n            const now = Date.now();\n            for (const [key, timestamp] of this.recentErrors) {\n                if (now - timestamp > this.deduplicationWindow) {\n                    this.recentErrors.delete(key);\n                }\n            }\n\n            return false;\n        } catch {\n            return false; // If deduplication fails, allow the error through\n        }\n    }\n\n    /**\n   * Simple hash function\n   */\n    simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            const char = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // Convert to 32bit integer\n        }\n        return hash.toString();\n    }\n\n    /**\n   * Flush errors from storage queue\n   */\n    async flushStoredErrors() {\n        try {\n            const queueSize = this.storageQueue.size();\n\n            if (queueSize === 0) {\n                return;\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Flushing ${queueSize} stored errors`);\n            }\n\n            // Limit flush to 5 errors at a time to avoid overwhelming\n            const limit = Math.min(queueSize, 5);\n\n            for (let i = 0; i < limit; i++) {\n                const payload = this.storageQueue.dequeue();\n\n                if (payload) {\n                    // Add to queue (but don't recurse infinitely)\n                    this.queue.push(payload);\n                }\n            }\n\n            // Process the queue\n            if (!this.sending && this.queue.length > 0) {\n                await this.processQueue();\n            }\n        } catch (error) {\n            // Never crash on flush\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Flush failed', error);\n            }\n        }\n    }\n\n    /**\n   * Delay helper for retry backoff\n   */\n    delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    /**\n   * Scrub sensitive data from payload\n   */\n    scrubSensitiveData(payload) {\n        const scrubFields = this.config.scrubFields || [];\n        const scrubPatterns = [\n            ...scrubFields,\n            'password',\n            'passwd',\n            'pwd',\n            'secret',\n            'api_key',\n            'apikey',\n            'token',\n            'auth',\n            'authorization',\n            'private_key',\n            'access_token',\n            'refresh_token',\n        ];\n\n        // Deep clone payload (handle circular references)\n        let scrubbed;\n        try {\n            scrubbed = JSON.parse(JSON.stringify(payload));\n        } catch {\n            // Circular reference detected - work with original and remove circular refs\n            scrubbed = this.removeCircularReferences(payload);\n        }\n\n        // Recursively scrub object\n        const scrubObject = (obj) => {\n            if (!obj || typeof obj !== 'object') {\n                return obj;\n            }\n\n            for (const key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    // Check if key matches scrub pattern\n                    const shouldScrub = scrubPatterns.some(pattern =>\n                        key.toLowerCase().includes(pattern.toLowerCase()),\n                    );\n\n                    if (shouldScrub) {\n                        obj[key] = '[REDACTED]';\n                    } else if (typeof obj[key] === 'object') {\n                        scrubObject(obj[key]);\n                    }\n                }\n            }\n\n            return obj;\n        };\n\n        return scrubObject(scrubbed);\n    }\n\n    /**\n     * Remove circular references from an object.\n     * Uses a WeakSet to track visited objects and prevent infinite loops.\n     *\n     * @param {Object} obj - Object to process\n     * @param {WeakSet} [seen] - Set of already visited objects\n     * @returns {Object} Object with circular references replaced\n     */\n    removeCircularReferences(obj, seen = new WeakSet()) {\n        // Handle primitives and null\n        if (obj === null || typeof obj !== 'object') {\n            return obj;\n        }\n\n        // Handle circular reference\n        if (seen.has(obj)) {\n            return '[Circular Reference]';\n        }\n\n        // Add to seen set\n        seen.add(obj);\n\n        // Handle arrays\n        if (Array.isArray(obj)) {\n            return obj.map(item => this.removeCircularReferences(item, seen));\n        }\n\n        // Handle objects\n        const result = {};\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                try {\n                    result[key] = this.removeCircularReferences(obj[key], seen);\n                } catch {\n                    // Skip properties that throw errors when accessed\n                    result[key] = '[Error accessing property]';\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Send session event to API\n     */\n    async sendSessionEvent(sessionId, eventData) {\n        if (!sessionId || !eventData) {\n            return;\n        }\n\n        try {\n            const url = `${this.dsn.protocol}://${this.dsn.host}/api/v1/sessions/${sessionId}/events`;\n\n            const response = await fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey,\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify(eventData),\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}`);\n            }\n\n            return response.json();\n        } catch (error) {\n            // Silently fail - session tracking is non-critical\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Failed to send session event', error);\n            }\n        }\n    }\n\n    /**\n     * Send session replay click data to API (batch)\n     */\n    async sendReplayClicks(sessionId, clicks) {\n        if (!sessionId || !clicks || clicks.length === 0) {\n            return;\n        }\n\n        try {\n            const url = `${this.dsn.protocol}://${this.dsn.host}/api/v1/sessions/${sessionId}/replay`;\n\n            const response = await fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey,\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify({ clicks }),\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}`);\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Sent ${clicks.length} heatmap clicks`);\n            }\n\n            return response.json();\n        } catch (error) {\n            // Silently fail - heatmap tracking is non-critical\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Failed to send heatmap data', error);\n            }\n        }\n    }\n\n    /**\n   * Get stats for monitoring\n   */\n    getStats() {\n        return {\n            queueSize: this.queue.length,\n            storedErrors: this.storageQueue.size(),\n            circuitBreaker: this.circuitBreaker.getState(),\n            rateLimitTokens: this.rateLimiter.getTokens(),\n        };\n    }\n\n    /**\n   * Flush pending errors using Beacon API\n   * Called on page unload to ensure errors are sent even as page closes\n   */\n    flushWithBeacon() {\n        try {\n            // Get all stored errors (from offline queue)\n            const storedErrors = this.storageQueue.getAll();\n\n            // Also include current queue\n            const allErrors = [...this.queue, ...storedErrors];\n\n            if (allErrors.length === 0) {\n                return;\n            }\n\n            // Limit to 10 most recent errors to avoid payload size issues\n            const errorsToSend = allErrors.slice(-10);\n\n            // Beacon API has limitations with headers, so we include DSN in body\n            const beaconPayload = {\n                dsn: this.config.dsn,\n                errors: errorsToSend,\n            };\n\n            const blob = new Blob([JSON.stringify(beaconPayload)], {\n                type: 'application/json',\n            });\n\n            // Try to send via Beacon API\n            const sent = navigator.sendBeacon(this.dsn.endpoint, blob);\n\n            if (sent) {\n                // Successfully queued for sending\n                // Clear the storage queue and current queue\n                this.storageQueue.clear();\n                this.queue = [];\n\n                if (this.config.debug) {\n                    console.warn(`ApplicationLogger: Flushed ${errorsToSend.length} errors via Beacon API`);\n                }\n            }\n        } catch (error) {\n            // Beacon flush failed - errors remain in storage for next session\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Beacon flush failed', error);\n            }\n        }\n    }\n}\n","/**\n * DOM Serializer - Privacy-First Visual Structure Capture\n *\n * CRITICAL: This module captures ONLY visual DOM structure for session replay.\n * It is designed with privacy as the #1 priority.\n *\n *  WHAT IS CAPTURED:\n * - Element tag names (div, button, input, etc.)\n * - Bounding rectangles (x, y, width, height)\n * - Background colors (computed styles)\n * - Layout types (flex, grid, block, inline)\n * - Parent-child relationships (tree structure)\n *\n *  WHAT IS NEVER CAPTURED:\n * - Text content (NO textContent, innerText, innerHTML)\n * - Attribute values (NO id, class, href, src, data-*)\n * - Form values (NO input values, textarea, select options)\n * - User-generated content (NO comments, user text)\n * - Sensitive styles (NO font-family, content properties)\n * - URLs or file paths (NO src, href, background-image)\n *\n * PRIVACY GUARANTEE:\n * All data is sanitized client-side. The server receives ONLY:\n * - Visual block structure (colored rectangles)\n * - Element types (for rendering context)\n * - Layout information (for accurate replay)\n *\n * This allows session replay visualization without exposing any user data.\n */\nexport class DOMSerializer {\n    constructor(options = {}) {\n        this.maxDepth = options.maxDepth || 10; // Prevent deep recursion\n        this.minSize = options.minSize || 5; // Skip tiny elements (px)\n        this.skipInvisible = options.skipInvisible !== false; // Skip hidden elements\n        this.captureColors = options.captureColors !== false; // Capture bg colors\n        this.debug = options.debug || false;\n\n        // Performance tracking\n        this.stats = {\n            totalElements: 0,\n            skippedInvisible: 0,\n            skippedTiny: 0,\n            skippedNonVisual: 0,\n            maxDepthReached: 0,\n        };\n    }\n\n    /**\n     * Serialize the current DOM tree to a privacy-safe structure.\n     *\n     * @param {Element} [rootElement=document.body] - Root element to serialize\n     * @returns {Object} Serialized DOM structure\n     */\n    serialize(rootElement = document.body) {\n        // Reset stats\n        this.stats = {\n            totalElements: 0,\n            skippedInvisible: 0,\n            skippedTiny: 0,\n            skippedNonVisual: 0,\n            maxDepthReached: 0,\n        };\n\n        const startTime = performance.now();\n\n        try {\n            // Get viewport dimensions for context\n            const viewport = {\n                width: window.innerWidth,\n                height: window.innerHeight,\n                scrollX: window.scrollX,\n                scrollY: window.scrollY,\n            };\n\n            // Serialize the tree\n            const tree = this.serializeElement(rootElement, 0);\n\n            const elapsed = performance.now() - startTime;\n\n            if (this.debug) {\n                console.warn('DOM Serialization Stats:', {\n                    ...this.stats,\n                    elapsedMs: elapsed.toFixed(2),\n                });\n            }\n\n            return {\n                viewport,\n                tree,\n                timestamp: Date.now(),\n                stats: this.stats,\n            };\n        } catch (error) {\n            console.error('DOM serialization failed:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Serialize a single element and its children recursively.\n     *\n     * @private\n     * @param {Element} element - Element to serialize\n     * @param {number} depth - Current recursion depth\n     * @returns {Object|null} Serialized element or null if skipped\n     */\n    serializeElement(element, depth) {\n        // Check depth limit\n        if (depth >= this.maxDepth) {\n            this.stats.maxDepthReached++;\n            return null;\n        }\n\n        // Skip non-visual elements\n        if (this.isNonVisualElement(element)) {\n            this.stats.skippedNonVisual++;\n            return null;\n        }\n\n        // Get computed style (for visibility and color)\n        const style = window.getComputedStyle(element);\n\n        // Skip invisible elements\n        if (this.skipInvisible && this.isInvisible(element, style)) {\n            this.stats.skippedInvisible++;\n            return null;\n        }\n\n        // Get bounding rectangle\n        const rect = element.getBoundingClientRect();\n\n        // Skip tiny elements (noise)\n        if (rect.width < this.minSize || rect.height < this.minSize) {\n            this.stats.skippedTiny++;\n            return null;\n        }\n\n        this.stats.totalElements++;\n\n        // Build serialized element\n        const serialized = {\n            // Element type (tag name)\n            type: element.tagName.toLowerCase(),\n\n            // Bounding box (relative to viewport)\n            bounds: {\n                x: Math.round(rect.left + window.scrollX),\n                y: Math.round(rect.top + window.scrollY),\n                width: Math.round(rect.width),\n                height: Math.round(rect.height),\n            },\n\n            // Visual properties\n            bgColor: this.captureColors ? this.extractBackgroundColor(style) : null,\n            layout: this.detectLayoutType(style),\n\n            // Meta information (for better rendering)\n            isInteractive: this.isInteractive(element),\n            isText: this.isTextContainer(element),\n        };\n\n        // Serialize children recursively\n        const children = [];\n        const childElements = Array.from(element.children);\n\n        for (const child of childElements) {\n            const serializedChild = this.serializeElement(child, depth + 1);\n            if (serializedChild) {\n                children.push(serializedChild);\n            }\n        }\n\n        if (children.length > 0) {\n            serialized.children = children;\n        }\n\n        return serialized;\n    }\n\n    /**\n     * Check if element is non-visual (script, style, etc.).\n     *\n     * @private\n     * @param {Element} element\n     * @returns {boolean}\n     */\n    isNonVisualElement(element) {\n        const nonVisualTags = [\n            'SCRIPT',\n            'STYLE',\n            'LINK',\n            'META',\n            'NOSCRIPT',\n            'TITLE',\n            'HEAD',\n            'BASE',\n        ];\n\n        return nonVisualTags.includes(element.tagName);\n    }\n\n    /**\n     * Check if element is invisible (display:none, visibility:hidden, etc.).\n     *\n     * @private\n     * @param {Element} element\n     * @param {CSSStyleDeclaration} style - Computed style\n     * @returns {boolean}\n     */\n    isInvisible(element, style) {\n        // Display none\n        if (style.display === 'none') {\n            return true;\n        }\n\n        // Visibility hidden\n        if (style.visibility === 'hidden') {\n            return true;\n        }\n\n        // Fully transparent\n        if (parseFloat(style.opacity) === 0) {\n            return true;\n        }\n\n        // Outside viewport (way off-screen)\n        const rect = element.getBoundingClientRect();\n        if (\n            rect.bottom < -1000 ||\n            rect.top > window.innerHeight + 1000 ||\n            rect.right < -1000 ||\n            rect.left > window.innerWidth + 1000\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Extract background color from computed style (privacy-safe).\n     *\n     * @private\n     * @param {CSSStyleDeclaration} style\n     * @returns {string|null} Hex color or null\n     */\n    extractBackgroundColor(style) {\n        try {\n            const bgColor = style.backgroundColor;\n\n            // Skip transparent\n            if (!bgColor || bgColor === 'transparent' || bgColor === 'rgba(0, 0, 0, 0)') {\n                return null;\n            }\n\n            // Convert to hex (simpler storage)\n            return this.rgbToHex(bgColor);\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Convert RGB/RGBA color to hex format.\n     *\n     * @private\n     * @param {string} rgb - RGB/RGBA color string\n     * @returns {string|null} Hex color\n     */\n    rgbToHex(rgb) {\n        try {\n            // Match rgb(r, g, b) or rgba(r, g, b, a)\n            const match = rgb.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*[\\d.]+)?\\)/);\n            if (!match) {\n                return null;\n            }\n\n            const r = parseInt(match[1], 10);\n            const g = parseInt(match[2], 10);\n            const b = parseInt(match[3], 10);\n\n            // Convert to hex\n            const toHex = (n) => {\n                const hex = n.toString(16);\n                return hex.length === 1 ? '0' + hex : hex;\n            };\n\n            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Detect layout type (flex, grid, block, inline).\n     *\n     * @private\n     * @param {CSSStyleDeclaration} style\n     * @returns {string}\n     */\n    detectLayoutType(style) {\n        const display = style.display;\n\n        if (display.includes('flex')) {\n            return 'flex';\n        }\n\n        if (display.includes('grid')) {\n            return 'grid';\n        }\n\n        if (display === 'inline' || display === 'inline-block') {\n            return 'inline';\n        }\n\n        return 'block';\n    }\n\n    /**\n     * Check if element is interactive (button, link, input, etc.).\n     *\n     * @private\n     * @param {Element} element\n     * @returns {boolean}\n     */\n    isInteractive(element) {\n        const interactiveTags = [\n            'A',\n            'BUTTON',\n            'INPUT',\n            'SELECT',\n            'TEXTAREA',\n            'LABEL',\n        ];\n\n        if (interactiveTags.includes(element.tagName)) {\n            return true;\n        }\n\n        // Check for click handlers (heuristic)\n        if (element.onclick || element.hasAttribute('onclick')) {\n            return true;\n        }\n\n        // Check for cursor pointer\n        const style = window.getComputedStyle(element);\n        if (style.cursor === 'pointer') {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if element is a text container (p, span, h1-h6, etc.).\n     *\n     * @private\n     * @param {Element} element\n     * @returns {boolean}\n     */\n    isTextContainer(element) {\n        const textTags = [\n            'P',\n            'SPAN',\n            'H1',\n            'H2',\n            'H3',\n            'H4',\n            'H5',\n            'H6',\n            'LI',\n            'LABEL',\n            'TD',\n            'TH',\n            'CODE',\n            'PRE',\n        ];\n\n        return textTags.includes(element.tagName);\n    }\n\n    /**\n     * Get statistics about the last serialization.\n     *\n     * @returns {Object} Statistics\n     */\n    getStats() {\n        return { ...this.stats };\n    }\n\n    /**\n     * Calculate approximate payload size (for debugging).\n     *\n     * @param {Object} serialized - Serialized DOM structure\n     * @returns {number} Approximate size in bytes\n     */\n    estimateSize(serialized) {\n        try {\n            const json = JSON.stringify(serialized);\n            return json.length;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Compress serialized structure (remove nulls, optimize).\n     *\n     * @param {Object} serialized - Serialized DOM structure\n     * @returns {Object} Compressed structure\n     */\n    compress(serialized) {\n        // Remove null/undefined values\n        const removeNulls = (obj) => {\n            if (Array.isArray(obj)) {\n                return obj.map(removeNulls);\n            }\n\n            if (obj !== null && typeof obj === 'object') {\n                const cleaned = {};\n                for (const key in obj) {\n                    if (obj[key] !== null && obj[key] !== undefined) {\n                        cleaned[key] = removeNulls(obj[key]);\n                    }\n                }\n                return cleaned;\n            }\n\n            return obj;\n        };\n\n        return removeNulls(serialized);\n    }\n}\n\n/**\n * Throttled DOM Serializer - Prevents excessive snapshots.\n *\n * Wraps DOMSerializer with throttling to limit snapshot frequency.\n * This prevents performance issues and excessive data collection.\n */\nexport class ThrottledDOMSerializer {\n    constructor(options = {}) {\n        this.serializer = new DOMSerializer(options);\n        this.throttleMs = options.throttleMs || 1000; // Default: 1 snapshot per second\n        this.lastCaptureTime = 0;\n        this.pendingCapture = null;\n    }\n\n    /**\n     * Serialize DOM with throttling.\n     *\n     * @param {Element} [rootElement] - Root element to serialize\n     * @returns {Object|null} Serialized structure or null if throttled\n     */\n    serialize(rootElement) {\n        const now = Date.now();\n        const timeSinceLastCapture = now - this.lastCaptureTime;\n\n        // Check if throttled\n        if (timeSinceLastCapture < this.throttleMs) {\n            // Throttled - schedule capture for later\n            if (!this.pendingCapture) {\n                const remainingTime = this.throttleMs - timeSinceLastCapture;\n                this.pendingCapture = setTimeout(() => {\n                    this.pendingCapture = null;\n                    this.lastCaptureTime = Date.now();\n                    // Capture will happen on next call\n                }, remainingTime);\n            }\n            return null;\n        }\n\n        // Not throttled - perform capture\n        this.lastCaptureTime = now;\n        return this.serializer.serialize(rootElement);\n    }\n\n    /**\n     * Get serializer statistics.\n     *\n     * @returns {Object}\n     */\n    getStats() {\n        return this.serializer.getStats();\n    }\n\n    /**\n     * Clear pending throttle timer.\n     */\n    clearThrottle() {\n        if (this.pendingCapture) {\n            clearTimeout(this.pendingCapture);\n            this.pendingCapture = null;\n        }\n    }\n}\n","import { ThrottledDOMSerializer } from './dom-serializer.js';\n\n/**\n * Click Tracker - Captures user clicks and interactions for Session Replay\n *\n * ERROR-TRIGGERED RECORDING ONLY:\n * - Records clicks to buffer (not sent immediately)\n * - Buffer sent only when error detected (via ErrorDetector)\n * - Captures N seconds/clicks before and after error\n *\n * FEATURES:\n * - Click coordinate tracking with viewport dimensions\n * - Element selector generation (CSS selectors)\n * - DOM structure capture for session replay (privacy-safe)\n * - Page transition tracking (for cross-page sessions)\n * - Privacy-respecting (no PII in selectors or DOM snapshots)\n * - Click debouncing to prevent localStorage spam from rapid clicking\n */\nexport class ClickTracker {\n    /**\n     * @param {ReplayBuffer} replayBuffer - Replay buffer instance\n     * @param {SessionManager} sessionManager - Session manager instance\n     * @param {Object} config - Configuration options\n     */\n    constructor(replayBuffer, sessionManager, config) {\n        this.replayBuffer = replayBuffer;\n        this.sessionManager = sessionManager;\n        this.config = config;\n        this.isInstalled = false;\n\n        // Initialize DOM serializer with configurable throttling\n        const throttleMs = Math.max(config.snapshotThrottleMs || 1000, 500); // Min 500ms\n        this.domSerializer = new ThrottledDOMSerializer({\n            maxDepth: 10,           // Limit tree depth\n            minSize: 5,             // Skip tiny elements\n            skipInvisible: true,    // Skip hidden elements\n            captureColors: true,    // Capture background colors\n            throttleMs,             // Configurable throttle\n            maxSize: config.maxSnapshotSize || 1048576, // Default 1MB\n            debug: config.debug || false,\n        });\n\n        // Track DOM capture stats\n        this.domCaptureStats = {\n            total: 0,\n            throttled: 0,\n            captured: 0,\n            errors: 0,\n        };\n\n        // Click debouncing to prevent localStorage spam\n        this.lastClickTime = 0;\n        this.clickDebounceMs = Math.max(config.clickDebounceMs || 1000, 100); // Min 100ms\n        this.debounceStats = {\n            totalClicks: 0,\n            debouncedClicks: 0,\n        };\n    }\n\n    /**\n     * Install click tracking listeners\n     */\n    install() {\n        if (this.isInstalled) {\n            return;\n        }\n\n        try {\n            // Track clicks\n            document.addEventListener('click', (event) => {\n                this.captureClick(event);\n            }, true);\n\n            this.isInstalled = true;\n\n            if (this.config.debug) {\n                console.warn('ClickTracker: Installed (buffer-based recording)');\n            }\n        } catch (error) {\n            console.error('ClickTracker: Failed to install', error);\n        }\n    }\n\n    /**\n     * Capture click event with DOM snapshot\n     *\n     * Events are buffered (not sent immediately) and only transmitted\n     * when an error is detected via ErrorDetector.\n     *\n     * Includes debouncing to prevent localStorage spam from rapid clicking.\n     */\n    captureClick(event) {\n        try {\n            // Debounce: Ignore clicks that are too close together\n            const now = Date.now();\n            this.debounceStats.totalClicks++;\n\n            if (now - this.lastClickTime < this.clickDebounceMs) {\n                this.debounceStats.debouncedClicks++;\n                if (this.config.debug) {\n                    console.warn('ClickTracker: Click debounced', {\n                        timeSinceLastClick: now - this.lastClickTime,\n                        debounceThreshold: this.clickDebounceMs,\n                    });\n                }\n                return; // Skip this click\n            }\n\n            this.lastClickTime = now;\n\n            // Create click event data\n            const clickEvent = {\n                type: 'click',\n                url: window.location.href,\n                timestamp: Date.now(),\n                clickData: {\n                    x: event.pageX,\n                    y: event.pageY,\n                    viewportWidth: window.innerWidth,\n                    viewportHeight: window.innerHeight,\n                    elementSelector: this.generateSelector(event.target),\n                },\n                sessionId: this.sessionManager.getSessionId(),\n            };\n\n            // Capture DOM snapshot (throttled based on config)\n            this.domCaptureStats.total++;\n            try {\n                const domSnapshot = this.domSerializer.serialize();\n\n                if (domSnapshot) {\n                    // Snapshot captured successfully\n                    clickEvent.domSnapshot = domSnapshot;\n                    this.domCaptureStats.captured++;\n\n                    if (this.config.debug) {\n                        const size = this.domSerializer.serializer.estimateSize(domSnapshot);\n                        console.warn('ClickTracker: DOM snapshot captured', {\n                            elements: domSnapshot.stats?.totalElements || 0,\n                            sizeBytes: size,\n                            sizeKB: (size / 1024).toFixed(2),\n                        });\n                    }\n                } else {\n                    // Snapshot throttled\n                    this.domCaptureStats.throttled++;\n\n                    if (this.config.debug) {\n                        console.warn('ClickTracker: DOM snapshot throttled');\n                    }\n                }\n            } catch (domError) {\n                // DOM serialization failed - don't block the click capture\n                this.domCaptureStats.errors++;\n                if (this.config.debug) {\n                    console.error('ClickTracker: DOM serialization failed', domError);\n                }\n                // Continue without DOM snapshot\n            }\n\n            // Add event to replay buffer (not sent immediately)\n            const added = this.replayBuffer.addEvent(clickEvent);\n\n            if (!added && this.config.debug) {\n                console.warn('ClickTracker: Failed to add click to buffer');\n            }\n        } catch (error) {\n            // Never crash on tracking\n            console.error('ClickTracker: Failed to capture click', error);\n        }\n    }\n\n    /**\n     * Generate CSS selector for element\n     *\n     * Creates a unique but privacy-respecting selector:\n     * - Uses tag name, ID, classes\n     * - Limits depth to 5 levels\n     * - Removes sensitive attributes (data-*, ng-*, etc.)\n     */\n    generateSelector(element) {\n        if (!element || element === document) {\n            return '';\n        }\n\n        try {\n            const parts = [];\n            let current = element;\n            let depth = 0;\n            const maxDepth = 5;\n\n            while (current && current !== document && depth < maxDepth) {\n                let selector = current.tagName.toLowerCase();\n\n                // Add ID if available (most specific)\n                if (current.id && !this.containsSensitiveData(current.id)) {\n                    selector += `#${CSS.escape(current.id)}`;\n                    parts.unshift(selector);\n                    break; // ID is unique, stop here\n                }\n\n                // Add classes (filter out utility/dynamic classes)\n                const classes = this.getCleanClasses(current);\n                if (classes.length > 0) {\n                    selector += `.${classes.join('.')}`;\n                }\n\n                // Add nth-child if needed for uniqueness\n                const siblings = current.parentElement ?\n                    Array.from(current.parentElement.children).filter(\n                        child => child.tagName === current.tagName,\n                    ) : [];\n\n                if (siblings.length > 1) {\n                    const index = siblings.indexOf(current) + 1;\n                    selector += `:nth-child(${index})`;\n                }\n\n                parts.unshift(selector);\n                current = current.parentElement;\n                depth++;\n            }\n\n            return parts.join(' > ');\n        } catch {\n            // If selector generation fails, return basic info\n            return element.tagName ? element.tagName.toLowerCase() : 'unknown';\n        }\n    }\n\n    /**\n     * Get cleaned class list (remove utility and sensitive classes)\n     */\n    getCleanClasses(element) {\n        if (!element.classList || element.classList.length === 0) {\n            return [];\n        }\n\n        const classes = Array.from(element.classList);\n        return classes\n            .filter(cls => {\n                // Filter out utility classes (Tailwind, Bootstrap, etc.)\n                if (cls.match(/^(active|hover|focus|disabled|hidden|show)$/)) {\n                    return false;\n                }\n\n                // Filter out generated classes\n                if (cls.match(/^(ng-|v-|data-|_)/)) {\n                    return false;\n                }\n\n                // Filter out classes that look like they contain sensitive data\n                if (this.containsSensitiveData(cls)) {\n                    return false;\n                }\n\n                return true;\n            })\n            .map(cls => CSS.escape(cls))\n            .slice(0, 3); // Limit to 3 classes\n    }\n\n    /**\n     * Check if string contains potentially sensitive data\n     */\n    containsSensitiveData(str) {\n        const sensitivePatterns = [\n            /user[-_]?id/i,\n            /email/i,\n            /token/i,\n            /session/i,\n            /auth/i,\n            /key/i,\n            /\\d{10,}/,  // Long numbers (could be IDs)\n        ];\n\n        return sensitivePatterns.some(pattern => pattern.test(str));\n    }\n\n\n    /**\n     * Get DOM capture statistics for monitoring\n     *\n     * @returns {Object} Statistics about DOM snapshot captures\n     */\n    getDOMCaptureStats() {\n        return {\n            ...this.domCaptureStats,\n            serializerStats: this.domSerializer.getStats(),\n        };\n    }\n\n    /**\n     * Get click debounce statistics\n     *\n     * @returns {Object} Statistics about debounced clicks\n     */\n    getDebounceStats() {\n        return {\n            ...this.debounceStats,\n            debounceRate: this.debounceStats.totalClicks > 0\n                ? (this.debounceStats.debouncedClicks / this.debounceStats.totalClicks * 100).toFixed(2) + '%'\n                : '0%',\n            clickDebounceMs: this.clickDebounceMs,\n        };\n    }\n\n    /**\n     * Clean up resources\n     */\n    cleanup() {\n        try {\n            // Clear DOM serializer throttle timer\n            if (this.domSerializer && this.domSerializer.clearThrottle) {\n                this.domSerializer.clearThrottle();\n            }\n\n            if (this.config.debug) {\n                console.warn('ClickTracker: Cleanup complete');\n            }\n        } catch (error) {\n            console.error('ClickTracker: Cleanup failed', error);\n        }\n    }\n}\n","/**\n * Replay Buffer - Circular Buffer for Session Replay Data\n *\n * Implements a circular buffer that stores clicks and DOM snapshots\n * before an error occurs. Only sends data when an error is detected.\n *\n * Features:\n * - Time-based buffering (e.g., last 30 seconds)\n * - Click-based buffering (e.g., last 10 clicks)\n * - Memory-efficient circular buffer (FIFO)\n * - Configurable hard caps\n * - Serialization for localStorage\n * - Automatic pruning of old data\n */\nexport class ReplayBuffer {\n    /**\n     * @param {Object} config Configuration options\n     * @param {number} [config.bufferBeforeErrorSeconds=30] - Seconds of activity before error\n     * @param {number} [config.bufferBeforeErrorClicks=10] - Number of clicks before error\n     * @param {number} [config.bufferAfterErrorSeconds=30] - Seconds to continue after error\n     * @param {number} [config.bufferAfterErrorClicks=10] - Clicks to continue after error\n     * @param {number} [config.maxBufferSizeMB=5] - Maximum localStorage buffer size\n     * @param {boolean} [config.debug=false] - Enable debug logging\n     */\n    constructor(config = {}) {\n        // Configuration with hard caps enforced\n        this.config = {\n            bufferBeforeErrorSeconds: Math.min(config.bufferBeforeErrorSeconds || 30, 60),\n            bufferBeforeErrorClicks: Math.min(config.bufferBeforeErrorClicks || 10, 15),\n            bufferAfterErrorSeconds: Math.min(config.bufferAfterErrorSeconds || 30, 60),\n            bufferAfterErrorClicks: Math.min(config.bufferAfterErrorClicks || 10, 15),\n            maxBufferSizeMB: Math.min(config.maxBufferSizeMB || 5, 20),\n            debug: config.debug || false,\n        };\n\n        // Buffer state\n        this.buffer = []; // Circular buffer of events\n        this.isRecordingAfterError = false;\n        this.recordingStartedAt = null;\n        this.errorOccurredAt = null;\n        this.postErrorEventCount = 0;\n\n        // Statistics\n        this.stats = {\n            totalEvents: 0,\n            eventsDropped: 0,\n            bufferFullCount: 0,\n            currentBufferSize: 0,\n        };\n\n        if (this.config.debug) {\n            console.warn('ReplayBuffer initialized with config:', this.config);\n        }\n    }\n\n    /**\n     * Add an event to the buffer\n     *\n     * @param {Object} event - Event data (click, page transition, etc.)\n     * @param {string} event.type - Event type (click, pageTransition)\n     * @param {string} event.url - Current URL\n     * @param {number} event.timestamp - Event timestamp (milliseconds)\n     * @param {Object} [event.clickData] - Click-specific data\n     * @param {Object} [event.domSnapshot] - DOM snapshot (optional)\n     * @returns {boolean} True if event was added, false if dropped\n     */\n    addEvent(event) {\n        try {\n            if (!event || !event.timestamp) {\n                console.warn('ReplayBuffer: Invalid event (missing timestamp)');\n                return false;\n            }\n\n            // Mark event phase (before_error, error, or after_error)\n            event.phase = this.isRecordingAfterError ? 'after_error' : 'before_error';\n            event.capturedAt = Date.now();\n\n            // Add to buffer\n            this.buffer.push(event);\n            this.stats.totalEvents++;\n\n            // If recording after error, track count\n            if (this.isRecordingAfterError) {\n                this.postErrorEventCount++;\n\n                // Check if we should stop recording\n                if (this.shouldStopRecording()) {\n                    this.stopRecording();\n                }\n            } else {\n                // Prune old events from buffer (before error)\n                this.pruneOldEvents();\n            }\n\n            // Update stats\n            this.updateStats();\n\n            return true;\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to add event:', error);\n            this.stats.eventsDropped++;\n            return false;\n        }\n    }\n\n    /**\n     * Mark the start of error-triggered recording\n     *\n     * Call this when an error is detected. It will:\n     * 1. Mark the buffer as \"recording after error\"\n     * 2. Reset post-error counters\n     * 3. Prepare to stop after configured buffer is filled\n     *\n     * @param {Object} errorContext - Error context information\n     * @param {string} errorContext.errorId - Error ID from backend\n     * @param {string} errorContext.message - Error message\n     * @param {number} errorContext.timestamp - Error timestamp\n     */\n    startRecordingAfterError(errorContext) {\n        try {\n            this.errorOccurredAt = errorContext.timestamp || Date.now();\n            this.postErrorEventCount = 0;\n\n            // Add error marker event to buffer (manually, before setting isRecordingAfterError)\n            // This ensures the error marker itself is not counted in postErrorEventCount\n            this.buffer.push({\n                type: 'error',\n                phase: 'error',\n                timestamp: this.errorOccurredAt,\n                capturedAt: Date.now(),\n                url: window.location.href,\n                errorContext,\n            });\n            this.stats.totalEvents++;\n\n            // Now mark as recording after error (subsequent events will be counted)\n            this.isRecordingAfterError = true;\n\n            if (this.config.debug) {\n                console.warn('ReplayBuffer: Started recording after error', {\n                    errorId: errorContext.errorId,\n                    bufferSize: this.buffer.length,\n                    willRecordFor: `${this.config.bufferAfterErrorSeconds}s or ${this.config.bufferAfterErrorClicks} clicks`,\n                });\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to start post-error recording:', error);\n        }\n    }\n\n    /**\n     * Stop recording after error buffer is full\n     */\n    stopRecording() {\n        try {\n            if (!this.isRecordingAfterError) {\n                return;\n            }\n\n            this.isRecordingAfterError = false;\n\n            if (this.config.debug) {\n                console.warn('ReplayBuffer: Stopped recording after error', {\n                    totalEvents: this.buffer.length,\n                    postErrorEvents: this.postErrorEventCount,\n                });\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to stop recording:', error);\n        }\n    }\n\n    /**\n     * Check if we should stop recording after error\n     *\n     * Stops when either condition is met:\n     * - Time limit reached (bufferAfterErrorSeconds)\n     * - Click limit reached (bufferAfterErrorClicks)\n     *\n     * @returns {boolean}\n     */\n    shouldStopRecording() {\n        if (!this.isRecordingAfterError || !this.errorOccurredAt) {\n            return false;\n        }\n\n        const now = Date.now();\n        const elapsedSeconds = (now - this.errorOccurredAt) / 1000;\n\n        // Check time limit\n        if (elapsedSeconds >= this.config.bufferAfterErrorSeconds) {\n            if (this.config.debug) {\n                console.warn(`ReplayBuffer: Time limit reached (${elapsedSeconds.toFixed(1)}s)`);\n            }\n            return true;\n        }\n\n        // Check click limit\n        if (this.postErrorEventCount >= this.config.bufferAfterErrorClicks) {\n            if (this.config.debug) {\n                console.warn(`ReplayBuffer: Click limit reached (${this.postErrorEventCount} clicks)`);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Prune old events from buffer (keep only recent N seconds/clicks)\n     */\n    pruneOldEvents() {\n        try {\n            const now = Date.now();\n            const cutoffTime = now - (this.config.bufferBeforeErrorSeconds * 1000);\n\n            // Filter events: keep events within time window\n            const timeFiltered = this.buffer.filter(event =>\n                event.capturedAt >= cutoffTime || event.phase === 'error',\n            );\n\n            // Also enforce click limit: keep last N clicks\n            const clickEvents = timeFiltered.filter(e => e.type === 'click');\n            const otherEvents = timeFiltered.filter(e => e.type !== 'click');\n\n            // Keep last N clicks + all other events (page transitions, errors)\n            const recentClicks = clickEvents.slice(-this.config.bufferBeforeErrorClicks);\n\n            this.buffer = [...otherEvents, ...recentClicks]\n                .sort((a, b) => a.capturedAt - b.capturedAt);\n\n            // Update stats if buffer was pruned\n            if (this.buffer.length < timeFiltered.length) {\n                const dropped = timeFiltered.length - this.buffer.length;\n                this.stats.eventsDropped += dropped;\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to prune old events:', error);\n        }\n    }\n\n    /**\n     * Get all events in the buffer\n     *\n     * @returns {Array<Object>} Array of events\n     */\n    getEvents() {\n        return [...this.buffer]; // Return copy\n    }\n\n    /**\n     * Get events by phase\n     *\n     * @param {string} phase - Phase to filter by (before_error, error, after_error)\n     * @returns {Array<Object>}\n     */\n    getEventsByPhase(phase) {\n        return this.buffer.filter(event => event.phase === phase);\n    }\n\n    /**\n     * Clear the buffer\n     */\n    clear() {\n        try {\n            this.buffer = [];\n            this.isRecordingAfterError = false;\n            this.recordingStartedAt = null;\n            this.errorOccurredAt = null;\n            this.postErrorEventCount = 0;\n\n            if (this.config.debug) {\n                console.warn('ReplayBuffer: Cleared');\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to clear buffer:', error);\n        }\n    }\n\n    /**\n     * Check if buffer is currently recording after an error\n     *\n     * @returns {boolean}\n     */\n    isRecording() {\n        return this.isRecordingAfterError;\n    }\n\n    /**\n     * Get buffer statistics\n     *\n     * @returns {Object} Statistics\n     */\n    getStats() {\n        return {\n            ...this.stats,\n            bufferLength: this.buffer.length,\n            isRecording: this.isRecordingAfterError,\n            postErrorEventCount: this.postErrorEventCount,\n        };\n    }\n\n    /**\n     * Update buffer statistics\n     */\n    updateStats() {\n        try {\n            // Calculate approximate buffer size\n            const approximateSize = this.estimateBufferSize();\n            this.stats.currentBufferSize = approximateSize;\n\n            // Check if buffer is getting too large\n            const maxSizeBytes = this.config.maxBufferSizeMB * 1024 * 1024;\n            if (approximateSize > maxSizeBytes) {\n                this.stats.bufferFullCount++;\n                // Aggressive pruning\n                this.buffer = this.buffer.slice(-Math.floor(this.buffer.length / 2));\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to update stats:', error);\n        }\n    }\n\n    /**\n     * Estimate buffer size in bytes\n     *\n     * @returns {number} Approximate size in bytes\n     */\n    estimateBufferSize() {\n        try {\n            const json = JSON.stringify(this.buffer);\n            return json.length;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Serialize buffer for storage\n     *\n     * @returns {Object} Serialized data\n     */\n    serialize() {\n        return {\n            buffer: this.buffer,\n            isRecordingAfterError: this.isRecordingAfterError,\n            errorOccurredAt: this.errorOccurredAt,\n            postErrorEventCount: this.postErrorEventCount,\n            stats: this.stats,\n        };\n    }\n\n    /**\n     * Deserialize buffer from storage\n     *\n     * @param {Object} data - Serialized data\n     * @returns {boolean} Success\n     */\n    deserialize(data) {\n        try {\n            if (!data || typeof data !== 'object') {\n                if (this.config.debug) {\n                    console.warn('ReplayBuffer: No data to deserialize');\n                }\n                return false;\n            }\n\n            this.buffer = Array.isArray(data.buffer) ? data.buffer : [];\n            this.isRecordingAfterError = !!data.isRecordingAfterError;\n            this.errorOccurredAt = data.errorOccurredAt || null;\n            this.postErrorEventCount = data.postErrorEventCount || 0;\n\n            if (data.stats && typeof data.stats === 'object') {\n                this.stats = { ...this.stats, ...data.stats };\n            }\n\n            // MIGRATION: Ensure all events have phase property\n            // Old localStorage data might not have phase property\n            let migratedCount = 0;\n            this.buffer = this.buffer.map(event => {\n                if (!event.phase) {\n                    migratedCount++;\n                    // Default to 'before_error' for old events\n                    return { ...event, phase: 'before_error' };\n                }\n                return event;\n            });\n\n            if (this.config.debug) {\n                const phaseBreakdown = this.buffer.reduce((acc, event) => {\n                    acc[event.phase] = (acc[event.phase] || 0) + 1;\n                    return acc;\n                }, {});\n\n                console.warn('ReplayBuffer: Deserialized from localStorage', {\n                    totalEvents: this.buffer.length,\n                    migratedEvents: migratedCount,\n                    phaseBreakdown,\n                    isRecording: this.isRecordingAfterError,\n                    byteSize: this.estimateBufferSize(),\n                });\n            }\n\n            return true;\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to deserialize:', error);\n            return false;\n        }\n    }\n}\n","/**\n * Error Detector - Triggers Session Replay on Errors\n *\n * Hooks into global error handlers and triggers replay buffer capture\n * when errors are detected. Coordinates with ReplayBuffer to send\n * buffered events along with error context.\n *\n * Features:\n * - Hooks window.onerror and unhandledrejection\n * - Triggers replay capture on error\n * - Links replay data to error ID\n * - Prevents duplicate captures\n * - Configurable error filtering\n */\nexport class ErrorDetector {\n    /**\n     * @param {ReplayBuffer} replayBuffer - Replay buffer instance\n     * @param {SessionManager} sessionManager - Session manager instance\n     * @param {Function} onErrorDetected - Callback when error detected (receives errorContext)\n     * @param {Transport|null} transport - Transport layer for sending recovery sessions\n     * @param {Object} [config] - Configuration options\n     * @param {boolean} [config.debug=false] - Enable debug logging\n     * @param {Array<string>} [config.ignoreErrors=[]] - Error messages to ignore\n     */\n    constructor(replayBuffer, sessionManager, onErrorDetected, transport = null, config = {}) {\n        this.replayBuffer = replayBuffer;\n        this.sessionManager = sessionManager;\n        this.onErrorDetected = onErrorDetected;\n        this.transport = transport;\n        this.config = {\n            debug: config.debug || false,\n            ignoreErrors: config.ignoreErrors || [],\n        };\n\n        // State\n        this.isInstalled = false;\n        this.recentErrors = new Set(); // Prevent duplicate captures\n        this.recentErrorsCleanupInterval = null;\n        this.isRecordingRecovery = false; // Prevent concurrent recovery recordings\n        this.recoveryRecordingCleanup = null; // Store cleanup function\n\n        // Statistics\n        this.stats = {\n            errorsDetected: 0,\n            errorsIgnored: 0,\n            replaysCaptured: 0,\n            duplicatesPrevented: 0,\n            recoveryRecordingsStarted: 0,\n            recoveryRecordingsCancelled: 0,\n        };\n\n        if (this.config.debug) {\n            console.warn('ErrorDetector initialized');\n        }\n    }\n\n    /**\n     * Install error detection handlers\n     */\n    install() {\n        if (this.isInstalled) {\n            console.warn('ErrorDetector: Already installed');\n            return;\n        }\n\n        try {\n            // Note: We intentionally do NOT add new handlers here\n            // The Client class already handles window.onerror and unhandledrejection\n            // This detector will be called FROM the Client class when errors occur\n            // This design prevents double-handling of errors\n\n            // Set up cleanup for recent errors (prevent duplicates)\n            this.recentErrorsCleanupInterval = setInterval(() => {\n                this.recentErrors.clear();\n            }, 60000); // Clear every 60 seconds\n\n            this.isInstalled = true;\n\n            if (this.config.debug) {\n                console.warn('ErrorDetector: Installed');\n            }\n        } catch (error) {\n            console.error('ErrorDetector: Failed to install:', error);\n        }\n    }\n\n    /**\n     * Uninstall error detection handlers\n     */\n    uninstall() {\n        try {\n            if (this.recentErrorsCleanupInterval) {\n                clearInterval(this.recentErrorsCleanupInterval);\n                this.recentErrorsCleanupInterval = null;\n            }\n\n            this.isInstalled = false;\n\n            if (this.config.debug) {\n                console.warn('ErrorDetector: Uninstalled');\n            }\n        } catch (error) {\n            console.error('ErrorDetector: Failed to uninstall:', error);\n        }\n    }\n\n    /**\n     * Handle detected error (called by Client)\n     *\n     * This is the main entry point called by the Client class when an error occurs.\n     *\n     * @param {Error} error - The error object\n     * @param {Object} errorPayload - The error payload being sent to backend\n     * @returns {Promise<Object|null>} Error context with replay data, or null\n     */\n    async handleError(error, errorPayload) {\n        try {\n            this.stats.errorsDetected++;\n\n            // Check if error should be ignored\n            if (this.shouldIgnoreError(error)) {\n                this.stats.errorsIgnored++;\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: Error ignored:', error.message);\n                }\n                return null;\n            }\n\n            // Generate error fingerprint for deduplication\n            const errorFingerprint = this.generateErrorFingerprint(error);\n\n            // Check if we recently captured this error\n            if (this.recentErrors.has(errorFingerprint)) {\n                this.stats.duplicatesPrevented++;\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: Duplicate error prevented');\n                }\n                return null;\n            }\n\n            // Mark error as recently seen\n            this.recentErrors.add(errorFingerprint);\n\n            // Create error context\n            const errorContext = {\n                errorId: null, // Will be set by backend response\n                message: error.message || 'Unknown error',\n                type: error.name || 'Error',\n                timestamp: Date.now(),\n                stack: error.stack || '',\n                url: window.location.href,\n            };\n\n            // Start recording after error (continue for N seconds/clicks)\n            this.replayBuffer.startRecordingAfterError(errorContext);\n\n            // Get buffered events\n            const events = this.replayBuffer.getEvents();\n\n            if (this.config.debug) {\n                console.warn('ErrorDetector: Replay captured', {\n                    errorMessage: errorContext.message,\n                    eventCount: events.length,\n                    beforeError: this.replayBuffer.getEventsByPhase('before_error').length,\n                    afterError: this.replayBuffer.getEventsByPhase('after_error').length,\n                });\n            }\n\n            this.stats.replaysCaptured++;\n\n            // Call the callback with error context and replay data\n            if (this.onErrorDetected) {\n                await this.onErrorDetected(errorContext, events, errorPayload);\n            }\n\n            return {\n                errorContext,\n                events,\n                sessionId: this.sessionManager.getSessionId(),\n                stats: this.replayBuffer.getStats(),\n            };\n        } catch (handlingError) {\n            console.error('ErrorDetector: Failed to handle error:', handlingError);\n            return null;\n        }\n    }\n\n    /**\n     * Check if error should be ignored\n     *\n     * @param {Error} error\n     * @returns {boolean}\n     */\n    shouldIgnoreError(error) {\n        try {\n            if (!error || !error.message) {\n                return false;\n            }\n\n            const message = error.message.toLowerCase();\n\n            // Check configured ignore patterns\n            for (const pattern of this.config.ignoreErrors) {\n                if (message.includes(pattern.toLowerCase())) {\n                    return true;\n                }\n            }\n\n            // Ignore common non-actionable errors\n            const commonIgnorePatterns = [\n                'script error', // Cross-origin script errors\n                'network error', // Network failures (not code bugs)\n                'loading chunk', // Webpack/bundler chunk loading issues\n                'dynamically imported module', // Dynamic import failures\n            ];\n\n            for (const pattern of commonIgnorePatterns) {\n                if (message.includes(pattern)) {\n                    return true;\n                }\n            }\n\n            return false;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Generate error fingerprint for deduplication\n     *\n     * @param {Error} error\n     * @returns {string}\n     */\n    generateErrorFingerprint(error) {\n        try {\n            const message = error.message || '';\n            const stack = error.stack || '';\n\n            // Extract first line of stack (most specific)\n            const stackFirstLine = stack.split('\\n')[1] || '';\n\n            // Combine message + first stack line for fingerprint\n            return `${message}:${stackFirstLine}`;\n        } catch {\n            return `${Date.now()}:${Math.random()}`;\n        }\n    }\n\n    /**\n     * Start recording recovery session after error (Phase 2 of two-phase replay)\n     *\n     * This method is called AFTER the error + pre-error replay has been sent.\n     * It continues recording user actions for the configured duration/clicks,\n     * then sends the recovery session as a separate request.\n     *\n     * EDGE CASES HANDLED:\n     * - Prevents multiple concurrent recovery recordings\n     * - Cleans up previous recording if new error occurs\n     * - Proper cleanup of intervals and event listeners\n     * - Handles page unload gracefully\n     * - Uses sendBeacon for reliable unload transmission\n     * - Handles null/undefined buffer states\n     *\n     * @param {Error} error - The error object\n     * @returns {Promise<void>}\n     */\n    async startRecoveryRecording(error) {\n        try {\n            // EDGE CASE 1: Check if already recording recovery\n            if (this.isRecordingRecovery) {\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: Already recording recovery, cleaning up previous recording');\n                }\n\n                // Clean up previous recording\n                if (this.recoveryRecordingCleanup) {\n                    this.recoveryRecordingCleanup();\n                }\n\n                this.stats.recoveryRecordingsCancelled++;\n            }\n\n            // EDGE CASE 2: Validate dependencies\n            if (!this.replayBuffer || !this.sessionManager) {\n                console.error('ErrorDetector: Cannot start recovery recording - missing dependencies');\n                return;\n            }\n\n            // EDGE CASE 3: Validate error object\n            if (!error || typeof error !== 'object') {\n                console.error('ErrorDetector: Invalid error object for recovery recording');\n                return;\n            }\n\n            this.isRecordingRecovery = true;\n            this.stats.recoveryRecordingsStarted++;\n\n            if (this.config.debug) {\n                console.warn('ErrorDetector: Starting recovery recording (phase 2)');\n            }\n\n            const errorContext = {\n                errorId: null, // Could be set from backend response if needed\n                message: error.message || 'Unknown error',\n                type: error.name || 'Error',\n                timestamp: Date.now(),\n                url: window.location.href,\n            };\n\n            // Mark buffer as recording recovery (after error)\n            // EDGE CASE 4: Validate method exists\n            if (typeof this.replayBuffer.startRecordingAfterError === 'function') {\n                this.replayBuffer.startRecordingAfterError(errorContext);\n            } else {\n                console.error('ErrorDetector: Buffer missing startRecordingAfterError method');\n                this.isRecordingRecovery = false;\n                return;\n            }\n\n            // Wait for recording to complete (time limit or click limit)\n            return new Promise((resolve) => {\n                let checkCompleteInterval = null;\n                let unloadHandler = null;\n                let visibilityHandler = null;\n\n                // Create cleanup function to prevent memory leaks\n                const cleanup = () => {\n                    // Clear interval\n                    if (checkCompleteInterval) {\n                        clearInterval(checkCompleteInterval);\n                        checkCompleteInterval = null;\n                    }\n\n                    // Remove event listeners\n                    if (unloadHandler) {\n                        window.removeEventListener('beforeunload', unloadHandler);\n                        unloadHandler = null;\n                    }\n\n                    if (visibilityHandler) {\n                        document.removeEventListener('visibilitychange', visibilityHandler);\n                        visibilityHandler = null;\n                    }\n\n                    // Clear recovery state\n                    this.isRecordingRecovery = false;\n                    this.recoveryRecordingCleanup = null;\n                };\n\n                // Store cleanup function for external cancellation\n                this.recoveryRecordingCleanup = cleanup;\n\n                const finishRecording = (reason = 'unknown') => {\n                    if (this.config.debug) {\n                        console.warn(`ErrorDetector: Finishing recovery recording (reason: ${reason})`);\n                    }\n\n                    // Clean up listeners FIRST\n                    cleanup();\n\n                    // Get recovery events\n                    // EDGE CASE 5: Validate method exists and returns array\n                    let recoveryEvents = [];\n                    if (this.replayBuffer && typeof this.replayBuffer.getEventsByPhase === 'function') {\n                        recoveryEvents = this.replayBuffer.getEventsByPhase('after_error') || [];\n                    }\n\n                    if (recoveryEvents.length > 0) {\n                        // Use sendBeacon for page unload (more reliable)\n                        const useBeacon = reason === 'page-unload' || reason === 'page-hidden';\n\n                        // Send recovery session separately\n                        this.sendRecoverySession(errorContext, recoveryEvents, useBeacon);\n                    } else if (this.config.debug) {\n                        console.warn('ErrorDetector: No recovery events captured');\n                    }\n\n                    resolve();\n                };\n\n                // Check every second if recording is complete\n                checkCompleteInterval = setInterval(() => {\n                    try {\n                        // EDGE CASE 6: Validate buffer still exists\n                        if (!this.replayBuffer || typeof this.replayBuffer.shouldStopRecording !== 'function') {\n                            finishRecording('buffer-unavailable');\n                            return;\n                        }\n\n                        if (this.replayBuffer.shouldStopRecording()) {\n                            finishRecording('limit-reached');\n                        }\n                    } catch (error) {\n                        console.error('ErrorDetector: Error in recovery check interval', error);\n                        finishRecording('check-error');\n                    }\n                }, 1000);\n\n                // Listen for page unload (use sendBeacon for reliability)\n                unloadHandler = () => {\n                    finishRecording('page-unload');\n                };\n                window.addEventListener('beforeunload', unloadHandler, { once: true });\n\n                // Also listen for visibility change (mobile)\n                visibilityHandler = () => {\n                    if (document.visibilityState === 'hidden') {\n                        finishRecording('page-hidden');\n                    }\n                };\n                document.addEventListener('visibilitychange', visibilityHandler, { once: true });\n\n                // EDGE CASE 7: Safety timeout (absolute maximum)\n                // If something goes wrong, force finish after 2 minutes\n                setTimeout(() => {\n                    if (this.isRecordingRecovery) {\n                        if (this.config.debug) {\n                            console.warn('ErrorDetector: Recovery recording safety timeout (2 minutes)');\n                        }\n                        finishRecording('safety-timeout');\n                    }\n                }, 120000); // 2 minutes absolute maximum\n            });\n        } catch (error) {\n            console.error('ErrorDetector: Failed to start recovery recording', error);\n            this.isRecordingRecovery = false;\n            this.recoveryRecordingCleanup = null;\n        }\n    }\n\n    /**\n     * Send recovery session as separate request (Phase 2)\n     *\n     * @param {Object} errorContext - Error context information\n     * @param {Array} events - Recovery events (after error)\n     * @param {boolean} [useBeacon=false] - Use sendBeacon API for reliable unload transmission\n     */\n    sendRecoverySession(errorContext, events, useBeacon = false) {\n        try {\n            if (events.length === 0) {\n                return; // No recovery data\n            }\n\n            // Format payload to match backend API expectations\n            const recoveryPayload = {\n                sessionId: this.sessionManager.getSessionId(),\n                events: events,\n                capturedAt: new Date().toISOString(),\n                url: window.location.href,\n            };\n\n            // Send via transport if available\n            if (this.transport && typeof this.transport.sendRecoverySession === 'function') {\n                this.transport.sendRecoverySession(recoveryPayload, useBeacon).catch(error => {\n                    console.error('ErrorDetector: Failed to send recovery session via transport', error);\n                });\n\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: Recovery session sent via transport', {\n                        eventCount: events.length,\n                        sessionId: recoveryPayload.sessionId,\n                        method: useBeacon ? 'sendBeacon' : 'fetch',\n                    });\n                }\n            } else {\n                // Fallback: call onErrorDetected callback\n                if (this.onErrorDetected) {\n                    this.onErrorDetected(errorContext, events, { recovery: true });\n                }\n\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: Recovery session sent via callback', {\n                        eventCount: events.length,\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('ErrorDetector: Failed to send recovery session', error);\n        }\n    }\n\n    /**\n     * Get error detection statistics\n     *\n     * @returns {Object}\n     */\n    getStats() {\n        return {\n            ...this.stats,\n            isInstalled: this.isInstalled,\n            recentErrorsCount: this.recentErrors.size,\n        };\n    }\n\n    /**\n     * Enable/disable error detection\n     *\n     * @param {boolean} enabled\n     */\n    setEnabled(enabled) {\n        if (enabled && !this.isInstalled) {\n            this.install();\n        } else if (!enabled && this.isInstalled) {\n            this.uninstall();\n        }\n    }\n\n    /**\n     * Check if error detection is enabled\n     *\n     * @returns {boolean}\n     */\n    isEnabled() {\n        return this.isInstalled;\n    }\n}\n","/**\n * Session Manager - Cross-Page Session Management\n *\n * Manages session ID persistence across page navigations using localStorage.\n * Tracks page transitions and session metadata for replay continuity.\n *\n * Features:\n * - Persistent session ID (UUID) in localStorage\n * - Cross-page session continuity\n * - Page transition tracking\n * - Session expiration (idle timeout)\n * - Session metadata (start time, page count)\n */\nexport class SessionManager {\n    /**\n     * @param {Object} [config] - Configuration options\n     * @param {number} [config.sessionTimeoutMinutes=30] - Session timeout in minutes\n     * @param {boolean} [config.debug=false] - Enable debug logging\n     */\n    constructor(config = {}) {\n        this.config = {\n            sessionTimeoutMinutes: Math.min(config.sessionTimeoutMinutes || 30, 120),\n            debug: config.debug || false,\n        };\n\n        // localStorage keys\n        this.STORAGE_KEY_SESSION_ID = '_app_logger_session_id';\n        this.STORAGE_KEY_SESSION_METADATA = '_app_logger_session_metadata';\n\n        // Session state\n        this.sessionId = null;\n        this.metadata = {\n            startedAt: null,\n            lastActivityAt: null,\n            pageCount: 0,\n            pages: [],\n        };\n\n        // Initialize\n        this.initialize();\n\n        if (this.config.debug) {\n            console.warn('SessionManager initialized', {\n                sessionId: this.sessionId,\n                metadata: this.metadata,\n            });\n        }\n    }\n\n    /**\n     * Initialize session (load or create)\n     */\n    initialize() {\n        try {\n            // Try to load existing session\n            const loaded = this.loadSession();\n\n            if (!loaded || this.isSessionExpired()) {\n                // Create new session\n                this.createNewSession();\n            } else {\n                // Update last activity\n                this.updateActivity();\n            }\n\n            // Track current page\n            this.trackPageView(window.location.href);\n\n            // Set up page transition tracking\n            this.setupPageTransitionTracking();\n        } catch (error) {\n            console.error('SessionManager: Failed to initialize:', error);\n            // Fallback: create new session\n            this.createNewSession();\n        }\n    }\n\n    /**\n     * Create a new session\n     */\n    createNewSession() {\n        try {\n            this.sessionId = this.generateSessionId();\n            this.metadata = {\n                startedAt: Date.now(),\n                lastActivityAt: Date.now(),\n                pageCount: 0,\n                pages: [],\n            };\n\n            this.saveSession();\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Created new session', this.sessionId);\n            }\n        } catch (error) {\n            console.error('SessionManager: Failed to create new session:', error);\n        }\n    }\n\n    /**\n     * Load session from localStorage\n     *\n     * @returns {boolean} True if session loaded successfully\n     */\n    loadSession() {\n        try {\n            const sessionId = localStorage.getItem(this.STORAGE_KEY_SESSION_ID);\n            const metadataJson = localStorage.getItem(this.STORAGE_KEY_SESSION_METADATA);\n\n            if (!sessionId || !metadataJson) {\n                return false;\n            }\n\n            const metadata = JSON.parse(metadataJson);\n\n            if (!metadata || !metadata.startedAt) {\n                return false;\n            }\n\n            this.sessionId = sessionId;\n            this.metadata = metadata;\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Loaded session', {\n                    sessionId,\n                    age: this.getSessionAge(),\n                });\n            }\n\n            return true;\n        } catch (error) {\n            console.error('SessionManager: Failed to load session:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Save session to localStorage\n     */\n    saveSession() {\n        try {\n            localStorage.setItem(this.STORAGE_KEY_SESSION_ID, this.sessionId);\n            localStorage.setItem(\n                this.STORAGE_KEY_SESSION_METADATA,\n                JSON.stringify(this.metadata),\n            );\n        } catch (error) {\n            console.error('SessionManager: Failed to save session:', error);\n        }\n    }\n\n    /**\n     * Check if session is expired\n     *\n     * @returns {boolean}\n     */\n    isSessionExpired() {\n        try {\n            if (!this.metadata.lastActivityAt) {\n                return true;\n            }\n\n            const now = Date.now();\n            const lastActivity = this.metadata.lastActivityAt;\n            const timeoutMs = this.config.sessionTimeoutMinutes * 60 * 1000;\n\n            return (now - lastActivity) > timeoutMs;\n        } catch {\n            return true;\n        }\n    }\n\n    /**\n     * Update last activity timestamp\n     */\n    updateActivity() {\n        try {\n            this.metadata.lastActivityAt = Date.now();\n            this.saveSession();\n        } catch (error) {\n            console.error('SessionManager: Failed to update activity:', error);\n        }\n    }\n\n    /**\n     * Track page view\n     *\n     * @param {string} url - Page URL\n     * @returns {Object} Page transition event\n     */\n    trackPageView(url) {\n        try {\n            // Increment page count\n            this.metadata.pageCount++;\n\n            // Add to pages array (keep last 50)\n            this.metadata.pages.push({\n                url,\n                timestamp: Date.now(),\n            });\n\n            if (this.metadata.pages.length > 50) {\n                this.metadata.pages = this.metadata.pages.slice(-50);\n            }\n\n            // Update activity\n            this.updateActivity();\n\n            // Create page transition event\n            const pageEvent = {\n                type: 'pageTransition',\n                url,\n                timestamp: Date.now(),\n                phase: 'before_error',\n                sessionId: this.sessionId,\n                pageCount: this.metadata.pageCount,\n            };\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Page view tracked', {\n                    url,\n                    pageCount: this.metadata.pageCount,\n                });\n            }\n\n            return pageEvent;\n        } catch (error) {\n            console.error('SessionManager: Failed to track page view:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Set up page transition tracking\n     */\n    setupPageTransitionTracking() {\n        try {\n            // Track history API navigation (pushState, replaceState)\n            const originalPushState = history.pushState;\n            const originalReplaceState = history.replaceState;\n\n            history.pushState = (...args) => {\n                originalPushState.apply(history, args);\n                this.handleNavigationChange();\n            };\n\n            history.replaceState = (...args) => {\n                originalReplaceState.apply(history, args);\n                this.handleNavigationChange();\n            };\n\n            // Track popstate (back/forward buttons)\n            window.addEventListener('popstate', () => {\n                this.handleNavigationChange();\n            });\n\n            // Track hash changes\n            window.addEventListener('hashchange', () => {\n                this.handleNavigationChange();\n            });\n        } catch (error) {\n            console.error('SessionManager: Failed to setup page transition tracking:', error);\n        }\n    }\n\n    /**\n     * Handle navigation change (for SPA routing)\n     */\n    handleNavigationChange() {\n        try {\n            const url = window.location.href;\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Navigation detected', url);\n            }\n\n            // Track the navigation as a page transition\n            this.trackPageView(url);\n        } catch (error) {\n            console.error('SessionManager: Failed to handle navigation change:', error);\n        }\n    }\n\n    /**\n     * Get current session ID\n     *\n     * @returns {string}\n     */\n    getSessionId() {\n        return this.sessionId;\n    }\n\n    /**\n     * Get session metadata\n     *\n     * @returns {Object}\n     */\n    getMetadata() {\n        return { ...this.metadata };\n    }\n\n    /**\n     * Get session age in milliseconds\n     *\n     * @returns {number}\n     */\n    getSessionAge() {\n        if (!this.metadata.startedAt) {\n            return 0;\n        }\n\n        return Date.now() - this.metadata.startedAt;\n    }\n\n    /**\n     * Generate a new session ID (UUID v4)\n     *\n     * @returns {string}\n     */\n    generateSessionId() {\n        try {\n            // Use crypto.randomUUID if available (modern browsers)\n            if (crypto && crypto.randomUUID) {\n                return crypto.randomUUID();\n            }\n\n            // Fallback: Generate UUID v4 manually\n            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n                const r = Math.random() * 16 | 0;\n                const v = c === 'x' ? r : (r & 0x3 | 0x8);\n                return v.toString(16);\n            });\n        } catch {\n            // Last resort: timestamp + random\n            return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n        }\n    }\n\n    /**\n     * Clear session (force new session on next page load)\n     */\n    clearSession() {\n        try {\n            localStorage.removeItem(this.STORAGE_KEY_SESSION_ID);\n            localStorage.removeItem(this.STORAGE_KEY_SESSION_METADATA);\n\n            this.sessionId = null;\n            this.metadata = {\n                startedAt: null,\n                lastActivityAt: null,\n                pageCount: 0,\n                pages: [],\n            };\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Session cleared');\n            }\n        } catch (error) {\n            console.error('SessionManager: Failed to clear session:', error);\n        }\n    }\n\n    /**\n     * Extend session (reset idle timeout)\n     */\n    extendSession() {\n        try {\n            this.updateActivity();\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Session extended');\n            }\n        } catch (error) {\n            console.error('SessionManager: Failed to extend session:', error);\n        }\n    }\n\n    /**\n     * Get session info for debugging\n     *\n     * @returns {Object}\n     */\n    getSessionInfo() {\n        return {\n            sessionId: this.sessionId,\n            age: this.getSessionAge(),\n            ageMinutes: Math.floor(this.getSessionAge() / 1000 / 60),\n            isExpired: this.isSessionExpired(),\n            pageCount: this.metadata.pageCount,\n            recentPages: this.metadata.pages.slice(-5),\n            timeoutMinutes: this.config.sessionTimeoutMinutes,\n        };\n    }\n}\n","/**\n * Storage Manager - localStorage Management for Replay Buffer\n *\n * Manages localStorage for replay buffer persistence across pages.\n * Handles quota management, compression, and cleanup.\n *\n * Features:\n * - Save/load replay buffer to/from localStorage\n * - Quota management (prevents quota exceeded errors)\n * - Automatic cleanup of old sessions\n * - LRU eviction when quota is tight\n * - Size monitoring and reporting\n */\nexport class StorageManager {\n    /**\n     * @param {Object} [config] - Configuration options\n     * @param {number} [config.maxBufferSizeMB=5] - Maximum buffer size in MB\n     * @param {boolean} [config.debug=false] - Enable debug logging\n     */\n    constructor(config = {}) {\n        this.config = {\n            maxBufferSizeMB: Math.min(config.maxBufferSizeMB || 5, 20),\n            debug: config.debug || false,\n        };\n\n        // localStorage keys\n        this.STORAGE_KEY_BUFFER = '_app_logger_replay_buffer';\n        this.STORAGE_KEY_METADATA = '_app_logger_replay_metadata';\n\n        // Statistics\n        this.stats = {\n            savesSuccessful: 0,\n            savesFailed: 0,\n            loadsSuccessful: 0,\n            loadsFailed: 0,\n            quotaExceededCount: 0,\n            cleanupCount: 0,\n        };\n\n        if (this.config.debug) {\n            console.warn('StorageManager initialized with config:', this.config);\n        }\n    }\n\n    /**\n     * Save replay buffer to localStorage\n     *\n     * @param {Object} bufferData - Serialized buffer data from ReplayBuffer\n     * @returns {boolean} Success\n     */\n    save(bufferData) {\n        try {\n            if (!bufferData || typeof bufferData !== 'object') {\n                console.warn('StorageManager: Invalid buffer data');\n                return false;\n            }\n\n            // Check size before saving\n            const estimatedSize = this.estimateSize(bufferData);\n            const maxSizeBytes = this.config.maxBufferSizeMB * 1024 * 1024;\n\n            if (estimatedSize > maxSizeBytes) {\n                if (this.config.debug) {\n                    console.warn('StorageManager: Buffer too large', {\n                        size: estimatedSize,\n                        max: maxSizeBytes,\n                        sizeMB: (estimatedSize / 1024 / 1024).toFixed(2),\n                    });\n                }\n\n                // Try to make space\n                this.cleanup();\n\n                // If still too large, prune the buffer\n                if (estimatedSize > maxSizeBytes) {\n                    bufferData = this.pruneBuffer(bufferData, maxSizeBytes);\n                }\n            }\n\n            // Save to localStorage\n            localStorage.setItem(this.STORAGE_KEY_BUFFER, JSON.stringify(bufferData));\n\n            // Save metadata\n            this.saveMetadata({\n                savedAt: Date.now(),\n                size: estimatedSize,\n            });\n\n            this.stats.savesSuccessful++;\n\n            if (this.config.debug) {\n                console.warn('StorageManager: Buffer saved', {\n                    size: estimatedSize,\n                    events: bufferData.buffer?.length || 0,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            this.stats.savesFailed++;\n\n            if (error.name === 'QuotaExceededError') {\n                this.stats.quotaExceededCount++;\n\n                if (this.config.debug) {\n                    console.warn('StorageManager: Quota exceeded, attempting cleanup');\n                }\n\n                // Try to make space and retry\n                this.cleanup();\n\n                try {\n                    // Retry with pruned buffer\n                    const prunedBuffer = this.pruneBuffer(\n                        bufferData,\n                        this.config.maxBufferSizeMB * 1024 * 1024 / 2, // Use half max size\n                    );\n\n                    localStorage.setItem(\n                        this.STORAGE_KEY_BUFFER,\n                        JSON.stringify(prunedBuffer),\n                    );\n\n                    this.stats.savesSuccessful++;\n                    return true;\n                } catch {\n                    console.error('StorageManager: Failed to save even after cleanup');\n                    return false;\n                }\n            }\n\n            console.error('StorageManager: Failed to save buffer:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Load replay buffer from localStorage\n     *\n     * @returns {Object|null} Buffer data or null if not found/invalid\n     */\n    load() {\n        try {\n            const stored = localStorage.getItem(this.STORAGE_KEY_BUFFER);\n\n            if (!stored) {\n                return null;\n            }\n\n            const bufferData = JSON.parse(stored);\n\n            if (!bufferData || typeof bufferData !== 'object') {\n                return null;\n            }\n\n            // Validate buffer structure\n            if (!Array.isArray(bufferData.buffer)) {\n                console.warn('StorageManager: Invalid buffer structure');\n                return null;\n            }\n\n            this.stats.loadsSuccessful++;\n\n            if (this.config.debug) {\n                console.warn('StorageManager: Buffer loaded', {\n                    events: bufferData.buffer.length,\n                    isRecording: bufferData.isRecordingAfterError,\n                });\n            }\n\n            return bufferData;\n        } catch (error) {\n            this.stats.loadsFailed++;\n            console.error('StorageManager: Failed to load buffer:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Clear replay buffer from localStorage\n     */\n    clear() {\n        try {\n            localStorage.removeItem(this.STORAGE_KEY_BUFFER);\n            localStorage.removeItem(this.STORAGE_KEY_METADATA);\n\n            if (this.config.debug) {\n                console.warn('StorageManager: Buffer cleared');\n            }\n        } catch (error) {\n            console.error('StorageManager: Failed to clear buffer:', error);\n        }\n    }\n\n    /**\n     * Clean up old/expired data\n     */\n    cleanup() {\n        try {\n            // Remove old buffer if it exists\n            const metadata = this.loadMetadata();\n\n            if (metadata && metadata.savedAt) {\n                const age = Date.now() - metadata.savedAt;\n                const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n\n                if (age > maxAge) {\n                    this.clear();\n                    this.stats.cleanupCount++;\n\n                    if (this.config.debug) {\n                        console.warn('StorageManager: Cleaned up old buffer', {\n                            ageHours: (age / 1000 / 60 / 60).toFixed(1),\n                        });\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('StorageManager: Cleanup failed:', error);\n        }\n    }\n\n    /**\n     * Save metadata\n     *\n     * @param {Object} metadata\n     */\n    saveMetadata(metadata) {\n        try {\n            localStorage.setItem(\n                this.STORAGE_KEY_METADATA,\n                JSON.stringify(metadata),\n            );\n        } catch (error) {\n            // Metadata save failure is not critical\n            if (this.config.debug) {\n                console.warn('StorageManager: Failed to save metadata:', error);\n            }\n        }\n    }\n\n    /**\n     * Load metadata\n     *\n     * @returns {Object|null}\n     */\n    loadMetadata() {\n        try {\n            const stored = localStorage.getItem(this.STORAGE_KEY_METADATA);\n\n            if (!stored) {\n                return null;\n            }\n\n            return JSON.parse(stored);\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Prune buffer to fit within size limit\n     *\n     * @param {Object} bufferData\n     * @param {number} maxSizeBytes\n     * @returns {Object} Pruned buffer\n     */\n    pruneBuffer(bufferData, maxSizeBytes) {\n        try {\n            if (!bufferData.buffer || !Array.isArray(bufferData.buffer)) {\n                return bufferData;\n            }\n\n            // Start by keeping all events\n            const pruned = { ...bufferData };\n            const events = [...bufferData.buffer];\n\n            // Remove oldest events until we fit\n            while (this.estimateSize(pruned) > maxSizeBytes && events.length > 1) {\n                // Remove oldest event (but keep error marker)\n                const removed = events.shift();\n\n                // If we removed an error marker, put it back\n                if (removed && removed.phase === 'error') {\n                    events.unshift(removed);\n                    break;\n                }\n\n                pruned.buffer = events;\n            }\n\n            if (this.config.debug) {\n                console.warn('StorageManager: Buffer pruned', {\n                    originalEvents: bufferData.buffer.length,\n                    prunedEvents: events.length,\n                    originalSize: this.estimateSize(bufferData),\n                    prunedSize: this.estimateSize(pruned),\n                });\n            }\n\n            return pruned;\n        } catch (error) {\n            console.error('StorageManager: Failed to prune buffer:', error);\n            return bufferData;\n        }\n    }\n\n    /**\n     * Estimate size of data in bytes\n     *\n     * @param {Object} data\n     * @returns {number} Size in bytes\n     */\n    estimateSize(data) {\n        try {\n            const json = JSON.stringify(data);\n            return json.length;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Get available localStorage space (approximate)\n     *\n     * @returns {Object} Space info\n     */\n    getSpaceInfo() {\n        try {\n            const testKey = '_app_logger_space_test';\n            const testData = '0'.repeat(1024); // 1KB test string\n\n            let available = 0;\n            let used = 0;\n\n            // Estimate used space\n            for (const key in localStorage) {\n                if (Object.prototype.hasOwnProperty.call(localStorage, key)) {\n                    used += localStorage[key].length + key.length;\n                }\n            }\n\n            // Estimate available space (crude test)\n            try {\n                for (let i = 0; i < 10000; i++) {\n                    localStorage.setItem(testKey, testData.repeat(i));\n                    available = i * 1024;\n                }\n            } catch {\n                // Quota exceeded - we found the limit\n            } finally {\n                localStorage.removeItem(testKey);\n            }\n\n            return {\n                usedBytes: used,\n                usedMB: (used / 1024 / 1024).toFixed(2),\n                availableMB: (available / 1024 / 1024).toFixed(2),\n                totalMB: ((used + available) / 1024 / 1024).toFixed(2),\n            };\n        } catch {\n            return {\n                usedBytes: 0,\n                usedMB: 'unknown',\n                availableMB: 'unknown',\n                totalMB: 'unknown',\n            };\n        }\n    }\n\n    /**\n     * Get storage statistics\n     *\n     * @returns {Object}\n     */\n    getStats() {\n        const spaceInfo = this.getSpaceInfo();\n\n        return {\n            ...this.stats,\n            ...spaceInfo,\n            maxBufferSizeMB: this.config.maxBufferSizeMB,\n        };\n    }\n\n    /**\n     * Check if localStorage is available\n     *\n     * @returns {boolean}\n     */\n    isAvailable() {\n        try {\n            const testKey = '_app_logger_test';\n            localStorage.setItem(testKey, 'test');\n            localStorage.removeItem(testKey);\n            return true;\n        } catch {\n            return false;\n        }\n    }\n}\n","/**\n * Application Logger JavaScript SDK\n *\n * ERROR-TRIGGERED SESSION REPLAY:\n * - Only captures replay when errors occur (not continuously)\n * - Buffers N seconds/clicks before and after error\n * - Cross-page session continuity via localStorage\n * - Privacy-first (no PII in DOM snapshots)\n *\n * FEATURES:\n * - JavaScript error capture and reporting\n * - Session replay on error (configurable buffer size)\n * - Breadcrumb tracking for debugging context\n * - Click heatmap for user behavior analysis\n *\n * @module ApplicationLogger\n */\n\nimport { Client } from './client.js';\nimport { BreadcrumbCollector } from './breadcrumbs.js';\nimport { Transport } from './transport.js';\nimport { ClickTracker } from './click-tracker.js';\nimport { ReplayBuffer } from './replay-buffer.js';\nimport { ErrorDetector } from './error-detector.js';\nimport { SessionManager } from './session-manager.js';\nimport { StorageManager } from './storage-manager.js';\n\n/**\n * Main ApplicationLogger class\n */\nclass ApplicationLogger {\n    /**\n     * @param {Object} config Configuration options\n     * @param {string} config.dsn Data Source Name (project endpoint URL)\n     * @param {string} config.apiKey API Key for authentication\n     * @param {string} [config.release] Application version/release\n     * @param {string} [config.environment] Environment (production, staging, etc.)\n     * @param {boolean} [config.debug=false] Enable debug logging\n     * @param {string[]} [config.scrubFields] Additional fields to scrub\n     *\n     * Session Replay Configuration (error-triggered only):\n     * @param {boolean} [config.sessionReplayEnabled=true] Enable session replay on errors\n     * @param {number} [config.bufferBeforeErrorSeconds=30] Seconds to buffer before error (max 60)\n     * @param {number} [config.bufferBeforeErrorClicks=10] Clicks to buffer before error (max 15)\n     * @param {number} [config.bufferAfterErrorSeconds=30] Seconds to buffer after error (max 60)\n     * @param {number} [config.bufferAfterErrorClicks=10] Clicks to buffer after error (max 15)\n     * @param {number} [config.snapshotThrottleMs=1000] DOM snapshot throttle (min 500ms)\n     * @param {number} [config.maxSnapshotSize=1048576] Max snapshot size (default 1MB)\n     * @param {number} [config.sessionTimeoutMinutes=30] Session timeout (max 120 min)\n     * @param {number} [config.maxBufferSizeMB=5] Max localStorage buffer size (max 20MB)\n     * @param {boolean} [config.exposeApi=true] Expose control API for developers\n     */\n    constructor(config) {\n        // Validate required configuration\n        if (!config || !config.dsn) {\n            throw new Error('ApplicationLogger: DSN is required. Expected format: https://host/project-id');\n        }\n\n        if (!config.apiKey) {\n            throw new Error('ApplicationLogger: API Key is required for authentication');\n        }\n\n        this.config = {\n            // Core config\n            debug: false,\n            scrubFields: ['password', 'token', 'api_key', 'secret'],\n\n            // Session replay config (error-triggered only)\n            sessionReplayEnabled: true,\n            bufferBeforeErrorSeconds: 30,\n            bufferBeforeErrorClicks: 10,\n            bufferAfterErrorSeconds: 30,\n            bufferAfterErrorClicks: 10,\n            snapshotThrottleMs: 1000,\n            maxSnapshotSize: 1048576, // 1MB\n            sessionTimeoutMinutes: 30,\n            maxBufferSizeMB: 5,\n            exposeApi: true,\n\n            // Merge user config\n            ...config,\n        };\n\n        // Initialize core components\n        this.transport = new Transport(this.config);\n\n        // Initialize breadcrumbs with error capture callback\n        // This enables zero-config error tracking: console.error(err) automatically captures\n        this.breadcrumbs = new BreadcrumbCollector(\n            50, // maxBreadcrumbs\n            (error, options) => {\n                // Debug log\n                if (this.config && this.config.debug) {\n                    console.warn('ApplicationLogger: Auto-capturing error from console.error()', error);\n                }\n                this.captureException(error, options);\n            }, // errorCaptureCallback\n        );\n\n        // Initialize session replay components (if enabled)\n        this.sessionManager = null;\n        this.replayBuffer = null;\n        this.storageManager = null;\n        this.errorDetector = null;\n        this.heatmap = null;\n\n        if (this.config.sessionReplayEnabled) {\n            this.initializeSessionReplay();\n        }\n\n        // Initialize client (with optional errorDetector and sessionManager)\n        this.client = new Client(\n            this.config,\n            this.transport,\n            this.breadcrumbs,\n            this.errorDetector,\n            this.sessionManager,\n        );\n\n        this.initialized = false;\n    }\n\n    /**\n     * Initialize session replay components\n     */\n    initializeSessionReplay() {\n        try {\n            // Session manager (cross-page sessions)\n            this.sessionManager = new SessionManager({\n                sessionTimeoutMinutes: this.config.sessionTimeoutMinutes,\n                debug: this.config.debug,\n            });\n\n            // Replay buffer (circular buffer for events)\n            this.replayBuffer = new ReplayBuffer({\n                bufferBeforeErrorSeconds: this.config.bufferBeforeErrorSeconds,\n                bufferBeforeErrorClicks: this.config.bufferBeforeErrorClicks,\n                bufferAfterErrorSeconds: this.config.bufferAfterErrorSeconds,\n                bufferAfterErrorClicks: this.config.bufferAfterErrorClicks,\n                maxBufferSizeMB: this.config.maxBufferSizeMB,\n                debug: this.config.debug,\n            });\n\n            // Storage manager (localStorage persistence)\n            this.storageManager = new StorageManager({\n                maxBufferSizeMB: this.config.maxBufferSizeMB,\n                debug: this.config.debug,\n            });\n\n            // Error detector (triggers replay on error)\n            this.errorDetector = new ErrorDetector(\n                this.replayBuffer,\n                this.sessionManager,\n                this.handleReplayCapture.bind(this),\n                this.transport, // Pass transport for recovery session sending\n                {\n                    debug: this.config.debug,\n                    ignoreErrors: [],\n                },\n            );\n\n            // Click tracker (click recording to buffer for session replay)\n            this.heatmap = new ClickTracker(\n                this.replayBuffer,\n                this.sessionManager,\n                this.config,\n            );\n\n            // Load existing buffer from localStorage (cross-page continuity)\n            const savedBuffer = this.storageManager.load();\n            if (savedBuffer) {\n                this.replayBuffer.deserialize(savedBuffer);\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Loaded replay buffer from localStorage', {\n                        events: savedBuffer.buffer?.length || 0,\n                    });\n                }\n            }\n\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Session replay initialized');\n            }\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to initialize session replay', error);\n            // Disable session replay on initialization failure\n            this.config.sessionReplayEnabled = false;\n        }\n    }\n\n    /**\n     * Handle replay capture when error is detected\n     *\n     * Called by ErrorDetector after buffering is complete.\n     * Saves buffer to localStorage for cross-page continuity.\n     *\n     * Note: Replay data is sent WITH the error payload in client.captureException(),\n     * not as a separate request. This callback is just for localStorage persistence.\n     *\n     * @param {Object} errorContext - Error context\n     * @param {Array} events - Buffered events (before + after error)\n     * @param {Object} errorPayload - Original error payload sent to backend (unused here)\n     */\n    // eslint-disable-next-line no-unused-vars\n    async handleReplayCapture(errorContext, events, errorPayload) {\n        try {\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Replay captured for error', {\n                    errorMessage: errorContext.message,\n                    eventCount: events.length,\n                    sessionId: this.sessionManager.getSessionId(),\n                });\n            }\n\n            // Save buffer to localStorage for cross-page continuity\n            const serialized = this.replayBuffer.serialize();\n            this.storageManager.save(serialized);\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to save replay buffer', error);\n        }\n    }\n\n    /**\n     * Initialize the SDK and start capturing errors\n     *\n     * IMPORTANT: Initialization order matters for reliability:\n     * 1. Breadcrumbs install first (wraps console/fetch before errors occur)\n     * 2. Session replay components (heatmap, error detector)\n     * 3. Error handlers install last (processes buffered errors, then goes live)\n     */\n    init() {\n        if (this.initialized) {\n            console.warn('ApplicationLogger already initialized');\n            return;\n        }\n\n        // 1. Install breadcrumbs FIRST (wraps console/fetch immediately)\n        // This ensures we capture breadcrumbs for any errors that occur during init\n        this.breadcrumbs.install();\n\n        // 2. Install session replay tracking (if enabled)\n        if (this.config.sessionReplayEnabled && this.heatmap) {\n            this.heatmap.install();\n            this.errorDetector.install();\n\n            // Periodic saves to localStorage (every 5 seconds)\n            // This ensures buffer persists even if page closes unexpectedly\n            this.bufferSaveInterval = setInterval(() => {\n                this.saveBufferToStorage();\n            }, 5000);\n\n            // Save buffer to localStorage on page unload\n            window.addEventListener('beforeunload', () => {\n                this.saveBufferToStorage();\n            });\n\n            // Also save on visibility change (mobile)\n            document.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'hidden') {\n                    this.saveBufferToStorage();\n                }\n            });\n\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Session replay enabled (error-triggered, periodic saves every 5s)');\n            }\n        }\n\n        // 3. Install error capture LAST (processes buffered errors, then starts live capture)\n        // Note: breadcrumbs.install() is called again in client.install() but it's idempotent\n        this.client.install();\n\n        this.initialized = true;\n\n        if (this.config.debug) {\n            const sdkLoadTime = window._appLoggerBuffer?.startTime\n                ? Date.now() - window._appLoggerBuffer.startTime\n                : 'unknown';\n\n            console.warn('ApplicationLogger initialized', {\n                environment: this.config.environment,\n                release: this.config.release,\n                sessionReplayEnabled: this.config.sessionReplayEnabled,\n                sessionId: this.sessionManager?.getSessionId(),\n                sdkLoadTime: sdkLoadTime + 'ms',\n                bufferedErrors: window._appLoggerBuffer?.errors?.length || 0,\n            });\n        }\n    }\n\n    /**\n     * Save buffer to localStorage for cross-page continuity\n     */\n    saveBufferToStorage() {\n        try {\n            if (this.replayBuffer && this.storageManager) {\n                const serialized = this.replayBuffer.serialize();\n                this.storageManager.save(serialized);\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Buffer saved to localStorage');\n                }\n            }\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to save buffer', error);\n        }\n    }\n\n    /**\n   * Manually capture an exception\n   *\n   * @param {Error} error The error to capture\n   * @param {Object} [options] Additional options\n   * @param {Object} [options.tags] Key-value tags\n   * @param {Object} [options.extra] Additional context data\n   */\n    captureException(error, options = {}) {\n        this.client.captureException(error, options);\n    }\n\n    /**\n   * Manually capture a message\n   *\n   * @param {string} message The message to capture\n   * @param {string} [level='info'] Log level\n   * @param {Object} [options] Additional options\n   */\n    captureMessage(message, level = 'info', options = {}) {\n        this.client.captureMessage(message, level, options);\n    }\n\n    /**\n   * Add a breadcrumb\n   *\n   * @param {Object} breadcrumb Breadcrumb data\n   * @param {string} breadcrumb.type Breadcrumb type (navigation, http, user, etc.)\n   * @param {string} breadcrumb.category Category\n   * @param {string} breadcrumb.message Message\n   * @param {Object} [breadcrumb.data] Additional data\n   * @param {string} [breadcrumb.level='info'] Log level\n   */\n    addBreadcrumb(breadcrumb) {\n        this.breadcrumbs.add(breadcrumb);\n    }\n\n    /**\n   * Set user context\n   *\n   * @param {Object} user User data\n   * @param {string} [user.id] User ID\n   * @param {string} [user.email] User email\n   * @param {string} [user.username] Username\n   */\n    setUser(user) {\n        this.client.setUser(user);\n    }\n\n    /**\n   * Set tags\n   *\n   * @param {Object} tags Key-value tags\n   */\n    setTags(tags) {\n        this.client.setTags(tags);\n    }\n\n    /**\n     * Set extra context\n     *\n     * @param {Object} extra Key-value extra data\n     */\n    setExtra(extra) {\n        this.client.setExtra(extra);\n    }\n\n    /**\n     * Session Replay API - exposed for developer control\n     *\n     * Allows developers to let users control session replay:\n     * - window.ApplicationLogger.sessionReplay.enable()\n     * - window.ApplicationLogger.sessionReplay.disable()\n     * - window.ApplicationLogger.sessionReplay.isEnabled()\n     */\n    get sessionReplay() {\n        if (!this.config.exposeApi) {\n            return null;\n        }\n\n        return {\n            /**\n             * Enable session replay recording\n             */\n            enable: () => {\n                if (!this.config.sessionReplayEnabled) {\n                    this.config.sessionReplayEnabled = true;\n\n                    // Re-initialize if not already initialized\n                    if (!this.heatmap) {\n                        this.initializeSessionReplay();\n                        if (this.initialized && this.heatmap) {\n                            this.heatmap.install();\n                            this.errorDetector.install();\n                        }\n                    }\n\n                    if (this.config.debug) {\n                        console.warn('ApplicationLogger: Session replay enabled');\n                    }\n                }\n            },\n\n            /**\n             * Disable session replay recording\n             */\n            disable: () => {\n                if (this.config.sessionReplayEnabled) {\n                    this.config.sessionReplayEnabled = false;\n\n                    // Clean up and save buffer\n                    if (this.heatmap) {\n                        this.heatmap.cleanup();\n                    }\n                    if (this.errorDetector) {\n                        this.errorDetector.uninstall();\n                    }\n                    this.saveBufferToStorage();\n\n                    if (this.config.debug) {\n                        console.warn('ApplicationLogger: Session replay disabled');\n                    }\n                }\n            },\n\n            /**\n             * Check if session replay is enabled\n             * @returns {boolean}\n             */\n            isEnabled: () => {\n                return this.config.sessionReplayEnabled;\n            },\n\n            /**\n             * Get session replay statistics for debugging\n             * @returns {Object}\n             */\n            getStats: () => {\n                if (!this.config.sessionReplayEnabled) {\n                    return { enabled: false };\n                }\n\n                return {\n                    enabled: true,\n                    sessionId: this.sessionManager?.getSessionId(),\n                    sessionAge: this.sessionManager?.getSessionAge(),\n                    bufferStats: this.replayBuffer?.getStats(),\n                    storageStats: this.storageManager?.getStats(),\n                    domCaptureStats: this.heatmap?.getDOMCaptureStats(),\n                    debounceStats: this.heatmap?.getDebounceStats(),\n                    errorDetectorStats: this.errorDetector?.getStats(),\n                };\n            },\n        };\n    }\n}\n\n// Export for ES modules\nexport default ApplicationLogger;\n\n// Export for UMD (window.ApplicationLogger)\nif (typeof window !== 'undefined') {\n    window.ApplicationLogger = ApplicationLogger;\n}\n"],"names":["Client","constructor","config","transport","breadcrumbs","errorDetector","sessionManager","this","userContext","tags","extra","pendingBeaconErrors","install","processResurrectedErrors","processBufferedErrors","window","addEventListener","event","captureException","error","Error","message","filename","lineno","colno","console","reason","type","flushBeaconErrors","document","visibilityState","NUCLEAR_KEY","RESURRECTION_ATTEMPTS_KEY","MAX_ATTEMPTS","MAX_AGE_MS","attempts","parseInt","localStorage","getItem","debug","warn","removeItem","stored","errors","JSON","parse","parseError","Array","isArray","length","now","Date","validErrors","filter","err","t","succeeded","failed","m","String","name","errorAge","resurrected","nuclear","resurrectTimestamp","originalTimestamp","Math","floor","f","l","c","originalUrl","u","sessionGap","sendError","setItem","_appLoggerBuffer","buffered","processed","item","stack","bufferedAt","timestamp","itemError","options","payload","buildPayload","replayBuffer","replayContext","handleError","replayData","events","preErrorEvents","phase","sessionId","totalEvents","bufferStats","getStats","hasContext","hasEvents","eventCount","send","startRecoveryRecording","catch","recoveryError","replayError","captureError","captureMessage","level","stackTrace","parseStackTrace","firstFrame","file","line","stack_trace","source","environment","release","url","location","href","http_method","detectHttpMethod","http_status_code","extractHttpStatusCode","session_hash","getSessionHash","session_id","getSessionId","toISOString","runtime","getBrowserInfo","user_agent","navigator","userAgent","get","context","removeNullValues","function","lines","split","frames","frame","parseStackLine","trim","push","match","column","navigation","performance","getEntriesByType","status","httpStatusCode","ua","includes","sessionHash","sessionStorage","generateSessionId","sha256","crypto","randomUUID","replace","r","random","toString","str","hash","i","charCodeAt","abs","padStart","obj","cleaned","key","value","Object","entries","setUser","user","setTags","setExtra","sendBeacon","stats","storedErrors","queueSize","flushWithBeacon","BreadcrumbCollector","maxBreadcrumbs","errorCaptureCallback","installed","target","tagName","toLowerCase","className","element","undefined","baseVal","id","firstClass","add","category","data","tag","class","originalPushState","history","pushState","originalReplaceState","replaceState","args","to","apply","wrapConsole","wrapFetch","breadcrumb","shift","clear","forEach","original","errorObj","find","arg","consoleError","consoleMessage","map","join","call","result","safeArgs","stringify","prototype","arguments","originalFetch","fetch","async","method","startTime","response","duration","status_code","ok","CircuitBreaker","static","failureThreshold","timeout","storageKey","loadState","isOpen","state","STATE_OPEN","shouldAttemptReset","halfOpen","isHalfOpen","STATE_HALF_OPEN","recordSuccess","close","STATE_CLOSED","failureCount","saveState","recordFailure","open","getState","openedAt","reset","StorageQueue","maxSize","maxAge","enqueue","queue","getQueue","saveQueue","dequeue","getAll","size","filtered","halfSize","trimmed","slice","RateLimiter","maxTokens","refillRate","tokens","lastRefill","isAllowed","refillTokens","consume","elapsed","tokensToAdd","min","getTokens","Transport","apiKey","dsn","parseDsn","sending","circuitBreaker","storageQueue","rateLimiter","recentErrors","Map","deduplicationWindow","flushStoredErrors","URL","projectId","pathname","protocol","host","endpoint","enhancedPayload","replay_session_id","replay_data","scrubbedPayload","scrubSensitiveData","isDuplicate","processQueue","sendRecoverySession","recoveryPayload","useBeacon","blob","Blob","success","controller","AbortController","timeoutId","setTimeout","abort","headers","body","signal","clearTimeout","json","queueError","sendToApi","attempt","statusText","delay","pow","signature","exception","stacktrace","simpleHash","has","set","delete","limit","ms","Promise","resolve","scrubPatterns","scrubFields","scrubbed","removeCircularReferences","scrubObject","hasOwnProperty","some","pattern","seen","WeakSet","sendSessionEvent","eventData","sendReplayClicks","clicks","rateLimitTokens","allErrors","errorsToSend","beaconPayload","DOMSerializer","maxDepth","minSize","skipInvisible","captureColors","totalElements","skippedInvisible","skippedTiny","skippedNonVisual","maxDepthReached","serialize","rootElement","viewport","width","innerWidth","height","innerHeight","scrollX","scrollY","tree","serializeElement","elapsedMs","toFixed","depth","isNonVisualElement","style","getComputedStyle","isInvisible","rect","getBoundingClientRect","serialized","bounds","x","round","left","y","top","bgColor","extractBackgroundColor","layout","detectLayoutType","isInteractive","isText","isTextContainer","children","childElements","from","child","serializedChild","display","visibility","parseFloat","opacity","bottom","right","backgroundColor","rgbToHex","rgb","g","b","toHex","n","hex","onclick","hasAttribute","cursor","estimateSize","compress","removeNulls","ThrottledDOMSerializer","serializer","throttleMs","lastCaptureTime","pendingCapture","timeSinceLastCapture","remainingTime","clearThrottle","ClickTracker","isInstalled","max","snapshotThrottleMs","domSerializer","maxSnapshotSize","domCaptureStats","total","throttled","captured","lastClickTime","clickDebounceMs","debounceStats","totalClicks","debouncedClicks","captureClick","timeSinceLastClick","debounceThreshold","clickEvent","clickData","pageX","pageY","viewportWidth","viewportHeight","elementSelector","generateSelector","domSnapshot","elements","sizeBytes","sizeKB","domError","addEvent","parts","current","selector","containsSensitiveData","CSS","escape","unshift","classes","getCleanClasses","siblings","parentElement","indexOf","classList","cls","test","getDOMCaptureStats","serializerStats","getDebounceStats","debounceRate","cleanup","ReplayBuffer","bufferBeforeErrorSeconds","bufferBeforeErrorClicks","bufferAfterErrorSeconds","bufferAfterErrorClicks","maxBufferSizeMB","buffer","isRecordingAfterError","recordingStartedAt","errorOccurredAt","postErrorEventCount","eventsDropped","bufferFullCount","currentBufferSize","capturedAt","shouldStopRecording","stopRecording","pruneOldEvents","updateStats","startRecordingAfterError","errorContext","errorId","bufferSize","willRecordFor","postErrorEvents","elapsedSeconds","cutoffTime","timeFiltered","clickEvents","e","otherEvents","recentClicks","sort","a","dropped","getEvents","getEventsByPhase","isRecording","bufferLength","approximateSize","estimateBufferSize","deserialize","migratedCount","phaseBreakdown","reduce","acc","migratedEvents","byteSize","ErrorDetector","onErrorDetected","ignoreErrors","Set","recentErrorsCleanupInterval","isRecordingRecovery","recoveryRecordingCleanup","errorsDetected","errorsIgnored","replaysCaptured","duplicatesPrevented","recoveryRecordingsStarted","recoveryRecordingsCancelled","setInterval","uninstall","clearInterval","errorPayload","shouldIgnoreError","errorFingerprint","generateErrorFingerprint","errorMessage","beforeError","afterError","handlingError","commonIgnorePatterns","checkCompleteInterval","unloadHandler","visibilityHandler","removeEventListener","finishRecording","recoveryEvents","once","recovery","recentErrorsCount","setEnabled","enabled","isEnabled","SessionManager","sessionTimeoutMinutes","STORAGE_KEY_SESSION_ID","STORAGE_KEY_SESSION_METADATA","metadata","startedAt","lastActivityAt","pageCount","pages","initialize","loadSession","isSessionExpired","createNewSession","updateActivity","trackPageView","setupPageTransitionTracking","saveSession","metadataJson","age","getSessionAge","lastActivity","pageEvent","handleNavigationChange","getMetadata","substr","clearSession","extendSession","getSessionInfo","ageMinutes","isExpired","recentPages","timeoutMinutes","StorageManager","STORAGE_KEY_BUFFER","STORAGE_KEY_METADATA","savesSuccessful","savesFailed","loadsSuccessful","loadsFailed","quotaExceededCount","cleanupCount","save","bufferData","estimatedSize","maxSizeBytes","sizeMB","pruneBuffer","saveMetadata","savedAt","prunedBuffer","load","loadMetadata","ageHours","pruned","removed","originalEvents","prunedEvents","originalSize","prunedSize","getSpaceInfo","testKey","testData","repeat","available","used","usedBytes","usedMB","availableMB","totalMB","spaceInfo","isAvailable","ApplicationLogger","sessionReplayEnabled","exposeApi","storageManager","heatmap","initializeSessionReplay","client","initialized","handleReplayCapture","bind","savedBuffer","init","bufferSaveInterval","saveBufferToStorage","sdkLoadTime","bufferedErrors","addBreadcrumb","sessionReplay","enable","disable","sessionAge","storageStats","errorDetectorStats"],"mappings":"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"}