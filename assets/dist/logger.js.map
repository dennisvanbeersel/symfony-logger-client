{"version":3,"file":"logger.js","sources":["../src/client.js","../src/breadcrumbs.js","../src/circuit-breaker.js","../src/storage-queue.js","../src/rate-limiter.js","../src/transport.js","../src/dom-serializer.js","../src/click-tracker.js","../src/replay-buffer.js","../src/error-detector.js","../src/session-manager.js","../src/storage-manager.js","../src/index.js"],"sourcesContent":["/**\n * Client for capturing errors and sending to platform\n *\n * ERROR-TRIGGERED SESSION REPLAY:\n * - When error detected, triggers replay buffer capture\n * - Sends buffered events (before/after error) to backend\n * - Links replay data to error for debugging\n *\n * RESILIENCE FEATURES:\n * - Beacon API for page unload events (ensures critical errors are sent)\n * - All error handling wrapped in try-catch\n * - Never crashes on logging errors\n */\nexport class Client {\n    /**\n     * @param {Object} config - Configuration options\n     * @param {Transport} transport - Transport layer for API communication\n     * @param {BreadcrumbCollector} breadcrumbs - Breadcrumb tracking\n     * @param {ErrorDetector|null} errorDetector - Error detector for replay capture (optional)\n     */\n    constructor(config, transport, breadcrumbs, errorDetector = null) {\n        this.config = config;\n        this.transport = transport;\n        this.breadcrumbs = breadcrumbs;\n        this.errorDetector = errorDetector;\n        this.userContext = null;\n        this.tags = {};\n        this.extra = {};\n        this.pendingBeaconErrors = [];\n    }\n\n    /**\n   * Install global error handlers\n   */\n    install() {\n        try {\n            // Handle uncaught errors\n            window.addEventListener('error', (event) => {\n                try {\n                    this.captureException(event.error || new Error(event.message), {\n                        extra: {\n                            filename: event.filename,\n                            lineno: event.lineno,\n                            colno: event.colno,\n                        },\n                    });\n                } catch (error) {\n                    // Never crash on error handling\n                    console.error('ApplicationLogger: Failed to capture error', error);\n                }\n            });\n\n            // Handle unhandled promise rejections\n            window.addEventListener('unhandledrejection', (event) => {\n                try {\n                    this.captureException(event.reason, {\n                        extra: {\n                            type: 'unhandledrejection',\n                        },\n                    });\n                } catch (error) {\n                    console.error('ApplicationLogger: Failed to capture rejection', error);\n                }\n            });\n\n            // Use Beacon API for page unload to ensure critical errors are sent\n            window.addEventListener('beforeunload', () => {\n                this.flushBeaconErrors();\n            });\n\n            // Also try on visibilitychange (for mobile)\n            document.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'hidden') {\n                    this.flushBeaconErrors();\n                }\n            });\n\n            // Track breadcrumbs\n            this.breadcrumbs.install();\n        } catch (error) {\n            // Installation failure should never crash the app\n            console.error('ApplicationLogger: Failed to install', error);\n        }\n    }\n\n    /**\n     * Capture exception and trigger session replay if enabled\n     *\n     * Flow (with session replay):\n     * 1. Build error payload\n     * 2. If errorDetector enabled, capture replay data first\n     * 3. Send error WITH replay data to backend in single request\n     * 4. If errorDetector disabled, send error without replay data\n     */\n    async captureException(error, options = {}) {\n        try {\n            // Build error payload\n            const payload = this.buildPayload(error, 'error', options);\n\n            // Capture session replay data if enabled (before sending error)\n            let replayData = null;\n            if (this.errorDetector) {\n                const replayCapture = await this.errorDetector.handleError(error, payload);\n                if (replayCapture) {\n                    replayData = {\n                        sessionId: replayCapture.sessionId,\n                        events: replayCapture.events,\n                    };\n                }\n            }\n\n            // Send error to backend (with replay data if captured)\n            await this.transport.send(payload, replayData);\n        } catch (captureError) {\n            // Never crash on error capture\n            console.error('Client: Failed to capture exception', captureError);\n        }\n    }\n\n    /**\n   * Capture message\n   */\n    captureMessage(message, level = 'info', options = {}) {\n        const payload = this.buildPayload(new Error(message), level, options);\n        this.transport.send(payload);\n    }\n\n    /**\n   * Build error payload matching API expectations\n   *\n   * API expects flat structure with snake_case field names:\n   * {type, message, file, line, stack_trace, level, environment, ...}\n   */\n    buildPayload(error, level, options = {}) {\n        try {\n            const stackTrace = this.parseStackTrace(error);\n            const firstFrame = stackTrace.length > 0 ? stackTrace[0] : null;\n\n            // Build payload matching exact API format\n            const payload = {\n                // Required fields (flat structure, not nested)\n                type: error.name || 'Error',\n                message: error.message || 'Unknown error',\n                file: firstFrame?.file || options.extra?.filename || 'unknown',\n                line: firstFrame?.line || options.extra?.lineno || 0,\n                stack_trace: stackTrace,\n\n                // Optional fields (snake_case to match API)\n                level: level || 'error',\n                source: 'frontend',\n                environment: this.config.environment || 'production',\n                release: this.config.release || null,\n                url: window.location.href,\n                http_method: this.detectHttpMethod(),\n                http_status_code: this.extractHttpStatusCode(error, options),\n                session_hash: this.getSessionHash(),\n                timestamp: new Date().toISOString(),\n                runtime: `JavaScript ${this.getBrowserInfo()}`,\n                user_agent: navigator.userAgent,\n                breadcrumbs: this.breadcrumbs.get(),\n                context: { ...this.extra, ...options.extra },\n                tags: { ...this.tags, ...options.tags },\n            };\n\n            // Clean up null values to reduce payload size\n            return this.removeNullValues(payload);\n        } catch (error) {\n            // If payload building completely fails, return minimal payload\n            console.error('ApplicationLogger: Failed to build payload', error);\n            return {\n                type: 'Error',\n                message: 'Failed to build error payload',\n                file: 'unknown',\n                line: 0,\n                stack_trace: [],\n                level: 'error',\n            };\n        }\n    }\n\n    /**\n   * Parse error stack trace with cross-browser support\n   *\n   * Returns array of frames matching API format:\n   * [{file, line, function, class, column}, ...]\n   */\n    parseStackTrace(error) {\n        if (!error.stack) {\n            return [{\n                file: 'unknown',\n                line: 0,\n                function: 'unknown',\n            }];\n        }\n\n        try {\n            const lines = error.stack.split('\\n');\n            const frames = [];\n\n            for (const line of lines) {\n                const frame = this.parseStackLine(line.trim());\n                if (frame) {\n                    frames.push(frame);\n                }\n            }\n\n            return frames.length > 0 ? frames : [{\n                file: 'unknown',\n                line: 0,\n                function: 'unknown',\n            }];\n        } catch {\n            return [{\n                file: 'unknown',\n                line: 0,\n                function: 'unknown',\n            }];\n        }\n    }\n\n    /**\n   * Parse a single stack trace line (cross-browser)\n   *\n   * Handles formats from Chrome, Firefox, Safari, Edge\n   */\n    parseStackLine(line) {\n        if (!line) {\n            return null;\n        }\n\n        // Chrome/V8: \"at functionName (file.js:line:col)\"\n        let match = line.match(/at\\s+(.+?)\\s+\\((.+?):(\\d+):(\\d+)\\)/);\n        if (match) {\n            return {\n                function: match[1].trim(),\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Chrome/V8 anonymous: \"at file.js:line:col\"\n        match = line.match(/at\\s+(.+?):(\\d+):(\\d+)/);\n        if (match) {\n            return {\n                function: 'anonymous',\n                file: match[1],\n                line: parseInt(match[2], 10),\n                column: parseInt(match[3], 10),\n            };\n        }\n\n        // Firefox: \"functionName@file.js:line:col\"\n        match = line.match(/(.+?)@(.+?):(\\d+):(\\d+)/);\n        if (match) {\n            return {\n                function: match[1] || 'anonymous',\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Safari/Firefox (no column): \"functionName@file.js:line\"\n        match = line.match(/(?:(.+)@)?(.+?):(\\d+)$/);\n        if (match) {\n            return {\n                function: match[1] || 'anonymous',\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: null,\n            };\n        }\n\n        // Edge legacy: \"at functionName (file.js:line:col)\"\n        match = line.match(/at\\s+(.+?)\\s+\\[(.+?):(\\d+):(\\d+)\\]/);\n        if (match) {\n            return {\n                function: match[1].trim(),\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Could not parse this line\n        return null;\n    }\n\n    /**\n   * Detect HTTP method for current page load\n   */\n    detectHttpMethod() {\n        try {\n            // Try to detect from performance API\n            const navigation = performance.getEntriesByType('navigation')[0];\n            if (navigation && navigation.type) {\n                // Navigation types: navigate, reload, back_forward, prerender\n                return 'GET'; // Page loads are always GET\n            }\n        } catch {\n            // Performance API not available\n        }\n\n        // Default to GET (most common for page loads)\n        return 'GET';\n    }\n\n    /**\n     * Extract HTTP status code from error context.\n     *\n     * Attempts to extract status code from:\n     * 1. Error object's status property (fetch Response)\n     * 2. Options extra data (manually passed)\n     * 3. Error message parsing (e.g., \"HTTP 404 Not Found\")\n     *\n     * @param {Error} error - The error object\n     * @param {Object} options - Additional options passed to captureException\n     * @returns {number|null} HTTP status code or null if not available\n     */\n    extractHttpStatusCode(error, options = {}) {\n        try {\n            // Check if error has status property (fetch Response errors)\n            if (error.status && typeof error.status === 'number') {\n                return error.status;\n            }\n\n            // Check if status was passed in options\n            if (options.httpStatusCode && typeof options.httpStatusCode === 'number') {\n                return options.httpStatusCode;\n            }\n\n            // Check extra context for status code\n            if (options.extra?.http_status_code && typeof options.extra.http_status_code === 'number') {\n                return options.extra.http_status_code;\n            }\n\n            if (options.extra?.httpStatusCode && typeof options.extra.httpStatusCode === 'number') {\n                return options.extra.httpStatusCode;\n            }\n\n            // Try to parse status code from error message (e.g., \"HTTP 404 Not Found\")\n            if (error.message) {\n                const match = error.message.match(/HTTP\\s+(\\d{3})/i);\n                if (match) {\n                    const status = parseInt(match[1], 10);\n                    if (status >= 100 && status < 600) {\n                        return status;\n                    }\n                }\n            }\n\n            // No HTTP status code available\n            return null;\n        } catch {\n            // If extraction fails, return null\n            return null;\n        }\n    }\n\n    /**\n   * Get browser info from user agent\n   */\n    getBrowserInfo() {\n        const ua = navigator.userAgent;\n\n        if (ua.includes('Chrome') && !ua.includes('Edge')) {\n            return 'Chrome';\n        }\n        if (ua.includes('Firefox')) {\n            return 'Firefox';\n        }\n        if (ua.includes('Safari') && !ua.includes('Chrome')) {\n            return 'Safari';\n        }\n        if (ua.includes('Edge') || ua.includes('Edg/')) {\n            return 'Edge';\n        }\n        if (ua.includes('MSIE') || ua.includes('Trident/')) {\n            return 'IE';\n        }\n\n        return 'Unknown';\n    }\n\n    /**\n     * Get session hash for GDPR-compliant session tracking\n     *\n     * Priority:\n     * 1. Use sessionHash from config if provided by server (Symfony bundle)\n     * 2. Generate from sessionStorage if available\n     * 3. Return null (errors will be tracked without session linkage)\n     *\n     * @returns {string|null} SHA-256 hash of session ID (64 hex chars)\n     */\n    getSessionHash() {\n        try {\n            // 1. Check if server provided session hash (Symfony bundle sets this)\n            if (this.config.sessionHash) {\n                return this.config.sessionHash;\n            }\n\n            // 2. Try to get/generate from sessionStorage\n            if (typeof sessionStorage !== 'undefined') {\n                let sessionId = sessionStorage.getItem('_app_logger_session_id');\n\n                if (!sessionId) {\n                    // Generate new session ID for this browser session\n                    sessionId = this.generateSessionId();\n                    sessionStorage.setItem('_app_logger_session_id', sessionId);\n                }\n\n                // Generate SHA-256 hash synchronously (simple implementation)\n                return this.sha256(sessionId);\n            }\n\n            // 3. No session tracking available\n            return null;\n        } catch {\n            // If session tracking fails, return null (errors still captured)\n            return null;\n        }\n    }\n\n    /**\n     * Generate a unique session ID for client-side session tracking\n     *\n     * @returns {string} Random session ID\n     */\n    generateSessionId() {\n        // Use crypto.randomUUID if available (modern browsers)\n        if (crypto && crypto.randomUUID) {\n            return crypto.randomUUID();\n        }\n\n        // Fallback: Generate random string\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = Math.random() * 16 | 0;\n            const v = c === 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n\n    /**\n     * Simple synchronous SHA-256 implementation\n     *\n     * This is a simplified hash function for client-side session hashing.\n     * While not cryptographically secure for production use, it's sufficient\n     * for generating consistent session hashes for tracking purposes.\n     *\n     * @param {string} str - String to hash\n     * @returns {string} 64-character hexadecimal hash\n     */\n    sha256(str) {\n        // Simple djb2-like hash (not real SHA-256, but consistent and sufficient)\n        let hash = 5381;\n        for (let i = 0; i < str.length; i++) {\n            hash = ((hash << 5) + hash) + str.charCodeAt(i);\n        }\n\n        // Convert to hex and pad to 64 characters for consistency with PHP hash('sha256')\n        // This is a simplified version - for production, consider using Web Crypto API\n        const hex = Math.abs(hash).toString(16);\n        return hex.padStart(64, '0');\n    }\n\n    /**\n   * Remove null/undefined values from object to reduce payload size\n   */\n    removeNullValues(obj) {\n        const cleaned = {};\n\n        for (const [key, value] of Object.entries(obj)) {\n            if (value !== null && value !== undefined) {\n                cleaned[key] = value;\n            }\n        }\n\n        return cleaned;\n    }\n\n    setUser(user) {\n        this.userContext = user;\n    }\n\n    setTags(tags) {\n        this.tags = { ...this.tags, ...tags };\n    }\n\n    setExtra(extra) {\n        this.extra = { ...this.extra, ...extra };\n    }\n\n    /**\n     * Flush pending errors using Beacon API\n     * Called on page unload to ensure critical errors are sent\n     */\n    flushBeaconErrors() {\n        try {\n            // Check if Beacon API is available\n            if (!navigator.sendBeacon) {\n                return;\n            }\n\n            // Get transport stats to check for pending errors\n            const stats = this.transport.getStats();\n\n            if (stats.storedErrors === 0 && stats.queueSize === 0) {\n                return; // Nothing to flush\n            }\n\n            // Delegate to transport's beacon flush method\n            this.transport.flushWithBeacon();\n        } catch {\n            // Never crash on flush - but this is our last chance to send errors\n            // So we silently fail\n        }\n    }\n}\n","/**\n * Breadcrumb collector for tracking user actions\n */\nexport class BreadcrumbCollector {\n    constructor(maxBreadcrumbs = 50) {\n        this.breadcrumbs = [];\n        this.maxBreadcrumbs = maxBreadcrumbs;\n    }\n\n    /**\n   * Install automatic breadcrumb tracking\n   */\n    install() {\n    // Track clicks\n        document.addEventListener('click', (event) => {\n            const target = event.target;\n            const tagName = target.tagName.toLowerCase();\n            let message = `Clicked ${tagName}`;\n\n            // Get className as string (handle SVG elements)\n            const getClassName = (element) => {\n                if (!element.className) return '';\n                // For SVG elements, className is an SVGAnimatedString\n                if (typeof element.className === 'object' && element.className.baseVal !== undefined) {\n                    return element.className.baseVal;\n                }\n                // For HTML elements, className is a string\n                return element.className;\n            };\n\n            const className = getClassName(target);\n\n            if (target.id) {\n                message += `#${target.id}`;\n            } else if (className) {\n                const firstClass = className.split(' ')[0];\n                if (firstClass) {\n                    message += `.${firstClass}`;\n                }\n            }\n\n            this.add({\n                type: 'ui',\n                category: 'click',\n                message,\n                data: {\n                    tag: tagName,\n                    id: target.id,\n                    class: className,\n                },\n            });\n        }, true);\n\n        // Track navigation\n        const originalPushState = history.pushState;\n        const originalReplaceState = history.replaceState;\n\n        history.pushState = (...args) => {\n            this.add({\n                type: 'navigation',\n                category: 'navigation',\n                message: `Navigated to ${args[2]}`,\n                data: { to: args[2] },\n            });\n            return originalPushState.apply(history, args);\n        };\n\n        history.replaceState = (...args) => {\n            this.add({\n                type: 'navigation',\n                category: 'navigation',\n                message: `Replaced state ${args[2]}`,\n                data: { to: args[2] },\n            });\n            return originalReplaceState.apply(history, args);\n        };\n\n        // Track console messages\n        this.wrapConsole();\n\n        // Track fetch requests\n        this.wrapFetch();\n    }\n\n    /**\n   * Add a breadcrumb\n   */\n    add(breadcrumb) {\n        this.breadcrumbs.push({\n            timestamp: new Date().toISOString(),\n            level: breadcrumb.level || 'info',\n            ...breadcrumb,\n        });\n\n        // Limit breadcrumbs\n        if (this.breadcrumbs.length > this.maxBreadcrumbs) {\n            this.breadcrumbs.shift();\n        }\n    }\n\n    /**\n   * Get all breadcrumbs\n   */\n    get() {\n        return this.breadcrumbs;\n    }\n\n    /**\n   * Clear breadcrumbs\n   */\n    clear() {\n        this.breadcrumbs = [];\n    }\n\n    /**\n   * Wrap console methods for breadcrumb tracking\n   */\n    wrapConsole() {\n        const levels = ['log', 'info', 'warn', 'error', 'debug'];\n\n        levels.forEach(level => {\n            // eslint-disable-next-line no-console\n            const original = console[level];\n            // eslint-disable-next-line no-console\n            console[level] = (...args) => {\n                this.add({\n                    type: 'console',\n                    category: 'console',\n                    message: args.join(' '),\n                    level: level === 'log' ? 'info' : level,\n                    data: { arguments: args },\n                });\n                return original.apply(console, args);\n            };\n        });\n    }\n\n    /**\n   * Wrap fetch for HTTP request breadcrumbs\n   */\n    wrapFetch() {\n        const originalFetch = window.fetch;\n\n        window.fetch = async (...args) => {\n            const url = typeof args[0] === 'string' ? args[0] : args[0].url;\n            const method = args[1]?.method || 'GET';\n            const startTime = Date.now();\n\n            try {\n                const response = await originalFetch.apply(window, args);\n                const duration = Date.now() - startTime;\n\n                this.add({\n                    type: 'http',\n                    category: 'fetch',\n                    message: `${method} ${url}`,\n                    data: {\n                        url,\n                        method,\n                        status_code: response.status,\n                        duration,\n                    },\n                    level: response.ok ? 'info' : 'warning',\n                });\n\n                return response;\n            } catch (error) {\n                const duration = Date.now() - startTime;\n\n                this.add({\n                    type: 'http',\n                    category: 'fetch',\n                    message: `${method} ${url} failed`,\n                    data: {\n                        url,\n                        method,\n                        error: error.message,\n                        duration,\n                    },\n                    level: 'error',\n                });\n\n                throw error;\n            }\n        };\n    }\n}\n","/**\n * Circuit Breaker for JavaScript\n *\n * Implements the circuit breaker pattern to prevent repeated calls to a failing service.\n * Uses sessionStorage to persist state across page reloads within the same session.\n *\n * States:\n * - CLOSED: Normal operation, requests go through\n * - OPEN: Service is down, requests are blocked immediately\n * - HALF_OPEN: Testing if service has recovered\n */\nexport class CircuitBreaker {\n    static STATE_CLOSED = 'closed';\n    static STATE_OPEN = 'open';\n    static STATE_HALF_OPEN = 'half_open';\n\n    constructor(config = {}) {\n        this.failureThreshold = config.failureThreshold || 5;\n        this.timeout = config.timeout || 60000; // 60 seconds in milliseconds\n        this.storageKey = 'app_logger_circuit_breaker';\n\n        this.loadState();\n    }\n\n    /**\n     * Check if circuit is open (service down, reject requests)\n     */\n    isOpen() {\n        // Check if we should transition from OPEN to HALF_OPEN\n        if (this.state === CircuitBreaker.STATE_OPEN && this.shouldAttemptReset()) {\n            this.halfOpen();\n        }\n\n        return this.state === CircuitBreaker.STATE_OPEN;\n    }\n\n    /**\n     * Check if circuit is in half-open state\n     */\n    isHalfOpen() {\n        return this.state === CircuitBreaker.STATE_HALF_OPEN;\n    }\n\n    /**\n     * Record a successful request\n     */\n    recordSuccess() {\n        if (this.state === CircuitBreaker.STATE_HALF_OPEN) {\n            // Success in half-open = circuit closes (service recovered)\n            this.close();\n        } else if (this.state === CircuitBreaker.STATE_CLOSED) {\n            // Reset failure count on success\n            this.failureCount = 0;\n            this.saveState();\n        }\n    }\n\n    /**\n     * Record a failed request\n     */\n    recordFailure() {\n        if (this.state === CircuitBreaker.STATE_HALF_OPEN) {\n            // Failure in half-open = circuit opens again\n            this.open();\n        } else if (this.state === CircuitBreaker.STATE_CLOSED) {\n            this.failureCount++;\n\n            if (this.failureCount >= this.failureThreshold) {\n                this.open();\n            } else {\n                this.saveState();\n            }\n        }\n    }\n\n    /**\n     * Get current state for monitoring/debugging\n     */\n    getState() {\n        return {\n            state: this.state,\n            failureCount: this.failureCount,\n            openedAt: this.openedAt,\n        };\n    }\n\n    /**\n     * Manually reset circuit breaker\n     */\n    reset() {\n        this.close();\n    }\n\n    /**\n     * Transition to CLOSED state\n     */\n    close() {\n        this.state = CircuitBreaker.STATE_CLOSED;\n        this.failureCount = 0;\n        this.openedAt = null;\n        this.saveState();\n    }\n\n    /**\n     * Transition to OPEN state\n     */\n    open() {\n        this.state = CircuitBreaker.STATE_OPEN;\n        this.openedAt = Date.now();\n        this.saveState();\n    }\n\n    /**\n     * Transition to HALF_OPEN state\n     */\n    halfOpen() {\n        this.state = CircuitBreaker.STATE_HALF_OPEN;\n        this.saveState();\n    }\n\n    /**\n     * Check if enough time has passed to attempt reset\n     */\n    shouldAttemptReset() {\n        if (!this.openedAt) {\n            return false;\n        }\n\n        return (Date.now() - this.openedAt) >= this.timeout;\n    }\n\n    /**\n     * Load state from sessionStorage\n     */\n    loadState() {\n        try {\n            const stored = sessionStorage.getItem(this.storageKey);\n\n            if (stored) {\n                const state = JSON.parse(stored);\n                this.state = state.state || CircuitBreaker.STATE_CLOSED;\n                this.failureCount = state.failureCount || 0;\n                this.openedAt = state.openedAt || null;\n            } else {\n                this.state = CircuitBreaker.STATE_CLOSED;\n                this.failureCount = 0;\n                this.openedAt = null;\n            }\n        } catch {\n            // If storage fails, default to closed state\n            this.state = CircuitBreaker.STATE_CLOSED;\n            this.failureCount = 0;\n            this.openedAt = null;\n        }\n    }\n\n    /**\n     * Save state to sessionStorage\n     */\n    saveState() {\n        try {\n            const state = {\n                state: this.state,\n                failureCount: this.failureCount,\n                openedAt: this.openedAt,\n            };\n\n            sessionStorage.setItem(this.storageKey, JSON.stringify(state));\n        } catch {\n            // Storage failure should never crash the app\n            // Circuit breaker still works in-memory for this page\n        }\n    }\n}\n","/**\n * Local Storage Queue\n *\n * Buffers failed error submissions in localStorage for later retry.\n * Used when the API is unreachable or circuit breaker is open.\n *\n * Features:\n * - FIFO queue with size limits\n * - Automatic expiration of old errors\n * - Safe storage operations (never crash on quota exceeded)\n */\nexport class StorageQueue {\n    constructor(config = {}) {\n        this.storageKey = 'app_logger_queue';\n        this.maxSize = config.maxSize || 50; // Max errors to store\n        this.maxAge = config.maxAge || 86400000; // 24 hours in milliseconds\n    }\n\n    /**\n     * Add an error to the queue\n     */\n    enqueue(payload) {\n        try {\n            const queue = this.getQueue();\n\n            // Add timestamp for expiration\n            const item = {\n                payload,\n                timestamp: Date.now(),\n            };\n\n            queue.push(item);\n\n            // Limit queue size (FIFO - remove oldest)\n            if (queue.length > this.maxSize) {\n                queue.shift();\n            }\n\n            this.saveQueue(queue);\n        } catch (error) {\n            // Storage failures should never crash the app\n            // Common causes: quota exceeded, private browsing mode\n            console.warn('ApplicationLogger: Failed to queue error', error);\n        }\n    }\n\n    /**\n     * Get next error from queue (FIFO)\n     */\n    dequeue() {\n        try {\n            const queue = this.getQueue();\n\n            if (queue.length === 0) {\n                return null;\n            }\n\n            const item = queue.shift();\n            this.saveQueue(queue);\n\n            return item.payload;\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Get all queued errors\n     */\n    getAll() {\n        const queue = this.getQueue();\n        return queue.map(item => item.payload);\n    }\n\n    /**\n     * Get queue size\n     */\n    size() {\n        const queue = this.getQueue();\n        return queue.length;\n    }\n\n    /**\n     * Clear the queue\n     */\n    clear() {\n        try {\n            localStorage.removeItem(this.storageKey);\n        } catch {\n            // Ignore\n        }\n    }\n\n    /**\n     * Get queue from localStorage with expiration cleanup\n     */\n    getQueue() {\n        try {\n            const stored = localStorage.getItem(this.storageKey);\n\n            if (!stored) {\n                return [];\n            }\n\n            const queue = JSON.parse(stored);\n\n            if (!Array.isArray(queue)) {\n                return [];\n            }\n\n            // Remove expired items\n            const now = Date.now();\n            const filtered = queue.filter(item => {\n                return item.timestamp && (now - item.timestamp) < this.maxAge;\n            });\n\n            // If we removed expired items, save the cleaned queue\n            if (filtered.length !== queue.length) {\n                this.saveQueue(filtered);\n            }\n\n            return filtered;\n        } catch {\n            return [];\n        }\n    }\n\n    /**\n     * Save queue to localStorage\n     */\n    saveQueue(queue) {\n        try {\n            localStorage.setItem(this.storageKey, JSON.stringify(queue));\n        } catch (error) {\n            // Handle quota exceeded or other storage errors\n            if (error.name === 'QuotaExceededError') {\n                // Try to make space by removing oldest items\n                const halfSize = Math.floor(queue.length / 2);\n                const trimmed = queue.slice(-halfSize);\n\n                try {\n                    localStorage.setItem(this.storageKey, JSON.stringify(trimmed));\n                } catch {\n                    // If still failing, clear the queue\n                    this.clear();\n                }\n            }\n        }\n    }\n}\n","/**\n * Rate Limiter\n *\n * Prevents error storms by limiting the number of errors sent per minute.\n * Uses token bucket algorithm for smooth rate limiting.\n *\n * This is critical for resilience - prevents overwhelming the API\n * and consuming excessive bandwidth during error cascades.\n */\nexport class RateLimiter {\n    constructor(config = {}) {\n        this.maxTokens = config.maxTokens || 10; // Max errors per window\n        this.refillRate = config.refillRate || 1; // Tokens per second\n        this.tokens = this.maxTokens;\n        this.lastRefill = Date.now();\n    }\n\n    /**\n     * Check if request is allowed\n     */\n    isAllowed() {\n        this.refillTokens();\n        return this.tokens > 0;\n    }\n\n    /**\n     * Consume a token (record an error sent)\n     */\n    consume() {\n        if (!this.isAllowed()) {\n            return false;\n        }\n\n        this.tokens--;\n        return true;\n    }\n\n    /**\n     * Refill tokens based on time elapsed\n     */\n    refillTokens() {\n        const now = Date.now();\n        const elapsed = (now - this.lastRefill) / 1000; // Convert to seconds\n        const tokensToAdd = Math.floor(elapsed * this.refillRate);\n\n        if (tokensToAdd > 0) {\n            this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);\n            this.lastRefill = now;\n        }\n    }\n\n    /**\n     * Get current token count (for debugging)\n     */\n    getTokens() {\n        this.refillTokens();\n        return this.tokens;\n    }\n\n    /**\n     * Reset rate limiter\n     */\n    reset() {\n        this.tokens = this.maxTokens;\n        this.lastRefill = Date.now();\n    }\n}\n","import { CircuitBreaker } from './circuit-breaker.js';\nimport { StorageQueue } from './storage-queue.js';\nimport { RateLimiter } from './rate-limiter.js';\n\n/**\n * Transport layer for sending errors to the platform\n *\n * RESILIENCE FEATURES:\n * - 3-second timeout with AbortController\n * - Circuit breaker prevents repeated calls to failing service\n * - Smart retry with exponential backoff\n * - Local storage queue for offline errors\n * - Rate limiting to prevent error storms\n * - Deduplication to avoid duplicate errors\n */\nexport class Transport {\n    constructor(config) {\n        this.config = config;\n        this.apiKey = config.apiKey; // Store API key separately (not in DSN)\n        this.dsn = this.parseDsn(config.dsn);\n        this.queue = [];\n        this.sending = false;\n\n        // Initialize resilience components\n        this.circuitBreaker = new CircuitBreaker({\n            failureThreshold: 5,\n            timeout: 60000, // 60 seconds\n        });\n\n        this.storageQueue = new StorageQueue({\n            maxSize: 50,\n            maxAge: 86400000, // 24 hours\n        });\n\n        this.rateLimiter = new RateLimiter({\n            maxTokens: 10, // Max 10 errors per minute\n            refillRate: 0.167, // Refill ~10 tokens per minute\n        });\n\n        // Deduplication cache\n        this.recentErrors = new Map();\n        this.deduplicationWindow = 5000; // 5 seconds\n\n        // Try to flush stored errors on init\n        this.flushStoredErrors();\n    }\n\n    /**\n   * Parse DSN into components\n   *\n   * DSN format: {protocol}://{host}/{projectId}\n   * Example: https://localhost:8111/b6d8ed85-c0af-4c02-b6bb-bfb0f3609b37\n   *\n   * Note: API key is NOT in the DSN. It's passed separately via config.apiKey.\n   */\n    parseDsn(dsn) {\n        if (!dsn) {\n            throw new Error('DSN is required');\n        }\n\n        try {\n            const url = new URL(dsn);\n            const projectId = url.pathname.replace(/^\\//, ''); // Remove leading slash\n\n            if (!projectId) {\n                throw new Error('DSN must include a project ID in the path');\n            }\n\n            return {\n                protocol: url.protocol.replace(':', ''),\n                host: url.host,\n                projectId: projectId,\n                endpoint: `${url.protocol}//${url.host}/api/errors/ingest`,\n            };\n        } catch (error) {\n            throw new Error(`Invalid DSN format: ${error.message}. Expected: https://host/project-id`);\n        }\n    }\n\n    /**\n   * Send error payload to platform\n   *\n   * @param {Object} payload - Error payload\n   * @param {Object|null} replayData - Optional session replay data\n   * @param {string} replayData.sessionId - Session ID from SessionManager\n   * @param {Array} replayData.events - Buffered events (before + after error)\n   */\n    async send(payload, replayData = null) {\n        try {\n            // Merge replay data into payload if provided\n            let enhancedPayload = payload;\n            if (replayData) {\n                enhancedPayload = {\n                    ...payload,\n                    replay_session_id: replayData.sessionId,\n                    replay_data: replayData.events,\n                };\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Sending error with replay data', {\n                        sessionId: replayData.sessionId,\n                        eventCount: replayData.events?.length || 0,\n                    });\n                }\n            }\n\n            // Scrub sensitive data\n            const scrubbedPayload = this.scrubSensitiveData(enhancedPayload);\n\n            // Check for duplicates\n            if (this.isDuplicate(scrubbedPayload)) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Duplicate error ignored');\n                }\n                return;\n            }\n\n            // Check rate limit\n            if (!this.rateLimiter.consume()) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Rate limit exceeded, error queued');\n                }\n                this.storageQueue.enqueue(scrubbedPayload);\n                return;\n            }\n\n            // Add to queue\n            this.queue.push(scrubbedPayload);\n\n            // Process queue\n            if (!this.sending) {\n                await this.processQueue();\n            }\n        } catch (error) {\n            // Never crash on send errors\n            console.error('ApplicationLogger: Send failed', error);\n        }\n    }\n\n    /**\n   * Process queued errors\n   */\n    async processQueue() {\n        if (this.queue.length === 0 || this.sending) {\n            return;\n        }\n\n        this.sending = true;\n\n        while (this.queue.length > 0) {\n            const payload = this.queue.shift();\n\n            try {\n                await this.sendToApi(payload);\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Error sent successfully');\n                }\n            } catch {\n                // Error already handled in sendToApi\n                // Don't re-queue here as sendToApi handles storage\n            }\n        }\n\n        this.sending = false;\n    }\n\n    /**\n   * Send payload to API with timeout and retry\n   */\n    async sendToApi(payload, attempt = 0) {\n        // Check circuit breaker\n        if (this.circuitBreaker.isOpen()) {\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Circuit breaker is open, error queued to storage');\n            }\n            this.storageQueue.enqueue(payload);\n            return;\n        }\n\n        // Create AbortController for timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 3000); // 3-second timeout\n\n        try {\n            const response = await fetch(this.dsn.endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey, // Use separate API key, not from DSN\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify(payload),\n                signal: controller.signal,\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n\n            // Success!\n            this.circuitBreaker.recordSuccess();\n\n            // Try to flush stored errors on success\n            this.flushStoredErrors();\n\n            return response.json();\n        } catch (error) {\n            clearTimeout(timeoutId);\n\n            // Handle timeout\n            if (error.name === 'AbortError') {\n                this.circuitBreaker.recordFailure();\n\n                if (this.config.debug) {\n                    console.error('ApplicationLogger: Request timeout');\n                }\n\n                this.storageQueue.enqueue(payload);\n                return;\n            }\n\n            // Handle network errors with retry\n            if (attempt < 2) {\n                // Exponential backoff: 1s, 2s\n                const delay = Math.pow(2, attempt) * 1000;\n                await this.delay(delay);\n\n                return this.sendToApi(payload, attempt + 1);\n            }\n\n            // Max retries reached\n            this.circuitBreaker.recordFailure();\n\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Max retries reached', error);\n            }\n\n            this.storageQueue.enqueue(payload);\n        }\n    }\n\n    /**\n   * Check if error is a duplicate\n   */\n    isDuplicate(payload) {\n        try {\n            // Create hash from error signature\n            const signature = JSON.stringify({\n                type: payload.exception?.type,\n                message: payload.exception?.value,\n                stack: payload.exception?.stacktrace?.frames?.slice(0, 3), // Top 3 frames\n            });\n\n            const hash = this.simpleHash(signature);\n\n            // Check if we've seen this recently\n            if (this.recentErrors.has(hash)) {\n                return true;\n            }\n\n            // Add to recent errors\n            this.recentErrors.set(hash, Date.now());\n\n            // Clean up old entries\n            const now = Date.now();\n            for (const [key, timestamp] of this.recentErrors) {\n                if (now - timestamp > this.deduplicationWindow) {\n                    this.recentErrors.delete(key);\n                }\n            }\n\n            return false;\n        } catch {\n            return false; // If deduplication fails, allow the error through\n        }\n    }\n\n    /**\n   * Simple hash function\n   */\n    simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            const char = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // Convert to 32bit integer\n        }\n        return hash.toString();\n    }\n\n    /**\n   * Flush errors from storage queue\n   */\n    async flushStoredErrors() {\n        try {\n            const queueSize = this.storageQueue.size();\n\n            if (queueSize === 0) {\n                return;\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Flushing ${queueSize} stored errors`);\n            }\n\n            // Limit flush to 5 errors at a time to avoid overwhelming\n            const limit = Math.min(queueSize, 5);\n\n            for (let i = 0; i < limit; i++) {\n                const payload = this.storageQueue.dequeue();\n\n                if (payload) {\n                    // Add to queue (but don't recurse infinitely)\n                    this.queue.push(payload);\n                }\n            }\n\n            // Process the queue\n            if (!this.sending && this.queue.length > 0) {\n                await this.processQueue();\n            }\n        } catch (error) {\n            // Never crash on flush\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Flush failed', error);\n            }\n        }\n    }\n\n    /**\n   * Delay helper for retry backoff\n   */\n    delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    /**\n   * Scrub sensitive data from payload\n   */\n    scrubSensitiveData(payload) {\n        const scrubFields = this.config.scrubFields || [];\n        const scrubPatterns = [\n            ...scrubFields,\n            'password',\n            'passwd',\n            'pwd',\n            'secret',\n            'api_key',\n            'apikey',\n            'token',\n            'auth',\n            'authorization',\n            'private_key',\n            'access_token',\n            'refresh_token',\n        ];\n\n        // Deep clone payload (handle circular references)\n        let scrubbed;\n        try {\n            scrubbed = JSON.parse(JSON.stringify(payload));\n        } catch {\n            // Circular reference detected - work with original and remove circular refs\n            scrubbed = this.removeCircularReferences(payload);\n        }\n\n        // Recursively scrub object\n        const scrubObject = (obj) => {\n            if (!obj || typeof obj !== 'object') {\n                return obj;\n            }\n\n            for (const key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    // Check if key matches scrub pattern\n                    const shouldScrub = scrubPatterns.some(pattern =>\n                        key.toLowerCase().includes(pattern.toLowerCase()),\n                    );\n\n                    if (shouldScrub) {\n                        obj[key] = '[REDACTED]';\n                    } else if (typeof obj[key] === 'object') {\n                        scrubObject(obj[key]);\n                    }\n                }\n            }\n\n            return obj;\n        };\n\n        return scrubObject(scrubbed);\n    }\n\n    /**\n     * Remove circular references from an object.\n     * Uses a WeakSet to track visited objects and prevent infinite loops.\n     *\n     * @param {Object} obj - Object to process\n     * @param {WeakSet} [seen] - Set of already visited objects\n     * @returns {Object} Object with circular references replaced\n     */\n    removeCircularReferences(obj, seen = new WeakSet()) {\n        // Handle primitives and null\n        if (obj === null || typeof obj !== 'object') {\n            return obj;\n        }\n\n        // Handle circular reference\n        if (seen.has(obj)) {\n            return '[Circular Reference]';\n        }\n\n        // Add to seen set\n        seen.add(obj);\n\n        // Handle arrays\n        if (Array.isArray(obj)) {\n            return obj.map(item => this.removeCircularReferences(item, seen));\n        }\n\n        // Handle objects\n        const result = {};\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                try {\n                    result[key] = this.removeCircularReferences(obj[key], seen);\n                } catch {\n                    // Skip properties that throw errors when accessed\n                    result[key] = '[Error accessing property]';\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Send session event to API\n     */\n    async sendSessionEvent(sessionId, eventData) {\n        if (!sessionId || !eventData) {\n            return;\n        }\n\n        try {\n            const url = `${this.dsn.protocol}://${this.dsn.host}/api/v1/sessions/${sessionId}/events`;\n\n            const response = await fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey,\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify(eventData),\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}`);\n            }\n\n            return response.json();\n        } catch (error) {\n            // Silently fail - session tracking is non-critical\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Failed to send session event', error);\n            }\n        }\n    }\n\n    /**\n     * Send session replay click data to API (batch)\n     */\n    async sendReplayClicks(sessionId, clicks) {\n        if (!sessionId || !clicks || clicks.length === 0) {\n            return;\n        }\n\n        try {\n            const url = `${this.dsn.protocol}://${this.dsn.host}/api/v1/sessions/${sessionId}/replay`;\n\n            const response = await fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey,\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify({ clicks }),\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}`);\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Sent ${clicks.length} heatmap clicks`);\n            }\n\n            return response.json();\n        } catch (error) {\n            // Silently fail - heatmap tracking is non-critical\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Failed to send heatmap data', error);\n            }\n        }\n    }\n\n    /**\n   * Get stats for monitoring\n   */\n    getStats() {\n        return {\n            queueSize: this.queue.length,\n            storedErrors: this.storageQueue.size(),\n            circuitBreaker: this.circuitBreaker.getState(),\n            rateLimitTokens: this.rateLimiter.getTokens(),\n        };\n    }\n\n    /**\n   * Flush pending errors using Beacon API\n   * Called on page unload to ensure errors are sent even as page closes\n   */\n    flushWithBeacon() {\n        try {\n            // Get all stored errors (from offline queue)\n            const storedErrors = this.storageQueue.getAll();\n\n            // Also include current queue\n            const allErrors = [...this.queue, ...storedErrors];\n\n            if (allErrors.length === 0) {\n                return;\n            }\n\n            // Limit to 10 most recent errors to avoid payload size issues\n            const errorsToSend = allErrors.slice(-10);\n\n            // Beacon API has limitations with headers, so we include DSN in body\n            const beaconPayload = {\n                dsn: this.config.dsn,\n                errors: errorsToSend,\n            };\n\n            const blob = new Blob([JSON.stringify(beaconPayload)], {\n                type: 'application/json',\n            });\n\n            // Try to send via Beacon API\n            const sent = navigator.sendBeacon(this.dsn.endpoint, blob);\n\n            if (sent) {\n                // Successfully queued for sending\n                // Clear the storage queue and current queue\n                this.storageQueue.clear();\n                this.queue = [];\n\n                if (this.config.debug) {\n                    console.warn(`ApplicationLogger: Flushed ${errorsToSend.length} errors via Beacon API`);\n                }\n            }\n        } catch (error) {\n            // Beacon flush failed - errors remain in storage for next session\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Beacon flush failed', error);\n            }\n        }\n    }\n}\n","/**\n * DOM Serializer - Privacy-First Visual Structure Capture\n *\n * CRITICAL: This module captures ONLY visual DOM structure for session replay.\n * It is designed with privacy as the #1 priority.\n *\n * ✅ WHAT IS CAPTURED:\n * - Element tag names (div, button, input, etc.)\n * - Bounding rectangles (x, y, width, height)\n * - Background colors (computed styles)\n * - Layout types (flex, grid, block, inline)\n * - Parent-child relationships (tree structure)\n *\n * ❌ WHAT IS NEVER CAPTURED:\n * - Text content (NO textContent, innerText, innerHTML)\n * - Attribute values (NO id, class, href, src, data-*)\n * - Form values (NO input values, textarea, select options)\n * - User-generated content (NO comments, user text)\n * - Sensitive styles (NO font-family, content properties)\n * - URLs or file paths (NO src, href, background-image)\n *\n * PRIVACY GUARANTEE:\n * All data is sanitized client-side. The server receives ONLY:\n * - Visual block structure (colored rectangles)\n * - Element types (for rendering context)\n * - Layout information (for accurate replay)\n *\n * This allows session replay visualization without exposing any user data.\n */\nexport class DOMSerializer {\n    constructor(options = {}) {\n        this.maxDepth = options.maxDepth || 10; // Prevent deep recursion\n        this.minSize = options.minSize || 5; // Skip tiny elements (px)\n        this.skipInvisible = options.skipInvisible !== false; // Skip hidden elements\n        this.captureColors = options.captureColors !== false; // Capture bg colors\n        this.debug = options.debug || false;\n\n        // Performance tracking\n        this.stats = {\n            totalElements: 0,\n            skippedInvisible: 0,\n            skippedTiny: 0,\n            skippedNonVisual: 0,\n            maxDepthReached: 0,\n        };\n    }\n\n    /**\n     * Serialize the current DOM tree to a privacy-safe structure.\n     *\n     * @param {Element} [rootElement=document.body] - Root element to serialize\n     * @returns {Object} Serialized DOM structure\n     */\n    serialize(rootElement = document.body) {\n        // Reset stats\n        this.stats = {\n            totalElements: 0,\n            skippedInvisible: 0,\n            skippedTiny: 0,\n            skippedNonVisual: 0,\n            maxDepthReached: 0,\n        };\n\n        const startTime = performance.now();\n\n        try {\n            // Get viewport dimensions for context\n            const viewport = {\n                width: window.innerWidth,\n                height: window.innerHeight,\n                scrollX: window.scrollX,\n                scrollY: window.scrollY,\n            };\n\n            // Serialize the tree\n            const tree = this.serializeElement(rootElement, 0);\n\n            const elapsed = performance.now() - startTime;\n\n            if (this.debug) {\n                console.warn('DOM Serialization Stats:', {\n                    ...this.stats,\n                    elapsedMs: elapsed.toFixed(2),\n                });\n            }\n\n            return {\n                viewport,\n                tree,\n                timestamp: Date.now(),\n                stats: this.stats,\n            };\n        } catch (error) {\n            console.error('DOM serialization failed:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Serialize a single element and its children recursively.\n     *\n     * @private\n     * @param {Element} element - Element to serialize\n     * @param {number} depth - Current recursion depth\n     * @returns {Object|null} Serialized element or null if skipped\n     */\n    serializeElement(element, depth) {\n        // Check depth limit\n        if (depth >= this.maxDepth) {\n            this.stats.maxDepthReached++;\n            return null;\n        }\n\n        // Skip non-visual elements\n        if (this.isNonVisualElement(element)) {\n            this.stats.skippedNonVisual++;\n            return null;\n        }\n\n        // Get computed style (for visibility and color)\n        const style = window.getComputedStyle(element);\n\n        // Skip invisible elements\n        if (this.skipInvisible && this.isInvisible(element, style)) {\n            this.stats.skippedInvisible++;\n            return null;\n        }\n\n        // Get bounding rectangle\n        const rect = element.getBoundingClientRect();\n\n        // Skip tiny elements (noise)\n        if (rect.width < this.minSize || rect.height < this.minSize) {\n            this.stats.skippedTiny++;\n            return null;\n        }\n\n        this.stats.totalElements++;\n\n        // Build serialized element\n        const serialized = {\n            // Element type (tag name)\n            type: element.tagName.toLowerCase(),\n\n            // Bounding box (relative to viewport)\n            bounds: {\n                x: Math.round(rect.left + window.scrollX),\n                y: Math.round(rect.top + window.scrollY),\n                width: Math.round(rect.width),\n                height: Math.round(rect.height),\n            },\n\n            // Visual properties\n            bgColor: this.captureColors ? this.extractBackgroundColor(style) : null,\n            layout: this.detectLayoutType(style),\n\n            // Meta information (for better rendering)\n            isInteractive: this.isInteractive(element),\n            isText: this.isTextContainer(element),\n        };\n\n        // Serialize children recursively\n        const children = [];\n        const childElements = Array.from(element.children);\n\n        for (const child of childElements) {\n            const serializedChild = this.serializeElement(child, depth + 1);\n            if (serializedChild) {\n                children.push(serializedChild);\n            }\n        }\n\n        if (children.length > 0) {\n            serialized.children = children;\n        }\n\n        return serialized;\n    }\n\n    /**\n     * Check if element is non-visual (script, style, etc.).\n     *\n     * @private\n     * @param {Element} element\n     * @returns {boolean}\n     */\n    isNonVisualElement(element) {\n        const nonVisualTags = [\n            'SCRIPT',\n            'STYLE',\n            'LINK',\n            'META',\n            'NOSCRIPT',\n            'TITLE',\n            'HEAD',\n            'BASE',\n        ];\n\n        return nonVisualTags.includes(element.tagName);\n    }\n\n    /**\n     * Check if element is invisible (display:none, visibility:hidden, etc.).\n     *\n     * @private\n     * @param {Element} element\n     * @param {CSSStyleDeclaration} style - Computed style\n     * @returns {boolean}\n     */\n    isInvisible(element, style) {\n        // Display none\n        if (style.display === 'none') {\n            return true;\n        }\n\n        // Visibility hidden\n        if (style.visibility === 'hidden') {\n            return true;\n        }\n\n        // Fully transparent\n        if (parseFloat(style.opacity) === 0) {\n            return true;\n        }\n\n        // Outside viewport (way off-screen)\n        const rect = element.getBoundingClientRect();\n        if (\n            rect.bottom < -1000 ||\n            rect.top > window.innerHeight + 1000 ||\n            rect.right < -1000 ||\n            rect.left > window.innerWidth + 1000\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Extract background color from computed style (privacy-safe).\n     *\n     * @private\n     * @param {CSSStyleDeclaration} style\n     * @returns {string|null} Hex color or null\n     */\n    extractBackgroundColor(style) {\n        try {\n            const bgColor = style.backgroundColor;\n\n            // Skip transparent\n            if (!bgColor || bgColor === 'transparent' || bgColor === 'rgba(0, 0, 0, 0)') {\n                return null;\n            }\n\n            // Convert to hex (simpler storage)\n            return this.rgbToHex(bgColor);\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Convert RGB/RGBA color to hex format.\n     *\n     * @private\n     * @param {string} rgb - RGB/RGBA color string\n     * @returns {string|null} Hex color\n     */\n    rgbToHex(rgb) {\n        try {\n            // Match rgb(r, g, b) or rgba(r, g, b, a)\n            const match = rgb.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*[\\d.]+)?\\)/);\n            if (!match) {\n                return null;\n            }\n\n            const r = parseInt(match[1], 10);\n            const g = parseInt(match[2], 10);\n            const b = parseInt(match[3], 10);\n\n            // Convert to hex\n            const toHex = (n) => {\n                const hex = n.toString(16);\n                return hex.length === 1 ? '0' + hex : hex;\n            };\n\n            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Detect layout type (flex, grid, block, inline).\n     *\n     * @private\n     * @param {CSSStyleDeclaration} style\n     * @returns {string}\n     */\n    detectLayoutType(style) {\n        const display = style.display;\n\n        if (display.includes('flex')) {\n            return 'flex';\n        }\n\n        if (display.includes('grid')) {\n            return 'grid';\n        }\n\n        if (display === 'inline' || display === 'inline-block') {\n            return 'inline';\n        }\n\n        return 'block';\n    }\n\n    /**\n     * Check if element is interactive (button, link, input, etc.).\n     *\n     * @private\n     * @param {Element} element\n     * @returns {boolean}\n     */\n    isInteractive(element) {\n        const interactiveTags = [\n            'A',\n            'BUTTON',\n            'INPUT',\n            'SELECT',\n            'TEXTAREA',\n            'LABEL',\n        ];\n\n        if (interactiveTags.includes(element.tagName)) {\n            return true;\n        }\n\n        // Check for click handlers (heuristic)\n        if (element.onclick || element.hasAttribute('onclick')) {\n            return true;\n        }\n\n        // Check for cursor pointer\n        const style = window.getComputedStyle(element);\n        if (style.cursor === 'pointer') {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if element is a text container (p, span, h1-h6, etc.).\n     *\n     * @private\n     * @param {Element} element\n     * @returns {boolean}\n     */\n    isTextContainer(element) {\n        const textTags = [\n            'P',\n            'SPAN',\n            'H1',\n            'H2',\n            'H3',\n            'H4',\n            'H5',\n            'H6',\n            'LI',\n            'LABEL',\n            'TD',\n            'TH',\n            'CODE',\n            'PRE',\n        ];\n\n        return textTags.includes(element.tagName);\n    }\n\n    /**\n     * Get statistics about the last serialization.\n     *\n     * @returns {Object} Statistics\n     */\n    getStats() {\n        return { ...this.stats };\n    }\n\n    /**\n     * Calculate approximate payload size (for debugging).\n     *\n     * @param {Object} serialized - Serialized DOM structure\n     * @returns {number} Approximate size in bytes\n     */\n    estimateSize(serialized) {\n        try {\n            const json = JSON.stringify(serialized);\n            return json.length;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Compress serialized structure (remove nulls, optimize).\n     *\n     * @param {Object} serialized - Serialized DOM structure\n     * @returns {Object} Compressed structure\n     */\n    compress(serialized) {\n        // Remove null/undefined values\n        const removeNulls = (obj) => {\n            if (Array.isArray(obj)) {\n                return obj.map(removeNulls);\n            }\n\n            if (obj !== null && typeof obj === 'object') {\n                const cleaned = {};\n                for (const key in obj) {\n                    if (obj[key] !== null && obj[key] !== undefined) {\n                        cleaned[key] = removeNulls(obj[key]);\n                    }\n                }\n                return cleaned;\n            }\n\n            return obj;\n        };\n\n        return removeNulls(serialized);\n    }\n}\n\n/**\n * Throttled DOM Serializer - Prevents excessive snapshots.\n *\n * Wraps DOMSerializer with throttling to limit snapshot frequency.\n * This prevents performance issues and excessive data collection.\n */\nexport class ThrottledDOMSerializer {\n    constructor(options = {}) {\n        this.serializer = new DOMSerializer(options);\n        this.throttleMs = options.throttleMs || 1000; // Default: 1 snapshot per second\n        this.lastCaptureTime = 0;\n        this.pendingCapture = null;\n    }\n\n    /**\n     * Serialize DOM with throttling.\n     *\n     * @param {Element} [rootElement] - Root element to serialize\n     * @returns {Object|null} Serialized structure or null if throttled\n     */\n    serialize(rootElement) {\n        const now = Date.now();\n        const timeSinceLastCapture = now - this.lastCaptureTime;\n\n        // Check if throttled\n        if (timeSinceLastCapture < this.throttleMs) {\n            // Throttled - schedule capture for later\n            if (!this.pendingCapture) {\n                const remainingTime = this.throttleMs - timeSinceLastCapture;\n                this.pendingCapture = setTimeout(() => {\n                    this.pendingCapture = null;\n                    this.lastCaptureTime = Date.now();\n                    // Capture will happen on next call\n                }, remainingTime);\n            }\n            return null;\n        }\n\n        // Not throttled - perform capture\n        this.lastCaptureTime = now;\n        return this.serializer.serialize(rootElement);\n    }\n\n    /**\n     * Get serializer statistics.\n     *\n     * @returns {Object}\n     */\n    getStats() {\n        return this.serializer.getStats();\n    }\n\n    /**\n     * Clear pending throttle timer.\n     */\n    clearThrottle() {\n        if (this.pendingCapture) {\n            clearTimeout(this.pendingCapture);\n            this.pendingCapture = null;\n        }\n    }\n}\n","import { ThrottledDOMSerializer } from './dom-serializer.js';\n\n/**\n * Click Tracker - Captures user clicks and interactions for Session Replay\n *\n * ERROR-TRIGGERED RECORDING ONLY:\n * - Records clicks to buffer (not sent immediately)\n * - Buffer sent only when error detected (via ErrorDetector)\n * - Captures N seconds/clicks before and after error\n *\n * FEATURES:\n * - Click coordinate tracking with viewport dimensions\n * - Element selector generation (CSS selectors)\n * - DOM structure capture for session replay (privacy-safe)\n * - Page transition tracking (for cross-page sessions)\n * - Privacy-respecting (no PII in selectors or DOM snapshots)\n * - Click debouncing to prevent localStorage spam from rapid clicking\n */\nexport class ClickTracker {\n    /**\n     * @param {ReplayBuffer} replayBuffer - Replay buffer instance\n     * @param {SessionManager} sessionManager - Session manager instance\n     * @param {Object} config - Configuration options\n     */\n    constructor(replayBuffer, sessionManager, config) {\n        this.replayBuffer = replayBuffer;\n        this.sessionManager = sessionManager;\n        this.config = config;\n        this.isInstalled = false;\n\n        // Initialize DOM serializer with configurable throttling\n        const throttleMs = Math.max(config.snapshotThrottleMs || 1000, 500); // Min 500ms\n        this.domSerializer = new ThrottledDOMSerializer({\n            maxDepth: 10,           // Limit tree depth\n            minSize: 5,             // Skip tiny elements\n            skipInvisible: true,    // Skip hidden elements\n            captureColors: true,    // Capture background colors\n            throttleMs,             // Configurable throttle\n            maxSize: config.maxSnapshotSize || 1048576, // Default 1MB\n            debug: config.debug || false,\n        });\n\n        // Track DOM capture stats\n        this.domCaptureStats = {\n            total: 0,\n            throttled: 0,\n            captured: 0,\n            errors: 0,\n        };\n\n        // Click debouncing to prevent localStorage spam\n        this.lastClickTime = 0;\n        this.clickDebounceMs = Math.max(config.clickDebounceMs || 1000, 100); // Min 100ms\n        this.debounceStats = {\n            totalClicks: 0,\n            debouncedClicks: 0,\n        };\n    }\n\n    /**\n     * Install click tracking listeners\n     */\n    install() {\n        if (this.isInstalled) {\n            return;\n        }\n\n        try {\n            // Track clicks\n            document.addEventListener('click', (event) => {\n                this.captureClick(event);\n            }, true);\n\n            this.isInstalled = true;\n\n            if (this.config.debug) {\n                console.warn('ClickTracker: Installed (buffer-based recording)');\n            }\n        } catch (error) {\n            console.error('ClickTracker: Failed to install', error);\n        }\n    }\n\n    /**\n     * Capture click event with DOM snapshot\n     *\n     * Events are buffered (not sent immediately) and only transmitted\n     * when an error is detected via ErrorDetector.\n     *\n     * Includes debouncing to prevent localStorage spam from rapid clicking.\n     */\n    captureClick(event) {\n        try {\n            // Debounce: Ignore clicks that are too close together\n            const now = Date.now();\n            this.debounceStats.totalClicks++;\n\n            if (now - this.lastClickTime < this.clickDebounceMs) {\n                this.debounceStats.debouncedClicks++;\n                if (this.config.debug) {\n                    console.warn('ClickTracker: Click debounced', {\n                        timeSinceLastClick: now - this.lastClickTime,\n                        debounceThreshold: this.clickDebounceMs,\n                    });\n                }\n                return; // Skip this click\n            }\n\n            this.lastClickTime = now;\n\n            // Create click event data\n            const clickEvent = {\n                type: 'click',\n                url: window.location.href,\n                timestamp: Date.now(),\n                clickData: {\n                    x: event.pageX,\n                    y: event.pageY,\n                    viewportWidth: window.innerWidth,\n                    viewportHeight: window.innerHeight,\n                    elementSelector: this.generateSelector(event.target),\n                },\n                sessionId: this.sessionManager.getSessionId(),\n            };\n\n            // Capture DOM snapshot (throttled based on config)\n            this.domCaptureStats.total++;\n            try {\n                const domSnapshot = this.domSerializer.serialize();\n\n                if (domSnapshot) {\n                    // Snapshot captured successfully\n                    clickEvent.domSnapshot = domSnapshot;\n                    this.domCaptureStats.captured++;\n\n                    if (this.config.debug) {\n                        const size = this.domSerializer.serializer.estimateSize(domSnapshot);\n                        console.warn('ClickTracker: DOM snapshot captured', {\n                            elements: domSnapshot.stats?.totalElements || 0,\n                            sizeBytes: size,\n                            sizeKB: (size / 1024).toFixed(2),\n                        });\n                    }\n                } else {\n                    // Snapshot throttled\n                    this.domCaptureStats.throttled++;\n\n                    if (this.config.debug) {\n                        console.warn('ClickTracker: DOM snapshot throttled');\n                    }\n                }\n            } catch (domError) {\n                // DOM serialization failed - don't block the click capture\n                this.domCaptureStats.errors++;\n                if (this.config.debug) {\n                    console.error('ClickTracker: DOM serialization failed', domError);\n                }\n                // Continue without DOM snapshot\n            }\n\n            // Add event to replay buffer (not sent immediately)\n            const added = this.replayBuffer.addEvent(clickEvent);\n\n            if (!added && this.config.debug) {\n                console.warn('ClickTracker: Failed to add click to buffer');\n            }\n        } catch (error) {\n            // Never crash on tracking\n            console.error('ClickTracker: Failed to capture click', error);\n        }\n    }\n\n    /**\n     * Generate CSS selector for element\n     *\n     * Creates a unique but privacy-respecting selector:\n     * - Uses tag name, ID, classes\n     * - Limits depth to 5 levels\n     * - Removes sensitive attributes (data-*, ng-*, etc.)\n     */\n    generateSelector(element) {\n        if (!element || element === document) {\n            return '';\n        }\n\n        try {\n            const parts = [];\n            let current = element;\n            let depth = 0;\n            const maxDepth = 5;\n\n            while (current && current !== document && depth < maxDepth) {\n                let selector = current.tagName.toLowerCase();\n\n                // Add ID if available (most specific)\n                if (current.id && !this.containsSensitiveData(current.id)) {\n                    selector += `#${CSS.escape(current.id)}`;\n                    parts.unshift(selector);\n                    break; // ID is unique, stop here\n                }\n\n                // Add classes (filter out utility/dynamic classes)\n                const classes = this.getCleanClasses(current);\n                if (classes.length > 0) {\n                    selector += `.${classes.join('.')}`;\n                }\n\n                // Add nth-child if needed for uniqueness\n                const siblings = current.parentElement ?\n                    Array.from(current.parentElement.children).filter(\n                        child => child.tagName === current.tagName,\n                    ) : [];\n\n                if (siblings.length > 1) {\n                    const index = siblings.indexOf(current) + 1;\n                    selector += `:nth-child(${index})`;\n                }\n\n                parts.unshift(selector);\n                current = current.parentElement;\n                depth++;\n            }\n\n            return parts.join(' > ');\n        } catch {\n            // If selector generation fails, return basic info\n            return element.tagName ? element.tagName.toLowerCase() : 'unknown';\n        }\n    }\n\n    /**\n     * Get cleaned class list (remove utility and sensitive classes)\n     */\n    getCleanClasses(element) {\n        if (!element.classList || element.classList.length === 0) {\n            return [];\n        }\n\n        const classes = Array.from(element.classList);\n        return classes\n            .filter(cls => {\n                // Filter out utility classes (Tailwind, Bootstrap, etc.)\n                if (cls.match(/^(active|hover|focus|disabled|hidden|show)$/)) {\n                    return false;\n                }\n\n                // Filter out generated classes\n                if (cls.match(/^(ng-|v-|data-|_)/)) {\n                    return false;\n                }\n\n                // Filter out classes that look like they contain sensitive data\n                if (this.containsSensitiveData(cls)) {\n                    return false;\n                }\n\n                return true;\n            })\n            .map(cls => CSS.escape(cls))\n            .slice(0, 3); // Limit to 3 classes\n    }\n\n    /**\n     * Check if string contains potentially sensitive data\n     */\n    containsSensitiveData(str) {\n        const sensitivePatterns = [\n            /user[-_]?id/i,\n            /email/i,\n            /token/i,\n            /session/i,\n            /auth/i,\n            /key/i,\n            /\\d{10,}/,  // Long numbers (could be IDs)\n        ];\n\n        return sensitivePatterns.some(pattern => pattern.test(str));\n    }\n\n\n    /**\n     * Get DOM capture statistics for monitoring\n     *\n     * @returns {Object} Statistics about DOM snapshot captures\n     */\n    getDOMCaptureStats() {\n        return {\n            ...this.domCaptureStats,\n            serializerStats: this.domSerializer.getStats(),\n        };\n    }\n\n    /**\n     * Get click debounce statistics\n     *\n     * @returns {Object} Statistics about debounced clicks\n     */\n    getDebounceStats() {\n        return {\n            ...this.debounceStats,\n            debounceRate: this.debounceStats.totalClicks > 0\n                ? (this.debounceStats.debouncedClicks / this.debounceStats.totalClicks * 100).toFixed(2) + '%'\n                : '0%',\n            clickDebounceMs: this.clickDebounceMs,\n        };\n    }\n\n    /**\n     * Clean up resources\n     */\n    cleanup() {\n        try {\n            // Clear DOM serializer throttle timer\n            if (this.domSerializer && this.domSerializer.clearThrottle) {\n                this.domSerializer.clearThrottle();\n            }\n\n            if (this.config.debug) {\n                console.warn('ClickTracker: Cleanup complete');\n            }\n        } catch (error) {\n            console.error('ClickTracker: Cleanup failed', error);\n        }\n    }\n}\n","/**\n * Replay Buffer - Circular Buffer for Session Replay Data\n *\n * Implements a circular buffer that stores clicks and DOM snapshots\n * before an error occurs. Only sends data when an error is detected.\n *\n * Features:\n * - Time-based buffering (e.g., last 30 seconds)\n * - Click-based buffering (e.g., last 10 clicks)\n * - Memory-efficient circular buffer (FIFO)\n * - Configurable hard caps\n * - Serialization for localStorage\n * - Automatic pruning of old data\n */\nexport class ReplayBuffer {\n    /**\n     * @param {Object} config Configuration options\n     * @param {number} [config.bufferBeforeErrorSeconds=30] - Seconds of activity before error\n     * @param {number} [config.bufferBeforeErrorClicks=10] - Number of clicks before error\n     * @param {number} [config.bufferAfterErrorSeconds=30] - Seconds to continue after error\n     * @param {number} [config.bufferAfterErrorClicks=10] - Clicks to continue after error\n     * @param {number} [config.maxBufferSizeMB=5] - Maximum localStorage buffer size\n     * @param {boolean} [config.debug=false] - Enable debug logging\n     */\n    constructor(config = {}) {\n        // Configuration with hard caps enforced\n        this.config = {\n            bufferBeforeErrorSeconds: Math.min(config.bufferBeforeErrorSeconds || 30, 60),\n            bufferBeforeErrorClicks: Math.min(config.bufferBeforeErrorClicks || 10, 15),\n            bufferAfterErrorSeconds: Math.min(config.bufferAfterErrorSeconds || 30, 60),\n            bufferAfterErrorClicks: Math.min(config.bufferAfterErrorClicks || 10, 15),\n            maxBufferSizeMB: Math.min(config.maxBufferSizeMB || 5, 20),\n            debug: config.debug || false,\n        };\n\n        // Buffer state\n        this.buffer = []; // Circular buffer of events\n        this.isRecordingAfterError = false;\n        this.recordingStartedAt = null;\n        this.errorOccurredAt = null;\n        this.postErrorEventCount = 0;\n\n        // Statistics\n        this.stats = {\n            totalEvents: 0,\n            eventsDropped: 0,\n            bufferFullCount: 0,\n            currentBufferSize: 0,\n        };\n\n        if (this.config.debug) {\n            console.warn('ReplayBuffer initialized with config:', this.config);\n        }\n    }\n\n    /**\n     * Add an event to the buffer\n     *\n     * @param {Object} event - Event data (click, page transition, etc.)\n     * @param {string} event.type - Event type (click, pageTransition)\n     * @param {string} event.url - Current URL\n     * @param {number} event.timestamp - Event timestamp (milliseconds)\n     * @param {Object} [event.clickData] - Click-specific data\n     * @param {Object} [event.domSnapshot] - DOM snapshot (optional)\n     * @returns {boolean} True if event was added, false if dropped\n     */\n    addEvent(event) {\n        try {\n            if (!event || !event.timestamp) {\n                console.warn('ReplayBuffer: Invalid event (missing timestamp)');\n                return false;\n            }\n\n            // Mark event phase (before_error, error, or after_error)\n            event.phase = this.isRecordingAfterError ? 'after_error' : 'before_error';\n            event.capturedAt = Date.now();\n\n            // Add to buffer\n            this.buffer.push(event);\n            this.stats.totalEvents++;\n\n            // If recording after error, track count\n            if (this.isRecordingAfterError) {\n                this.postErrorEventCount++;\n\n                // Check if we should stop recording\n                if (this.shouldStopRecording()) {\n                    this.stopRecording();\n                }\n            } else {\n                // Prune old events from buffer (before error)\n                this.pruneOldEvents();\n            }\n\n            // Update stats\n            this.updateStats();\n\n            return true;\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to add event:', error);\n            this.stats.eventsDropped++;\n            return false;\n        }\n    }\n\n    /**\n     * Mark the start of error-triggered recording\n     *\n     * Call this when an error is detected. It will:\n     * 1. Mark the buffer as \"recording after error\"\n     * 2. Reset post-error counters\n     * 3. Prepare to stop after configured buffer is filled\n     *\n     * @param {Object} errorContext - Error context information\n     * @param {string} errorContext.errorId - Error ID from backend\n     * @param {string} errorContext.message - Error message\n     * @param {number} errorContext.timestamp - Error timestamp\n     */\n    startRecordingAfterError(errorContext) {\n        try {\n            this.errorOccurredAt = errorContext.timestamp || Date.now();\n            this.postErrorEventCount = 0;\n\n            // Add error marker event to buffer (manually, before setting isRecordingAfterError)\n            // This ensures the error marker itself is not counted in postErrorEventCount\n            this.buffer.push({\n                type: 'error',\n                phase: 'error',\n                timestamp: this.errorOccurredAt,\n                capturedAt: Date.now(),\n                url: window.location.href,\n                errorContext,\n            });\n            this.stats.totalEvents++;\n\n            // Now mark as recording after error (subsequent events will be counted)\n            this.isRecordingAfterError = true;\n\n            if (this.config.debug) {\n                console.warn('ReplayBuffer: Started recording after error', {\n                    errorId: errorContext.errorId,\n                    bufferSize: this.buffer.length,\n                    willRecordFor: `${this.config.bufferAfterErrorSeconds}s or ${this.config.bufferAfterErrorClicks} clicks`,\n                });\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to start post-error recording:', error);\n        }\n    }\n\n    /**\n     * Stop recording after error buffer is full\n     */\n    stopRecording() {\n        try {\n            if (!this.isRecordingAfterError) {\n                return;\n            }\n\n            this.isRecordingAfterError = false;\n\n            if (this.config.debug) {\n                console.warn('ReplayBuffer: Stopped recording after error', {\n                    totalEvents: this.buffer.length,\n                    postErrorEvents: this.postErrorEventCount,\n                });\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to stop recording:', error);\n        }\n    }\n\n    /**\n     * Check if we should stop recording after error\n     *\n     * Stops when either condition is met:\n     * - Time limit reached (bufferAfterErrorSeconds)\n     * - Click limit reached (bufferAfterErrorClicks)\n     *\n     * @returns {boolean}\n     */\n    shouldStopRecording() {\n        if (!this.isRecordingAfterError || !this.errorOccurredAt) {\n            return false;\n        }\n\n        const now = Date.now();\n        const elapsedSeconds = (now - this.errorOccurredAt) / 1000;\n\n        // Check time limit\n        if (elapsedSeconds >= this.config.bufferAfterErrorSeconds) {\n            if (this.config.debug) {\n                console.warn(`ReplayBuffer: Time limit reached (${elapsedSeconds.toFixed(1)}s)`);\n            }\n            return true;\n        }\n\n        // Check click limit\n        if (this.postErrorEventCount >= this.config.bufferAfterErrorClicks) {\n            if (this.config.debug) {\n                console.warn(`ReplayBuffer: Click limit reached (${this.postErrorEventCount} clicks)`);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Prune old events from buffer (keep only recent N seconds/clicks)\n     */\n    pruneOldEvents() {\n        try {\n            const now = Date.now();\n            const cutoffTime = now - (this.config.bufferBeforeErrorSeconds * 1000);\n\n            // Filter events: keep events within time window\n            const timeFiltered = this.buffer.filter(event =>\n                event.capturedAt >= cutoffTime || event.phase === 'error',\n            );\n\n            // Also enforce click limit: keep last N clicks\n            const clickEvents = timeFiltered.filter(e => e.type === 'click');\n            const otherEvents = timeFiltered.filter(e => e.type !== 'click');\n\n            // Keep last N clicks + all other events (page transitions, errors)\n            const recentClicks = clickEvents.slice(-this.config.bufferBeforeErrorClicks);\n\n            this.buffer = [...otherEvents, ...recentClicks]\n                .sort((a, b) => a.capturedAt - b.capturedAt);\n\n            // Update stats if buffer was pruned\n            if (this.buffer.length < timeFiltered.length) {\n                const dropped = timeFiltered.length - this.buffer.length;\n                this.stats.eventsDropped += dropped;\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to prune old events:', error);\n        }\n    }\n\n    /**\n     * Get all events in the buffer\n     *\n     * @returns {Array<Object>} Array of events\n     */\n    getEvents() {\n        return [...this.buffer]; // Return copy\n    }\n\n    /**\n     * Get events by phase\n     *\n     * @param {string} phase - Phase to filter by (before_error, error, after_error)\n     * @returns {Array<Object>}\n     */\n    getEventsByPhase(phase) {\n        return this.buffer.filter(event => event.phase === phase);\n    }\n\n    /**\n     * Clear the buffer\n     */\n    clear() {\n        try {\n            this.buffer = [];\n            this.isRecordingAfterError = false;\n            this.recordingStartedAt = null;\n            this.errorOccurredAt = null;\n            this.postErrorEventCount = 0;\n\n            if (this.config.debug) {\n                console.warn('ReplayBuffer: Cleared');\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to clear buffer:', error);\n        }\n    }\n\n    /**\n     * Check if buffer is currently recording after an error\n     *\n     * @returns {boolean}\n     */\n    isRecording() {\n        return this.isRecordingAfterError;\n    }\n\n    /**\n     * Get buffer statistics\n     *\n     * @returns {Object} Statistics\n     */\n    getStats() {\n        return {\n            ...this.stats,\n            bufferLength: this.buffer.length,\n            isRecording: this.isRecordingAfterError,\n            postErrorEventCount: this.postErrorEventCount,\n        };\n    }\n\n    /**\n     * Update buffer statistics\n     */\n    updateStats() {\n        try {\n            // Calculate approximate buffer size\n            const approximateSize = this.estimateBufferSize();\n            this.stats.currentBufferSize = approximateSize;\n\n            // Check if buffer is getting too large\n            const maxSizeBytes = this.config.maxBufferSizeMB * 1024 * 1024;\n            if (approximateSize > maxSizeBytes) {\n                this.stats.bufferFullCount++;\n                // Aggressive pruning\n                this.buffer = this.buffer.slice(-Math.floor(this.buffer.length / 2));\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to update stats:', error);\n        }\n    }\n\n    /**\n     * Estimate buffer size in bytes\n     *\n     * @returns {number} Approximate size in bytes\n     */\n    estimateBufferSize() {\n        try {\n            const json = JSON.stringify(this.buffer);\n            return json.length;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Serialize buffer for storage\n     *\n     * @returns {Object} Serialized data\n     */\n    serialize() {\n        return {\n            buffer: this.buffer,\n            isRecordingAfterError: this.isRecordingAfterError,\n            errorOccurredAt: this.errorOccurredAt,\n            postErrorEventCount: this.postErrorEventCount,\n            stats: this.stats,\n        };\n    }\n\n    /**\n     * Deserialize buffer from storage\n     *\n     * @param {Object} data - Serialized data\n     * @returns {boolean} Success\n     */\n    deserialize(data) {\n        try {\n            if (!data || typeof data !== 'object') {\n                return false;\n            }\n\n            this.buffer = Array.isArray(data.buffer) ? data.buffer : [];\n            this.isRecordingAfterError = !!data.isRecordingAfterError;\n            this.errorOccurredAt = data.errorOccurredAt || null;\n            this.postErrorEventCount = data.postErrorEventCount || 0;\n\n            if (data.stats && typeof data.stats === 'object') {\n                this.stats = { ...this.stats, ...data.stats };\n            }\n\n            if (this.config.debug) {\n                console.warn('ReplayBuffer: Deserialized', {\n                    events: this.buffer.length,\n                    isRecording: this.isRecordingAfterError,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to deserialize:', error);\n            return false;\n        }\n    }\n}\n","/**\n * Error Detector - Triggers Session Replay on Errors\n *\n * Hooks into global error handlers and triggers replay buffer capture\n * when errors are detected. Coordinates with ReplayBuffer to send\n * buffered events along with error context.\n *\n * Features:\n * - Hooks window.onerror and unhandledrejection\n * - Triggers replay capture on error\n * - Links replay data to error ID\n * - Prevents duplicate captures\n * - Configurable error filtering\n */\nexport class ErrorDetector {\n    /**\n     * @param {ReplayBuffer} replayBuffer - Replay buffer instance\n     * @param {SessionManager} sessionManager - Session manager instance\n     * @param {Function} onErrorDetected - Callback when error detected (receives errorContext)\n     * @param {Object} [config] - Configuration options\n     * @param {boolean} [config.debug=false] - Enable debug logging\n     * @param {Array<string>} [config.ignoreErrors=[]] - Error messages to ignore\n     */\n    constructor(replayBuffer, sessionManager, onErrorDetected, config = {}) {\n        this.replayBuffer = replayBuffer;\n        this.sessionManager = sessionManager;\n        this.onErrorDetected = onErrorDetected;\n        this.config = {\n            debug: config.debug || false,\n            ignoreErrors: config.ignoreErrors || [],\n        };\n\n        // State\n        this.isInstalled = false;\n        this.recentErrors = new Set(); // Prevent duplicate captures\n        this.recentErrorsCleanupInterval = null;\n\n        // Statistics\n        this.stats = {\n            errorsDetected: 0,\n            errorsIgnored: 0,\n            replaysCaptured: 0,\n            duplicatesPrevented: 0,\n        };\n\n        if (this.config.debug) {\n            console.warn('ErrorDetector initialized');\n        }\n    }\n\n    /**\n     * Install error detection handlers\n     */\n    install() {\n        if (this.isInstalled) {\n            console.warn('ErrorDetector: Already installed');\n            return;\n        }\n\n        try {\n            // Note: We intentionally do NOT add new handlers here\n            // The Client class already handles window.onerror and unhandledrejection\n            // This detector will be called FROM the Client class when errors occur\n            // This design prevents double-handling of errors\n\n            // Set up cleanup for recent errors (prevent duplicates)\n            this.recentErrorsCleanupInterval = setInterval(() => {\n                this.recentErrors.clear();\n            }, 60000); // Clear every 60 seconds\n\n            this.isInstalled = true;\n\n            if (this.config.debug) {\n                console.warn('ErrorDetector: Installed');\n            }\n        } catch (error) {\n            console.error('ErrorDetector: Failed to install:', error);\n        }\n    }\n\n    /**\n     * Uninstall error detection handlers\n     */\n    uninstall() {\n        try {\n            if (this.recentErrorsCleanupInterval) {\n                clearInterval(this.recentErrorsCleanupInterval);\n                this.recentErrorsCleanupInterval = null;\n            }\n\n            this.isInstalled = false;\n\n            if (this.config.debug) {\n                console.warn('ErrorDetector: Uninstalled');\n            }\n        } catch (error) {\n            console.error('ErrorDetector: Failed to uninstall:', error);\n        }\n    }\n\n    /**\n     * Handle detected error (called by Client)\n     *\n     * This is the main entry point called by the Client class when an error occurs.\n     *\n     * @param {Error} error - The error object\n     * @param {Object} errorPayload - The error payload being sent to backend\n     * @returns {Promise<Object|null>} Error context with replay data, or null\n     */\n    async handleError(error, errorPayload) {\n        try {\n            this.stats.errorsDetected++;\n\n            // Check if error should be ignored\n            if (this.shouldIgnoreError(error)) {\n                this.stats.errorsIgnored++;\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: Error ignored:', error.message);\n                }\n                return null;\n            }\n\n            // Generate error fingerprint for deduplication\n            const errorFingerprint = this.generateErrorFingerprint(error);\n\n            // Check if we recently captured this error\n            if (this.recentErrors.has(errorFingerprint)) {\n                this.stats.duplicatesPrevented++;\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: Duplicate error prevented');\n                }\n                return null;\n            }\n\n            // Mark error as recently seen\n            this.recentErrors.add(errorFingerprint);\n\n            // Create error context\n            const errorContext = {\n                errorId: null, // Will be set by backend response\n                message: error.message || 'Unknown error',\n                type: error.name || 'Error',\n                timestamp: Date.now(),\n                stack: error.stack || '',\n                url: window.location.href,\n            };\n\n            // Start recording after error (continue for N seconds/clicks)\n            this.replayBuffer.startRecordingAfterError(errorContext);\n\n            // Get buffered events\n            const events = this.replayBuffer.getEvents();\n\n            if (this.config.debug) {\n                console.warn('ErrorDetector: Replay captured', {\n                    errorMessage: errorContext.message,\n                    eventCount: events.length,\n                    beforeError: this.replayBuffer.getEventsByPhase('before_error').length,\n                    afterError: this.replayBuffer.getEventsByPhase('after_error').length,\n                });\n            }\n\n            this.stats.replaysCaptured++;\n\n            // Call the callback with error context and replay data\n            if (this.onErrorDetected) {\n                await this.onErrorDetected(errorContext, events, errorPayload);\n            }\n\n            return {\n                errorContext,\n                events,\n                sessionId: this.sessionManager.getSessionId(),\n                stats: this.replayBuffer.getStats(),\n            };\n        } catch (handlingError) {\n            console.error('ErrorDetector: Failed to handle error:', handlingError);\n            return null;\n        }\n    }\n\n    /**\n     * Check if error should be ignored\n     *\n     * @param {Error} error\n     * @returns {boolean}\n     */\n    shouldIgnoreError(error) {\n        try {\n            if (!error || !error.message) {\n                return false;\n            }\n\n            const message = error.message.toLowerCase();\n\n            // Check configured ignore patterns\n            for (const pattern of this.config.ignoreErrors) {\n                if (message.includes(pattern.toLowerCase())) {\n                    return true;\n                }\n            }\n\n            // Ignore common non-actionable errors\n            const commonIgnorePatterns = [\n                'script error', // Cross-origin script errors\n                'network error', // Network failures (not code bugs)\n                'loading chunk', // Webpack/bundler chunk loading issues\n                'dynamically imported module', // Dynamic import failures\n            ];\n\n            for (const pattern of commonIgnorePatterns) {\n                if (message.includes(pattern)) {\n                    return true;\n                }\n            }\n\n            return false;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Generate error fingerprint for deduplication\n     *\n     * @param {Error} error\n     * @returns {string}\n     */\n    generateErrorFingerprint(error) {\n        try {\n            const message = error.message || '';\n            const stack = error.stack || '';\n\n            // Extract first line of stack (most specific)\n            const stackFirstLine = stack.split('\\n')[1] || '';\n\n            // Combine message + first stack line for fingerprint\n            return `${message}:${stackFirstLine}`;\n        } catch {\n            return `${Date.now()}:${Math.random()}`;\n        }\n    }\n\n    /**\n     * Get error detection statistics\n     *\n     * @returns {Object}\n     */\n    getStats() {\n        return {\n            ...this.stats,\n            isInstalled: this.isInstalled,\n            recentErrorsCount: this.recentErrors.size,\n        };\n    }\n\n    /**\n     * Enable/disable error detection\n     *\n     * @param {boolean} enabled\n     */\n    setEnabled(enabled) {\n        if (enabled && !this.isInstalled) {\n            this.install();\n        } else if (!enabled && this.isInstalled) {\n            this.uninstall();\n        }\n    }\n\n    /**\n     * Check if error detection is enabled\n     *\n     * @returns {boolean}\n     */\n    isEnabled() {\n        return this.isInstalled;\n    }\n}\n","/**\n * Session Manager - Cross-Page Session Management\n *\n * Manages session ID persistence across page navigations using localStorage.\n * Tracks page transitions and session metadata for replay continuity.\n *\n * Features:\n * - Persistent session ID (UUID) in localStorage\n * - Cross-page session continuity\n * - Page transition tracking\n * - Session expiration (idle timeout)\n * - Session metadata (start time, page count)\n */\nexport class SessionManager {\n    /**\n     * @param {Object} [config] - Configuration options\n     * @param {number} [config.sessionTimeoutMinutes=30] - Session timeout in minutes\n     * @param {boolean} [config.debug=false] - Enable debug logging\n     */\n    constructor(config = {}) {\n        this.config = {\n            sessionTimeoutMinutes: Math.min(config.sessionTimeoutMinutes || 30, 120),\n            debug: config.debug || false,\n        };\n\n        // localStorage keys\n        this.STORAGE_KEY_SESSION_ID = '_app_logger_session_id';\n        this.STORAGE_KEY_SESSION_METADATA = '_app_logger_session_metadata';\n\n        // Session state\n        this.sessionId = null;\n        this.metadata = {\n            startedAt: null,\n            lastActivityAt: null,\n            pageCount: 0,\n            pages: [],\n        };\n\n        // Initialize\n        this.initialize();\n\n        if (this.config.debug) {\n            console.warn('SessionManager initialized', {\n                sessionId: this.sessionId,\n                metadata: this.metadata,\n            });\n        }\n    }\n\n    /**\n     * Initialize session (load or create)\n     */\n    initialize() {\n        try {\n            // Try to load existing session\n            const loaded = this.loadSession();\n\n            if (!loaded || this.isSessionExpired()) {\n                // Create new session\n                this.createNewSession();\n            } else {\n                // Update last activity\n                this.updateActivity();\n            }\n\n            // Track current page\n            this.trackPageView(window.location.href);\n\n            // Set up page transition tracking\n            this.setupPageTransitionTracking();\n        } catch (error) {\n            console.error('SessionManager: Failed to initialize:', error);\n            // Fallback: create new session\n            this.createNewSession();\n        }\n    }\n\n    /**\n     * Create a new session\n     */\n    createNewSession() {\n        try {\n            this.sessionId = this.generateSessionId();\n            this.metadata = {\n                startedAt: Date.now(),\n                lastActivityAt: Date.now(),\n                pageCount: 0,\n                pages: [],\n            };\n\n            this.saveSession();\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Created new session', this.sessionId);\n            }\n        } catch (error) {\n            console.error('SessionManager: Failed to create new session:', error);\n        }\n    }\n\n    /**\n     * Load session from localStorage\n     *\n     * @returns {boolean} True if session loaded successfully\n     */\n    loadSession() {\n        try {\n            const sessionId = localStorage.getItem(this.STORAGE_KEY_SESSION_ID);\n            const metadataJson = localStorage.getItem(this.STORAGE_KEY_SESSION_METADATA);\n\n            if (!sessionId || !metadataJson) {\n                return false;\n            }\n\n            const metadata = JSON.parse(metadataJson);\n\n            if (!metadata || !metadata.startedAt) {\n                return false;\n            }\n\n            this.sessionId = sessionId;\n            this.metadata = metadata;\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Loaded session', {\n                    sessionId,\n                    age: this.getSessionAge(),\n                });\n            }\n\n            return true;\n        } catch (error) {\n            console.error('SessionManager: Failed to load session:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Save session to localStorage\n     */\n    saveSession() {\n        try {\n            localStorage.setItem(this.STORAGE_KEY_SESSION_ID, this.sessionId);\n            localStorage.setItem(\n                this.STORAGE_KEY_SESSION_METADATA,\n                JSON.stringify(this.metadata),\n            );\n        } catch (error) {\n            console.error('SessionManager: Failed to save session:', error);\n        }\n    }\n\n    /**\n     * Check if session is expired\n     *\n     * @returns {boolean}\n     */\n    isSessionExpired() {\n        try {\n            if (!this.metadata.lastActivityAt) {\n                return true;\n            }\n\n            const now = Date.now();\n            const lastActivity = this.metadata.lastActivityAt;\n            const timeoutMs = this.config.sessionTimeoutMinutes * 60 * 1000;\n\n            return (now - lastActivity) > timeoutMs;\n        } catch {\n            return true;\n        }\n    }\n\n    /**\n     * Update last activity timestamp\n     */\n    updateActivity() {\n        try {\n            this.metadata.lastActivityAt = Date.now();\n            this.saveSession();\n        } catch (error) {\n            console.error('SessionManager: Failed to update activity:', error);\n        }\n    }\n\n    /**\n     * Track page view\n     *\n     * @param {string} url - Page URL\n     * @returns {Object} Page transition event\n     */\n    trackPageView(url) {\n        try {\n            // Increment page count\n            this.metadata.pageCount++;\n\n            // Add to pages array (keep last 50)\n            this.metadata.pages.push({\n                url,\n                timestamp: Date.now(),\n            });\n\n            if (this.metadata.pages.length > 50) {\n                this.metadata.pages = this.metadata.pages.slice(-50);\n            }\n\n            // Update activity\n            this.updateActivity();\n\n            // Create page transition event\n            const pageEvent = {\n                type: 'pageTransition',\n                url,\n                timestamp: Date.now(),\n                phase: 'before_error',\n                sessionId: this.sessionId,\n                pageCount: this.metadata.pageCount,\n            };\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Page view tracked', {\n                    url,\n                    pageCount: this.metadata.pageCount,\n                });\n            }\n\n            return pageEvent;\n        } catch (error) {\n            console.error('SessionManager: Failed to track page view:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Set up page transition tracking\n     */\n    setupPageTransitionTracking() {\n        try {\n            // Track history API navigation (pushState, replaceState)\n            const originalPushState = history.pushState;\n            const originalReplaceState = history.replaceState;\n\n            history.pushState = (...args) => {\n                originalPushState.apply(history, args);\n                this.handleNavigationChange();\n            };\n\n            history.replaceState = (...args) => {\n                originalReplaceState.apply(history, args);\n                this.handleNavigationChange();\n            };\n\n            // Track popstate (back/forward buttons)\n            window.addEventListener('popstate', () => {\n                this.handleNavigationChange();\n            });\n\n            // Track hash changes\n            window.addEventListener('hashchange', () => {\n                this.handleNavigationChange();\n            });\n        } catch (error) {\n            console.error('SessionManager: Failed to setup page transition tracking:', error);\n        }\n    }\n\n    /**\n     * Handle navigation change (for SPA routing)\n     */\n    handleNavigationChange() {\n        try {\n            const url = window.location.href;\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Navigation detected', url);\n            }\n\n            // Track the navigation as a page transition\n            this.trackPageView(url);\n        } catch (error) {\n            console.error('SessionManager: Failed to handle navigation change:', error);\n        }\n    }\n\n    /**\n     * Get current session ID\n     *\n     * @returns {string}\n     */\n    getSessionId() {\n        return this.sessionId;\n    }\n\n    /**\n     * Get session metadata\n     *\n     * @returns {Object}\n     */\n    getMetadata() {\n        return { ...this.metadata };\n    }\n\n    /**\n     * Get session age in milliseconds\n     *\n     * @returns {number}\n     */\n    getSessionAge() {\n        if (!this.metadata.startedAt) {\n            return 0;\n        }\n\n        return Date.now() - this.metadata.startedAt;\n    }\n\n    /**\n     * Generate a new session ID (UUID v4)\n     *\n     * @returns {string}\n     */\n    generateSessionId() {\n        try {\n            // Use crypto.randomUUID if available (modern browsers)\n            if (crypto && crypto.randomUUID) {\n                return crypto.randomUUID();\n            }\n\n            // Fallback: Generate UUID v4 manually\n            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n                const r = Math.random() * 16 | 0;\n                const v = c === 'x' ? r : (r & 0x3 | 0x8);\n                return v.toString(16);\n            });\n        } catch {\n            // Last resort: timestamp + random\n            return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n        }\n    }\n\n    /**\n     * Clear session (force new session on next page load)\n     */\n    clearSession() {\n        try {\n            localStorage.removeItem(this.STORAGE_KEY_SESSION_ID);\n            localStorage.removeItem(this.STORAGE_KEY_SESSION_METADATA);\n\n            this.sessionId = null;\n            this.metadata = {\n                startedAt: null,\n                lastActivityAt: null,\n                pageCount: 0,\n                pages: [],\n            };\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Session cleared');\n            }\n        } catch (error) {\n            console.error('SessionManager: Failed to clear session:', error);\n        }\n    }\n\n    /**\n     * Extend session (reset idle timeout)\n     */\n    extendSession() {\n        try {\n            this.updateActivity();\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Session extended');\n            }\n        } catch (error) {\n            console.error('SessionManager: Failed to extend session:', error);\n        }\n    }\n\n    /**\n     * Get session info for debugging\n     *\n     * @returns {Object}\n     */\n    getSessionInfo() {\n        return {\n            sessionId: this.sessionId,\n            age: this.getSessionAge(),\n            ageMinutes: Math.floor(this.getSessionAge() / 1000 / 60),\n            isExpired: this.isSessionExpired(),\n            pageCount: this.metadata.pageCount,\n            recentPages: this.metadata.pages.slice(-5),\n            timeoutMinutes: this.config.sessionTimeoutMinutes,\n        };\n    }\n}\n","/**\n * Storage Manager - localStorage Management for Replay Buffer\n *\n * Manages localStorage for replay buffer persistence across pages.\n * Handles quota management, compression, and cleanup.\n *\n * Features:\n * - Save/load replay buffer to/from localStorage\n * - Quota management (prevents quota exceeded errors)\n * - Automatic cleanup of old sessions\n * - LRU eviction when quota is tight\n * - Size monitoring and reporting\n */\nexport class StorageManager {\n    /**\n     * @param {Object} [config] - Configuration options\n     * @param {number} [config.maxBufferSizeMB=5] - Maximum buffer size in MB\n     * @param {boolean} [config.debug=false] - Enable debug logging\n     */\n    constructor(config = {}) {\n        this.config = {\n            maxBufferSizeMB: Math.min(config.maxBufferSizeMB || 5, 20),\n            debug: config.debug || false,\n        };\n\n        // localStorage keys\n        this.STORAGE_KEY_BUFFER = '_app_logger_replay_buffer';\n        this.STORAGE_KEY_METADATA = '_app_logger_replay_metadata';\n\n        // Statistics\n        this.stats = {\n            savesSuccessful: 0,\n            savesFailed: 0,\n            loadsSuccessful: 0,\n            loadsFailed: 0,\n            quotaExceededCount: 0,\n            cleanupCount: 0,\n        };\n\n        if (this.config.debug) {\n            console.warn('StorageManager initialized with config:', this.config);\n        }\n    }\n\n    /**\n     * Save replay buffer to localStorage\n     *\n     * @param {Object} bufferData - Serialized buffer data from ReplayBuffer\n     * @returns {boolean} Success\n     */\n    save(bufferData) {\n        try {\n            if (!bufferData || typeof bufferData !== 'object') {\n                console.warn('StorageManager: Invalid buffer data');\n                return false;\n            }\n\n            // Check size before saving\n            const estimatedSize = this.estimateSize(bufferData);\n            const maxSizeBytes = this.config.maxBufferSizeMB * 1024 * 1024;\n\n            if (estimatedSize > maxSizeBytes) {\n                if (this.config.debug) {\n                    console.warn('StorageManager: Buffer too large', {\n                        size: estimatedSize,\n                        max: maxSizeBytes,\n                        sizeMB: (estimatedSize / 1024 / 1024).toFixed(2),\n                    });\n                }\n\n                // Try to make space\n                this.cleanup();\n\n                // If still too large, prune the buffer\n                if (estimatedSize > maxSizeBytes) {\n                    bufferData = this.pruneBuffer(bufferData, maxSizeBytes);\n                }\n            }\n\n            // Save to localStorage\n            localStorage.setItem(this.STORAGE_KEY_BUFFER, JSON.stringify(bufferData));\n\n            // Save metadata\n            this.saveMetadata({\n                savedAt: Date.now(),\n                size: estimatedSize,\n            });\n\n            this.stats.savesSuccessful++;\n\n            if (this.config.debug) {\n                console.warn('StorageManager: Buffer saved', {\n                    size: estimatedSize,\n                    events: bufferData.buffer?.length || 0,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            this.stats.savesFailed++;\n\n            if (error.name === 'QuotaExceededError') {\n                this.stats.quotaExceededCount++;\n\n                if (this.config.debug) {\n                    console.warn('StorageManager: Quota exceeded, attempting cleanup');\n                }\n\n                // Try to make space and retry\n                this.cleanup();\n\n                try {\n                    // Retry with pruned buffer\n                    const prunedBuffer = this.pruneBuffer(\n                        bufferData,\n                        this.config.maxBufferSizeMB * 1024 * 1024 / 2, // Use half max size\n                    );\n\n                    localStorage.setItem(\n                        this.STORAGE_KEY_BUFFER,\n                        JSON.stringify(prunedBuffer),\n                    );\n\n                    this.stats.savesSuccessful++;\n                    return true;\n                } catch {\n                    console.error('StorageManager: Failed to save even after cleanup');\n                    return false;\n                }\n            }\n\n            console.error('StorageManager: Failed to save buffer:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Load replay buffer from localStorage\n     *\n     * @returns {Object|null} Buffer data or null if not found/invalid\n     */\n    load() {\n        try {\n            const stored = localStorage.getItem(this.STORAGE_KEY_BUFFER);\n\n            if (!stored) {\n                return null;\n            }\n\n            const bufferData = JSON.parse(stored);\n\n            if (!bufferData || typeof bufferData !== 'object') {\n                return null;\n            }\n\n            // Validate buffer structure\n            if (!Array.isArray(bufferData.buffer)) {\n                console.warn('StorageManager: Invalid buffer structure');\n                return null;\n            }\n\n            this.stats.loadsSuccessful++;\n\n            if (this.config.debug) {\n                console.warn('StorageManager: Buffer loaded', {\n                    events: bufferData.buffer.length,\n                    isRecording: bufferData.isRecordingAfterError,\n                });\n            }\n\n            return bufferData;\n        } catch (error) {\n            this.stats.loadsFailed++;\n            console.error('StorageManager: Failed to load buffer:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Clear replay buffer from localStorage\n     */\n    clear() {\n        try {\n            localStorage.removeItem(this.STORAGE_KEY_BUFFER);\n            localStorage.removeItem(this.STORAGE_KEY_METADATA);\n\n            if (this.config.debug) {\n                console.warn('StorageManager: Buffer cleared');\n            }\n        } catch (error) {\n            console.error('StorageManager: Failed to clear buffer:', error);\n        }\n    }\n\n    /**\n     * Clean up old/expired data\n     */\n    cleanup() {\n        try {\n            // Remove old buffer if it exists\n            const metadata = this.loadMetadata();\n\n            if (metadata && metadata.savedAt) {\n                const age = Date.now() - metadata.savedAt;\n                const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n\n                if (age > maxAge) {\n                    this.clear();\n                    this.stats.cleanupCount++;\n\n                    if (this.config.debug) {\n                        console.warn('StorageManager: Cleaned up old buffer', {\n                            ageHours: (age / 1000 / 60 / 60).toFixed(1),\n                        });\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('StorageManager: Cleanup failed:', error);\n        }\n    }\n\n    /**\n     * Save metadata\n     *\n     * @param {Object} metadata\n     */\n    saveMetadata(metadata) {\n        try {\n            localStorage.setItem(\n                this.STORAGE_KEY_METADATA,\n                JSON.stringify(metadata),\n            );\n        } catch (error) {\n            // Metadata save failure is not critical\n            if (this.config.debug) {\n                console.warn('StorageManager: Failed to save metadata:', error);\n            }\n        }\n    }\n\n    /**\n     * Load metadata\n     *\n     * @returns {Object|null}\n     */\n    loadMetadata() {\n        try {\n            const stored = localStorage.getItem(this.STORAGE_KEY_METADATA);\n\n            if (!stored) {\n                return null;\n            }\n\n            return JSON.parse(stored);\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Prune buffer to fit within size limit\n     *\n     * @param {Object} bufferData\n     * @param {number} maxSizeBytes\n     * @returns {Object} Pruned buffer\n     */\n    pruneBuffer(bufferData, maxSizeBytes) {\n        try {\n            if (!bufferData.buffer || !Array.isArray(bufferData.buffer)) {\n                return bufferData;\n            }\n\n            // Start by keeping all events\n            const pruned = { ...bufferData };\n            const events = [...bufferData.buffer];\n\n            // Remove oldest events until we fit\n            while (this.estimateSize(pruned) > maxSizeBytes && events.length > 1) {\n                // Remove oldest event (but keep error marker)\n                const removed = events.shift();\n\n                // If we removed an error marker, put it back\n                if (removed && removed.phase === 'error') {\n                    events.unshift(removed);\n                    break;\n                }\n\n                pruned.buffer = events;\n            }\n\n            if (this.config.debug) {\n                console.warn('StorageManager: Buffer pruned', {\n                    originalEvents: bufferData.buffer.length,\n                    prunedEvents: events.length,\n                    originalSize: this.estimateSize(bufferData),\n                    prunedSize: this.estimateSize(pruned),\n                });\n            }\n\n            return pruned;\n        } catch (error) {\n            console.error('StorageManager: Failed to prune buffer:', error);\n            return bufferData;\n        }\n    }\n\n    /**\n     * Estimate size of data in bytes\n     *\n     * @param {Object} data\n     * @returns {number} Size in bytes\n     */\n    estimateSize(data) {\n        try {\n            const json = JSON.stringify(data);\n            return json.length;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Get available localStorage space (approximate)\n     *\n     * @returns {Object} Space info\n     */\n    getSpaceInfo() {\n        try {\n            const testKey = '_app_logger_space_test';\n            const testData = '0'.repeat(1024); // 1KB test string\n\n            let available = 0;\n            let used = 0;\n\n            // Estimate used space\n            for (const key in localStorage) {\n                if (Object.prototype.hasOwnProperty.call(localStorage, key)) {\n                    used += localStorage[key].length + key.length;\n                }\n            }\n\n            // Estimate available space (crude test)\n            try {\n                for (let i = 0; i < 10000; i++) {\n                    localStorage.setItem(testKey, testData.repeat(i));\n                    available = i * 1024;\n                }\n            } catch {\n                // Quota exceeded - we found the limit\n            } finally {\n                localStorage.removeItem(testKey);\n            }\n\n            return {\n                usedBytes: used,\n                usedMB: (used / 1024 / 1024).toFixed(2),\n                availableMB: (available / 1024 / 1024).toFixed(2),\n                totalMB: ((used + available) / 1024 / 1024).toFixed(2),\n            };\n        } catch {\n            return {\n                usedBytes: 0,\n                usedMB: 'unknown',\n                availableMB: 'unknown',\n                totalMB: 'unknown',\n            };\n        }\n    }\n\n    /**\n     * Get storage statistics\n     *\n     * @returns {Object}\n     */\n    getStats() {\n        const spaceInfo = this.getSpaceInfo();\n\n        return {\n            ...this.stats,\n            ...spaceInfo,\n            maxBufferSizeMB: this.config.maxBufferSizeMB,\n        };\n    }\n\n    /**\n     * Check if localStorage is available\n     *\n     * @returns {boolean}\n     */\n    isAvailable() {\n        try {\n            const testKey = '_app_logger_test';\n            localStorage.setItem(testKey, 'test');\n            localStorage.removeItem(testKey);\n            return true;\n        } catch {\n            return false;\n        }\n    }\n}\n","/**\n * Application Logger JavaScript SDK\n *\n * ERROR-TRIGGERED SESSION REPLAY:\n * - Only captures replay when errors occur (not continuously)\n * - Buffers N seconds/clicks before and after error\n * - Cross-page session continuity via localStorage\n * - Privacy-first (no PII in DOM snapshots)\n *\n * FEATURES:\n * - JavaScript error capture and reporting\n * - Session replay on error (configurable buffer size)\n * - Breadcrumb tracking for debugging context\n * - Click heatmap for user behavior analysis\n *\n * @module ApplicationLogger\n */\n\nimport { Client } from './client.js';\nimport { BreadcrumbCollector } from './breadcrumbs.js';\nimport { Transport } from './transport.js';\nimport { ClickTracker } from './click-tracker.js';\nimport { ReplayBuffer } from './replay-buffer.js';\nimport { ErrorDetector } from './error-detector.js';\nimport { SessionManager } from './session-manager.js';\nimport { StorageManager } from './storage-manager.js';\n\n/**\n * Main ApplicationLogger class\n */\nclass ApplicationLogger {\n    /**\n     * @param {Object} config Configuration options\n     * @param {string} config.dsn Data Source Name (project endpoint URL)\n     * @param {string} config.apiKey API Key for authentication\n     * @param {string} [config.release] Application version/release\n     * @param {string} [config.environment] Environment (production, staging, etc.)\n     * @param {boolean} [config.debug=false] Enable debug logging\n     * @param {string[]} [config.scrubFields] Additional fields to scrub\n     *\n     * Session Replay Configuration (error-triggered only):\n     * @param {boolean} [config.sessionReplayEnabled=true] Enable session replay on errors\n     * @param {number} [config.bufferBeforeErrorSeconds=30] Seconds to buffer before error (max 60)\n     * @param {number} [config.bufferBeforeErrorClicks=10] Clicks to buffer before error (max 15)\n     * @param {number} [config.bufferAfterErrorSeconds=30] Seconds to buffer after error (max 60)\n     * @param {number} [config.bufferAfterErrorClicks=10] Clicks to buffer after error (max 15)\n     * @param {number} [config.snapshotThrottleMs=1000] DOM snapshot throttle (min 500ms)\n     * @param {number} [config.maxSnapshotSize=1048576] Max snapshot size (default 1MB)\n     * @param {number} [config.sessionTimeoutMinutes=30] Session timeout (max 120 min)\n     * @param {number} [config.maxBufferSizeMB=5] Max localStorage buffer size (max 20MB)\n     * @param {boolean} [config.exposeApi=true] Expose control API for developers\n     */\n    constructor(config) {\n        // Validate required configuration\n        if (!config || !config.dsn) {\n            throw new Error('ApplicationLogger: DSN is required. Expected format: https://host/project-id');\n        }\n\n        if (!config.apiKey) {\n            throw new Error('ApplicationLogger: API Key is required for authentication');\n        }\n\n        this.config = {\n            // Core config\n            debug: false,\n            scrubFields: ['password', 'token', 'api_key', 'secret'],\n\n            // Session replay config (error-triggered only)\n            sessionReplayEnabled: true,\n            bufferBeforeErrorSeconds: 30,\n            bufferBeforeErrorClicks: 10,\n            bufferAfterErrorSeconds: 30,\n            bufferAfterErrorClicks: 10,\n            snapshotThrottleMs: 1000,\n            maxSnapshotSize: 1048576, // 1MB\n            sessionTimeoutMinutes: 30,\n            maxBufferSizeMB: 5,\n            exposeApi: true,\n\n            // Merge user config\n            ...config,\n        };\n\n        // Initialize core components\n        this.transport = new Transport(this.config);\n        this.breadcrumbs = new BreadcrumbCollector();\n\n        // Initialize session replay components (if enabled)\n        this.sessionManager = null;\n        this.replayBuffer = null;\n        this.storageManager = null;\n        this.errorDetector = null;\n        this.heatmap = null;\n\n        if (this.config.sessionReplayEnabled) {\n            this.initializeSessionReplay();\n        }\n\n        // Initialize client (with optional errorDetector)\n        this.client = new Client(\n            this.config,\n            this.transport,\n            this.breadcrumbs,\n            this.errorDetector,\n        );\n\n        this.initialized = false;\n    }\n\n    /**\n     * Initialize session replay components\n     */\n    initializeSessionReplay() {\n        try {\n            // Session manager (cross-page sessions)\n            this.sessionManager = new SessionManager({\n                sessionTimeoutMinutes: this.config.sessionTimeoutMinutes,\n                debug: this.config.debug,\n            });\n\n            // Replay buffer (circular buffer for events)\n            this.replayBuffer = new ReplayBuffer({\n                bufferBeforeErrorSeconds: this.config.bufferBeforeErrorSeconds,\n                bufferBeforeErrorClicks: this.config.bufferBeforeErrorClicks,\n                bufferAfterErrorSeconds: this.config.bufferAfterErrorSeconds,\n                bufferAfterErrorClicks: this.config.bufferAfterErrorClicks,\n                maxBufferSizeMB: this.config.maxBufferSizeMB,\n                debug: this.config.debug,\n            });\n\n            // Storage manager (localStorage persistence)\n            this.storageManager = new StorageManager({\n                maxBufferSizeMB: this.config.maxBufferSizeMB,\n                debug: this.config.debug,\n            });\n\n            // Error detector (triggers replay on error)\n            this.errorDetector = new ErrorDetector(\n                this.replayBuffer,\n                this.sessionManager,\n                this.handleReplayCapture.bind(this),\n                {\n                    debug: this.config.debug,\n                    ignoreErrors: [],\n                },\n            );\n\n            // Click tracker (click recording to buffer for session replay)\n            this.heatmap = new ClickTracker(\n                this.replayBuffer,\n                this.sessionManager,\n                this.config,\n            );\n\n            // Load existing buffer from localStorage (cross-page continuity)\n            const savedBuffer = this.storageManager.load();\n            if (savedBuffer) {\n                this.replayBuffer.deserialize(savedBuffer);\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Loaded replay buffer from localStorage', {\n                        events: savedBuffer.buffer?.length || 0,\n                    });\n                }\n            }\n\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Session replay initialized');\n            }\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to initialize session replay', error);\n            // Disable session replay on initialization failure\n            this.config.sessionReplayEnabled = false;\n        }\n    }\n\n    /**\n     * Handle replay capture when error is detected\n     *\n     * Called by ErrorDetector after buffering is complete.\n     * Saves buffer to localStorage for cross-page continuity.\n     *\n     * Note: Replay data is sent WITH the error payload in client.captureException(),\n     * not as a separate request. This callback is just for localStorage persistence.\n     *\n     * @param {Object} errorContext - Error context\n     * @param {Array} events - Buffered events (before + after error)\n     * @param {Object} errorPayload - Original error payload sent to backend (unused here)\n     */\n    // eslint-disable-next-line no-unused-vars\n    async handleReplayCapture(errorContext, events, errorPayload) {\n        try {\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Replay captured for error', {\n                    errorMessage: errorContext.message,\n                    eventCount: events.length,\n                    sessionId: this.sessionManager.getSessionId(),\n                });\n            }\n\n            // Save buffer to localStorage for cross-page continuity\n            const serialized = this.replayBuffer.serialize();\n            this.storageManager.save(serialized);\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to save replay buffer', error);\n        }\n    }\n\n    /**\n     * Initialize the SDK and start capturing errors\n     */\n    init() {\n        if (this.initialized) {\n            console.warn('ApplicationLogger already initialized');\n            return;\n        }\n\n        // Install error capture\n        this.client.install();\n\n        // Install session replay (if enabled)\n        if (this.config.sessionReplayEnabled && this.heatmap) {\n            this.heatmap.install();\n            this.errorDetector.install();\n\n            // Save buffer to localStorage on page unload\n            window.addEventListener('beforeunload', () => {\n                this.saveBufferToStorage();\n            });\n\n            // Also save on visibility change (mobile)\n            document.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'hidden') {\n                    this.saveBufferToStorage();\n                }\n            });\n\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Session replay enabled (error-triggered)');\n            }\n        }\n\n        this.initialized = true;\n\n        if (this.config.debug) {\n            console.warn('ApplicationLogger initialized', {\n                environment: this.config.environment,\n                release: this.config.release,\n                sessionReplayEnabled: this.config.sessionReplayEnabled,\n                sessionId: this.sessionManager?.getSessionId(),\n            });\n        }\n    }\n\n    /**\n     * Save buffer to localStorage for cross-page continuity\n     */\n    saveBufferToStorage() {\n        try {\n            if (this.replayBuffer && this.storageManager) {\n                const serialized = this.replayBuffer.serialize();\n                this.storageManager.save(serialized);\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Buffer saved to localStorage');\n                }\n            }\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to save buffer', error);\n        }\n    }\n\n    /**\n   * Manually capture an exception\n   *\n   * @param {Error} error The error to capture\n   * @param {Object} [options] Additional options\n   * @param {Object} [options.tags] Key-value tags\n   * @param {Object} [options.extra] Additional context data\n   */\n    captureException(error, options = {}) {\n        this.client.captureException(error, options);\n    }\n\n    /**\n   * Manually capture a message\n   *\n   * @param {string} message The message to capture\n   * @param {string} [level='info'] Log level\n   * @param {Object} [options] Additional options\n   */\n    captureMessage(message, level = 'info', options = {}) {\n        this.client.captureMessage(message, level, options);\n    }\n\n    /**\n   * Add a breadcrumb\n   *\n   * @param {Object} breadcrumb Breadcrumb data\n   * @param {string} breadcrumb.type Breadcrumb type (navigation, http, user, etc.)\n   * @param {string} breadcrumb.category Category\n   * @param {string} breadcrumb.message Message\n   * @param {Object} [breadcrumb.data] Additional data\n   * @param {string} [breadcrumb.level='info'] Log level\n   */\n    addBreadcrumb(breadcrumb) {\n        this.breadcrumbs.add(breadcrumb);\n    }\n\n    /**\n   * Set user context\n   *\n   * @param {Object} user User data\n   * @param {string} [user.id] User ID\n   * @param {string} [user.email] User email\n   * @param {string} [user.username] Username\n   */\n    setUser(user) {\n        this.client.setUser(user);\n    }\n\n    /**\n   * Set tags\n   *\n   * @param {Object} tags Key-value tags\n   */\n    setTags(tags) {\n        this.client.setTags(tags);\n    }\n\n    /**\n     * Set extra context\n     *\n     * @param {Object} extra Key-value extra data\n     */\n    setExtra(extra) {\n        this.client.setExtra(extra);\n    }\n\n    /**\n     * Session Replay API - exposed for developer control\n     *\n     * Allows developers to let users control session replay:\n     * - window.ApplicationLogger.sessionReplay.enable()\n     * - window.ApplicationLogger.sessionReplay.disable()\n     * - window.ApplicationLogger.sessionReplay.isEnabled()\n     */\n    get sessionReplay() {\n        if (!this.config.exposeApi) {\n            return null;\n        }\n\n        return {\n            /**\n             * Enable session replay recording\n             */\n            enable: () => {\n                if (!this.config.sessionReplayEnabled) {\n                    this.config.sessionReplayEnabled = true;\n\n                    // Re-initialize if not already initialized\n                    if (!this.heatmap) {\n                        this.initializeSessionReplay();\n                        if (this.initialized && this.heatmap) {\n                            this.heatmap.install();\n                            this.errorDetector.install();\n                        }\n                    }\n\n                    if (this.config.debug) {\n                        console.warn('ApplicationLogger: Session replay enabled');\n                    }\n                }\n            },\n\n            /**\n             * Disable session replay recording\n             */\n            disable: () => {\n                if (this.config.sessionReplayEnabled) {\n                    this.config.sessionReplayEnabled = false;\n\n                    // Clean up and save buffer\n                    if (this.heatmap) {\n                        this.heatmap.cleanup();\n                    }\n                    if (this.errorDetector) {\n                        this.errorDetector.uninstall();\n                    }\n                    this.saveBufferToStorage();\n\n                    if (this.config.debug) {\n                        console.warn('ApplicationLogger: Session replay disabled');\n                    }\n                }\n            },\n\n            /**\n             * Check if session replay is enabled\n             * @returns {boolean}\n             */\n            isEnabled: () => {\n                return this.config.sessionReplayEnabled;\n            },\n\n            /**\n             * Get session replay statistics for debugging\n             * @returns {Object}\n             */\n            getStats: () => {\n                if (!this.config.sessionReplayEnabled) {\n                    return { enabled: false };\n                }\n\n                return {\n                    enabled: true,\n                    sessionId: this.sessionManager?.getSessionId(),\n                    sessionAge: this.sessionManager?.getSessionAge(),\n                    bufferStats: this.replayBuffer?.getStats(),\n                    storageStats: this.storageManager?.getStats(),\n                    domCaptureStats: this.heatmap?.getDOMCaptureStats(),\n                    debounceStats: this.heatmap?.getDebounceStats(),\n                    errorDetectorStats: this.errorDetector?.getStats(),\n                };\n            },\n        };\n    }\n}\n\n// Export for ES modules\nexport default ApplicationLogger;\n\n// Export for UMD (window.ApplicationLogger)\nif (typeof window !== 'undefined') {\n    window.ApplicationLogger = ApplicationLogger;\n}\n"],"names":["Client","constructor","config","transport","breadcrumbs","errorDetector","this","userContext","tags","extra","pendingBeaconErrors","install","window","addEventListener","event","captureException","error","Error","message","filename","lineno","colno","console","reason","type","flushBeaconErrors","document","visibilityState","options","payload","buildPayload","replayData","replayCapture","handleError","sessionId","events","send","captureError","captureMessage","level","stackTrace","parseStackTrace","firstFrame","length","name","file","line","stack_trace","source","environment","release","url","location","href","http_method","detectHttpMethod","http_status_code","extractHttpStatusCode","session_hash","getSessionHash","timestamp","Date","toISOString","runtime","getBrowserInfo","user_agent","navigator","userAgent","get","context","removeNullValues","stack","function","lines","split","frames","frame","parseStackLine","trim","push","match","parseInt","column","navigation","performance","getEntriesByType","status","httpStatusCode","ua","includes","sessionHash","sessionStorage","getItem","generateSessionId","setItem","sha256","crypto","randomUUID","replace","c","r","Math","random","toString","str","hash","i","charCodeAt","abs","padStart","obj","cleaned","key","value","Object","entries","setUser","user","setTags","setExtra","sendBeacon","stats","getStats","storedErrors","queueSize","flushWithBeacon","BreadcrumbCollector","maxBreadcrumbs","target","tagName","toLowerCase","className","element","undefined","baseVal","id","firstClass","add","category","data","tag","class","originalPushState","history","pushState","originalReplaceState","replaceState","args","to","apply","wrapConsole","wrapFetch","breadcrumb","shift","clear","forEach","original","join","arguments","originalFetch","fetch","async","method","startTime","now","response","duration","status_code","ok","CircuitBreaker","static","failureThreshold","timeout","storageKey","loadState","isOpen","state","STATE_OPEN","shouldAttemptReset","halfOpen","isHalfOpen","STATE_HALF_OPEN","recordSuccess","close","STATE_CLOSED","failureCount","saveState","recordFailure","open","getState","openedAt","reset","stored","JSON","parse","stringify","StorageQueue","maxSize","maxAge","enqueue","queue","getQueue","item","saveQueue","warn","dequeue","getAll","map","size","localStorage","removeItem","Array","isArray","filtered","filter","halfSize","floor","trimmed","slice","RateLimiter","maxTokens","refillRate","tokens","lastRefill","isAllowed","refillTokens","consume","elapsed","tokensToAdd","min","getTokens","Transport","apiKey","dsn","parseDsn","sending","circuitBreaker","storageQueue","rateLimiter","recentErrors","Map","deduplicationWindow","flushStoredErrors","URL","projectId","pathname","protocol","host","endpoint","enhancedPayload","replay_session_id","replay_data","debug","eventCount","scrubbedPayload","scrubSensitiveData","isDuplicate","processQueue","sendToApi","attempt","controller","AbortController","timeoutId","setTimeout","abort","headers","body","signal","clearTimeout","statusText","json","delay","pow","signature","exception","stacktrace","simpleHash","has","set","delete","limit","ms","Promise","resolve","scrubPatterns","scrubFields","scrubbed","removeCircularReferences","scrubObject","prototype","hasOwnProperty","call","some","pattern","seen","WeakSet","result","sendSessionEvent","eventData","sendReplayClicks","clicks","rateLimitTokens","allErrors","errorsToSend","beaconPayload","errors","blob","Blob","DOMSerializer","maxDepth","minSize","skipInvisible","captureColors","totalElements","skippedInvisible","skippedTiny","skippedNonVisual","maxDepthReached","serialize","rootElement","viewport","width","innerWidth","height","innerHeight","scrollX","scrollY","tree","serializeElement","elapsedMs","toFixed","depth","isNonVisualElement","style","getComputedStyle","isInvisible","rect","getBoundingClientRect","serialized","bounds","x","round","left","y","top","bgColor","extractBackgroundColor","layout","detectLayoutType","isInteractive","isText","isTextContainer","children","childElements","from","child","serializedChild","display","visibility","parseFloat","opacity","bottom","right","backgroundColor","rgbToHex","rgb","g","b","toHex","n","hex","onclick","hasAttribute","cursor","estimateSize","compress","removeNulls","ThrottledDOMSerializer","serializer","throttleMs","lastCaptureTime","pendingCapture","timeSinceLastCapture","remainingTime","clearThrottle","ClickTracker","replayBuffer","sessionManager","isInstalled","max","snapshotThrottleMs","domSerializer","maxSnapshotSize","domCaptureStats","total","throttled","captured","lastClickTime","clickDebounceMs","debounceStats","totalClicks","debouncedClicks","captureClick","timeSinceLastClick","debounceThreshold","clickEvent","clickData","pageX","pageY","viewportWidth","viewportHeight","elementSelector","generateSelector","getSessionId","domSnapshot","elements","sizeBytes","sizeKB","domError","addEvent","parts","current","selector","containsSensitiveData","CSS","escape","unshift","classes","getCleanClasses","siblings","parentElement","indexOf","classList","cls","test","getDOMCaptureStats","serializerStats","getDebounceStats","debounceRate","cleanup","ReplayBuffer","bufferBeforeErrorSeconds","bufferBeforeErrorClicks","bufferAfterErrorSeconds","bufferAfterErrorClicks","maxBufferSizeMB","buffer","isRecordingAfterError","recordingStartedAt","errorOccurredAt","postErrorEventCount","totalEvents","eventsDropped","bufferFullCount","currentBufferSize","phase","capturedAt","shouldStopRecording","stopRecording","pruneOldEvents","updateStats","startRecordingAfterError","errorContext","errorId","bufferSize","willRecordFor","postErrorEvents","elapsedSeconds","cutoffTime","timeFiltered","clickEvents","e","otherEvents","recentClicks","sort","a","dropped","getEvents","getEventsByPhase","isRecording","bufferLength","approximateSize","estimateBufferSize","deserialize","ErrorDetector","onErrorDetected","ignoreErrors","Set","recentErrorsCleanupInterval","errorsDetected","errorsIgnored","replaysCaptured","duplicatesPrevented","setInterval","uninstall","clearInterval","errorPayload","shouldIgnoreError","errorFingerprint","generateErrorFingerprint","errorMessage","beforeError","afterError","handlingError","commonIgnorePatterns","recentErrorsCount","setEnabled","enabled","isEnabled","SessionManager","sessionTimeoutMinutes","STORAGE_KEY_SESSION_ID","STORAGE_KEY_SESSION_METADATA","metadata","startedAt","lastActivityAt","pageCount","pages","initialize","loadSession","isSessionExpired","createNewSession","updateActivity","trackPageView","setupPageTransitionTracking","saveSession","metadataJson","age","getSessionAge","lastActivity","pageEvent","handleNavigationChange","getMetadata","substr","clearSession","extendSession","getSessionInfo","ageMinutes","isExpired","recentPages","timeoutMinutes","StorageManager","STORAGE_KEY_BUFFER","STORAGE_KEY_METADATA","savesSuccessful","savesFailed","loadsSuccessful","loadsFailed","quotaExceededCount","cleanupCount","save","bufferData","estimatedSize","maxSizeBytes","sizeMB","pruneBuffer","saveMetadata","savedAt","prunedBuffer","load","loadMetadata","ageHours","pruned","removed","originalEvents","prunedEvents","originalSize","prunedSize","getSpaceInfo","testKey","testData","repeat","available","used","usedBytes","usedMB","availableMB","totalMB","spaceInfo","isAvailable","ApplicationLogger","sessionReplayEnabled","exposeApi","storageManager","heatmap","initializeSessionReplay","client","initialized","handleReplayCapture","bind","savedBuffer","init","saveBufferToStorage","addBreadcrumb","sessionReplay","enable","disable","sessionAge","bufferStats","storageStats","errorDetectorStats"],"mappings":"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"}