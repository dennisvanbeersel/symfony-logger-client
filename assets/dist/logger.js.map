{"version":3,"file":"logger.js","sources":["../src/client.js","../src/breadcrumbs.js","../src/circuit-breaker.js","../src/storage-queue.js","../src/rate-limiter.js","../src/transport.js","../src/dom-serializer.js","../src/click-tracker.js","../src/replay-buffer.js","../src/error-detector.js","../src/session-manager.js","../src/storage-manager.js","../src/index.js"],"sourcesContent":["/**\n * Client for capturing errors and sending to platform\n *\n * ERROR-TRIGGERED SESSION REPLAY:\n * - When error detected, triggers replay buffer capture\n * - Sends buffered events (before/after error) to backend\n * - Links replay data to error for debugging\n *\n * RESILIENCE FEATURES:\n * - Beacon API for page unload events (ensures critical errors are sent)\n * - All error handling wrapped in try-catch\n * - Never crashes on logging errors\n */\nexport class Client {\n    /**\n     * @param {Object} config - Configuration options\n     * @param {Transport} transport - Transport layer for API communication\n     * @param {BreadcrumbCollector} breadcrumbs - Breadcrumb tracking\n     * @param {ErrorDetector|null} errorDetector - Error detector for replay capture (optional)\n     * @param {SessionManager|null} sessionManager - Session manager for session ID tracking (optional)\n     */\n    constructor(config, transport, breadcrumbs, errorDetector = null, sessionManager = null) {\n        this.config = config;\n        this.transport = transport;\n        this.breadcrumbs = breadcrumbs;\n        this.errorDetector = errorDetector;\n        this.sessionManager = sessionManager;\n        this.userContext = null;\n        this.tags = {};\n        this.extra = {};\n        this.pendingBeaconErrors = [];\n        this.cachedSessionHash = null; // Pre-computed SHA-256 hash (async init)\n    }\n\n    /**\n   * Install global error handlers\n   *\n   * Processing order (critical for reliability):\n   * 1. Resurrect nuclear errors from previous page loads (localStorage)\n   * 2. Process buffered errors from current page load (window._appLoggerBuffer)\n   * 3. Install live error handlers for future errors\n   */\n    install() {\n        try {\n            // 0. Initialize session hash asynchronously (non-blocking)\n            //    First few errors before hash is computed will have null session_hash\n            this.initSessionHash().catch(() => {\n                // Silently fail - session hash is optional\n            });\n\n            // 1. Process \"resurrected\" errors first (from previous sessions)\n            //    These are catastrophic errors that broke JS execution\n            this.processResurrectedErrors();\n\n            // 2. Process any errors that were buffered before SDK loaded (current page)\n            this.processBufferedErrors();\n\n            // 3. Handle uncaught errors (live, from this point forward)\n            window.addEventListener('error', (event) => {\n                try {\n                    this.captureException(event.error || new Error(event.message), {\n                        extra: {\n                            filename: event.filename,\n                            lineno: event.lineno,\n                            colno: event.colno,\n                        },\n                    });\n                } catch (error) {\n                    // Never crash on error handling\n                    console.error('ApplicationLogger: Failed to capture error', error);\n                }\n            });\n\n            // Handle unhandled promise rejections\n            window.addEventListener('unhandledrejection', (event) => {\n                try {\n                    this.captureException(event.reason, {\n                        extra: {\n                            type: 'unhandledrejection',\n                        },\n                    });\n                } catch (error) {\n                    console.error('ApplicationLogger: Failed to capture rejection', error);\n                }\n            });\n\n            // Use Beacon API for page unload to ensure critical errors are sent\n            window.addEventListener('beforeunload', () => {\n                this.flushBeaconErrors();\n            });\n\n            // Also try on visibilitychange (for mobile)\n            document.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'hidden') {\n                    this.flushBeaconErrors();\n                }\n            });\n\n            // Track breadcrumbs\n            this.breadcrumbs.install();\n        } catch (error) {\n            // Installation failure should never crash the app\n            console.error('ApplicationLogger: Failed to install', error);\n        }\n    }\n\n    /**\n     * Process \"resurrected\" errors from previous page loads.\n     *\n     * The nuclear error trap (ultra-minimal inline script) captures catastrophic\n     * errors that break JavaScript execution and stores them to localStorage.\n     * On the NEXT page load (when things have \"normalized\"), we resurrect and\n     * send these errors.\n     *\n     * This handles the \"nuclear scenario\":\n     * - Syntax errors before SDK loads\n     * - Module import failures\n     * - Blocking runtime errors\n     * - Third-party script failures\n     *\n     * Flow:\n     * 1. Check localStorage for '_appLogger_nuclear'\n     * 2. Parse stored errors\n     * 3. Send each error to API with 'resurrected: true' flag\n     * 4. Clear localStorage after successful send\n     */\n    processResurrectedErrors() {\n        try {\n            const NUCLEAR_KEY = '_appLogger_nuclear';\n            const RESURRECTION_ATTEMPTS_KEY = '_appLogger_resurrection_attempts';\n            const MAX_ATTEMPTS = 5;\n            const MAX_AGE_MS = 24 * 60 * 60 * 1000; // 24 hours\n\n            // Check if we've tried too many times\n            const attempts = parseInt(localStorage.getItem(RESURRECTION_ATTEMPTS_KEY) || '0', 10);\n            if (attempts >= MAX_ATTEMPTS) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Max resurrection attempts reached, clearing nuclear errors');\n                }\n                localStorage.removeItem(NUCLEAR_KEY);\n                localStorage.removeItem(RESURRECTION_ATTEMPTS_KEY);\n                return;\n            }\n\n            // Try to load nuclear errors\n            const stored = localStorage.getItem(NUCLEAR_KEY);\n            if (!stored) {\n                // No errors to resurrect\n                return;\n            }\n\n            // Parse stored errors\n            let errors;\n            try {\n                errors = JSON.parse(stored);\n            } catch (parseError) {\n                // Corrupted data - clear it\n                if (this.config.debug) {\n                    console.error('ApplicationLogger: Failed to parse nuclear errors, clearing', parseError);\n                }\n                localStorage.removeItem(NUCLEAR_KEY);\n                return;\n            }\n\n            // Validate array\n            if (!Array.isArray(errors) || errors.length === 0) {\n                localStorage.removeItem(NUCLEAR_KEY);\n                return;\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Resurrecting ${errors.length} nuclear error(s) from previous session`);\n            }\n\n            // Filter out old errors (older than MAX_AGE)\n            const now = Date.now();\n            const validErrors = errors.filter(err => {\n                const age = now - (err.t || 0);\n                return age < MAX_AGE_MS;\n            });\n\n            if (validErrors.length === 0) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: All nuclear errors expired, clearing');\n                }\n                localStorage.removeItem(NUCLEAR_KEY);\n                return;\n            }\n\n            // Track successes and failures\n            let succeeded = 0;\n            let failed = 0;\n\n            // Send each error\n            for (const err of validErrors) {\n                try {\n                    // Reconstruct error message\n                    const message = err.m\n                        ? String(err.m)\n                        : 'Nuclear error (catastrophic JavaScript failure)';\n\n                    const error = new Error(message);\n                    error.name = 'NuclearError';\n\n                    // Calculate age\n                    const errorAge = now - (err.t || now);\n\n                    // Capture with resurrection context\n                    this.captureException(error, {\n                        extra: {\n                            resurrected: true,\n                            nuclear: true,\n                            resurrectTimestamp: now,\n                            originalTimestamp: err.t || 0,\n                            errorAge: Math.floor(errorAge / 1000), // seconds\n                            filename: err.f || 'unknown',\n                            lineno: err.l || 0,\n                            colno: err.c || 0,\n                            originalUrl: err.u || 'unknown',\n                            sessionGap: true, // Error from previous page load\n                        },\n                    });\n\n                    succeeded++;\n                } catch (sendError) {\n                    failed++;\n                    if (this.config.debug) {\n                        console.error('ApplicationLogger: Failed to resurrect nuclear error', sendError);\n                    }\n                }\n            }\n\n            // If all succeeded, clear localStorage\n            if (failed === 0) {\n                localStorage.removeItem(NUCLEAR_KEY);\n                localStorage.removeItem(RESURRECTION_ATTEMPTS_KEY);\n\n                if (this.config.debug) {\n                    console.warn(`ApplicationLogger: Successfully resurrected ${succeeded} nuclear error(s)`);\n                }\n            } else {\n                // Some failed - increment attempt counter\n                localStorage.setItem(RESURRECTION_ATTEMPTS_KEY, String(attempts + 1));\n\n                if (this.config.debug) {\n                    console.warn(`ApplicationLogger: Resurrection partial success (${succeeded} succeeded, ${failed} failed), will retry on next load`);\n                }\n            }\n        } catch (error) {\n            // Never crash on resurrection\n            console.error('ApplicationLogger: Failed to process resurrected errors', error);\n        }\n    }\n\n    /**\n     * Process errors that were buffered before SDK loaded.\n     *\n     * The early error buffer (window._appLoggerBuffer) captures errors that occur\n     * before the full SDK loads (during page parsing, module loading, etc.).\n     * This method processes those buffered errors and sends them to the API.\n     */\n    processBufferedErrors() {\n        try {\n            // Check if buffer exists and is valid\n            if (!window._appLoggerBuffer ||\n                !Array.isArray(window._appLoggerBuffer.errors)) {\n                return;\n            }\n\n            const buffered = window._appLoggerBuffer.errors;\n\n            // Nothing to process\n            if (buffered.length === 0) {\n                return;\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Processing ${buffered.length} buffered error(s)`);\n            }\n\n            // Clear buffer immediately to prevent reprocessing\n            window._appLoggerBuffer.errors = [];\n\n            // Track processing stats\n            let processed = 0;\n            let failed = 0;\n\n            // Process each buffered error\n            for (const item of buffered) {\n                try {\n                    // Validate item structure\n                    if (!item || typeof item !== 'object') {\n                        failed++;\n                        continue;\n                    }\n\n                    if (item.type === 'error') {\n                        // Reconstruct error object from buffered data\n                        const message = item.error && item.error.message\n                            ? String(item.error.message)\n                            : (item.message ? String(item.message) : 'Unknown buffered error');\n\n                        const error = new Error(message);\n\n                        // Restore error properties if available\n                        if (item.error && typeof item.error === 'object') {\n                            if (item.error.name) {\n                                error.name = String(item.error.name);\n                            }\n                            if (item.error.stack) {\n                                error.stack = String(item.error.stack);\n                            }\n                        }\n\n                        // Capture with buffered context\n                        this.captureException(error, {\n                            extra: {\n                                buffered: true,\n                                bufferedAt: item.timestamp || Date.now(),\n                                filename: item.filename || 'unknown',\n                                lineno: typeof item.lineno === 'number' ? item.lineno : 0,\n                                colno: typeof item.colno === 'number' ? item.colno : 0,\n                            },\n                        });\n\n                        processed++;\n                    } else if (item.type === 'rejection') {\n                        // Handle promise rejection\n                        const reason = item.reason;\n                        let error;\n\n                        if (reason && typeof reason === 'object') {\n                            const message = reason.message\n                                ? String(reason.message)\n                                : 'Unhandled promise rejection';\n\n                            error = new Error(message);\n                            error.name = reason.name ? String(reason.name) : 'UnhandledRejection';\n\n                            if (reason.stack) {\n                                error.stack = String(reason.stack);\n                            }\n                        } else {\n                            // Primitive value or null/undefined\n                            const message = (reason !== null && reason !== undefined)\n                                ? String(reason)\n                                : 'Unhandled promise rejection (undefined)';\n\n                            error = new Error(message);\n                            error.name = 'UnhandledRejection';\n                        }\n\n                        this.captureException(error, {\n                            extra: {\n                                buffered: true,\n                                bufferedAt: item.timestamp || Date.now(),\n                                type: 'unhandledrejection',\n                            },\n                        });\n\n                        processed++;\n                    } else {\n                        // Unknown item type\n                        if (this.config.debug) {\n                            console.warn('ApplicationLogger: Unknown buffered item type:', item.type);\n                        }\n                        failed++;\n                    }\n                } catch (itemError) {\n                    // Failed to process this specific item - continue with others\n                    failed++;\n                    if (this.config.debug) {\n                        console.error('ApplicationLogger: Failed to process buffered item', itemError);\n                    }\n                }\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Buffered errors processed (${processed} succeeded, ${failed} failed)`);\n            }\n        } catch (error) {\n            // Never crash on buffer processing\n            console.error('ApplicationLogger: Failed to process buffered errors', error);\n        }\n    }\n\n    /**\n     * Count click events in an event array\n     * @param {Array} events - Array of replay events\n     * @returns {number} - Count of click events\n     */\n    countClickEvents(events) {\n        if (!Array.isArray(events)) {\n            return 0;\n        }\n        return events.filter(event => event && event.type === 'click').length;\n    }\n\n    /**\n     * Capture exception and trigger TWO-PHASE session replay if enabled\n     *\n     * TWO-PHASE ARCHITECTURE:\n     * Phase 1 (Immediate): Send error + pre-error buffer right away\n     * Phase 2 (Recovery): Continue recording, send recovery session separately\n     *\n     * Flow:\n     * 1. Build error payload\n     * 2. If session replay enabled:\n     *    a) Call errorDetector.handleError() to mark buffer and get events\n     *    b) Send error + pre-error replay immediately (don't wait)\n     *    c) Start recording recovery session (async, non-blocking)\n     * 3. If session replay disabled: send error only\n     */\n    async captureException(error, options = {}) {\n        try {\n            // Build error payload\n            const payload = this.buildPayload(error, 'error', options);\n\n            // TWO-PHASE SESSION REPLAY (with defensive null checks)\n            if (this.errorDetector && this.errorDetector.replayBuffer && this.errorDetector.sessionManager) {\n                try {\n                    // CRITICAL: Call handleError() to properly mark the buffer and get events\n                    // This method:\n                    // 1. Marks the current buffer position as \"error occurred\"\n                    // 2. Gets all buffered events (before error)\n                    // 3. Triggers the onErrorDetected callback\n                    // 4. Returns replay context with events\n                    const replayContext = await this.errorDetector.handleError(error, payload);\n\n                    // Defensive: Check if we got replay context with events\n                    let replayData = null;\n                    if (replayContext && replayContext.events && replayContext.events.length > 0) {\n                        // Filter to get only pre-error events\n                        const preErrorEvents = replayContext.events.filter(event =>\n                            event.phase === 'before_error' || event.phase === 'error',\n                        );\n\n                        if (preErrorEvents.length > 0) {\n                            // Check if there are any click events (user interactions)\n                            const clickCount = this.countClickEvents(preErrorEvents);\n\n                            if (clickCount > 0) {\n                                replayData = {\n                                    sessionId: replayContext.sessionId,\n                                    events: preErrorEvents,\n                                    phase: 'pre-error', // Mark as phase 1\n                                };\n\n                                if (this.config.debug) {\n                                    console.warn('ApplicationLogger: Sending error with pre-error replay (phase 1)', {\n                                        totalEvents: replayContext.events.length,\n                                        preErrorEvents: preErrorEvents.length,\n                                        clickEvents: clickCount,\n                                        sessionId: replayData.sessionId,\n                                    });\n                                }\n                            } else if (this.config.debug) {\n                                console.warn('ApplicationLogger: No click events in replay buffer, skipping replay data', {\n                                    totalEvents: preErrorEvents.length,\n                                    bufferStats: this.errorDetector.replayBuffer.getStats(),\n                                });\n                            }\n                        } else if (this.config.debug) {\n                            console.warn('ApplicationLogger: No pre-error events in buffer', {\n                                totalEvents: replayContext.events.length,\n                                bufferStats: this.errorDetector.replayBuffer.getStats(),\n                            });\n                        }\n                    } else if (this.config.debug) {\n                        console.warn('ApplicationLogger: No replay context from error detector', {\n                            hasContext: !!replayContext,\n                            hasEvents: !!(replayContext && replayContext.events),\n                            eventCount: replayContext?.events?.length || 0,\n                            bufferStats: this.errorDetector.replayBuffer.getStats(),\n                        });\n                    }\n\n                    // Send error + pre-error replay immediately\n                    await this.transport.send(payload, replayData);\n\n                    // Phase 2: Start recording recovery session (async, non-blocking)\n                    // This runs in the background and sends separately when complete\n                    // Defensive: Check method exists before calling\n                    if (typeof this.errorDetector.startRecoveryRecording === 'function') {\n                        this.errorDetector.startRecoveryRecording(error).catch(recoveryError => {\n                            if (this.config.debug) {\n                                console.error('ApplicationLogger: Recovery recording failed', recoveryError);\n                            }\n                        });\n                    }\n                } catch (replayError) {\n                    // If session replay fails, still send error without replay data\n                    if (this.config.debug) {\n                        console.error('ApplicationLogger: Session replay failed, sending error without replay', replayError);\n                    }\n                    await this.transport.send(payload);\n                }\n            } else {\n                // No session replay - send error only\n                if (this.config.debug && !this.errorDetector) {\n                    console.warn('ApplicationLogger: Session replay disabled (no error detector)');\n                }\n                await this.transport.send(payload);\n            }\n        } catch (captureError) {\n            // Never crash on error capture\n            console.error('Client: Failed to capture exception', captureError);\n        }\n    }\n\n    /**\n   * Capture message\n   */\n    captureMessage(message, level = 'info', options = {}) {\n        const payload = this.buildPayload(new Error(message), level, options);\n        this.transport.send(payload);\n    }\n\n    /**\n   * Build error payload matching API expectations\n   *\n   * API expects flat structure with snake_case field names:\n   * {type, message, file, line, stack_trace, level, environment, ...}\n   */\n    buildPayload(error, level, options = {}) {\n        try {\n            const stackTrace = this.parseStackTrace(error);\n            const firstFrame = stackTrace.length > 0 ? stackTrace[0] : null;\n\n            // Build payload matching exact API format\n            // Apply length limits to prevent API validation failures\n            const payload = {\n                // Required fields (flat structure, not nested)\n                // API length constraints: type (255), message (1000), file (500)\n                type: this.truncate(error.name || 'Error', 255),\n                message: this.truncate(error.message || 'Unknown error', 1000),\n                file: this.truncate(firstFrame?.file || options.extra?.filename || 'unknown', 500),\n                // API requires line > 0 (Positive constraint), default to 1\n                line: firstFrame?.line || options.extra?.lineno || 1,\n                stack_trace: stackTrace,\n\n                // Optional fields (snake_case to match API)\n                level: level || 'error',\n                source: 'frontend',\n                environment: this.config.environment || 'production',\n                release: this.config.release || null,\n                url: window.location.href,\n                http_method: this.detectHttpMethod(),\n                http_status_code: this.extractHttpStatusCode(error, options),\n                session_hash: this.getSessionHash(),\n                session_id: this.sessionManager ? this.sessionManager.getSessionId() : null,\n                timestamp: new Date().toISOString(),\n                runtime: `JavaScript ${this.getBrowserInfo()}`,\n                user_agent: navigator.userAgent,\n                breadcrumbs: this.breadcrumbs.get(),\n                context: { ...this.extra, ...options.extra },\n                tags: { ...this.tags, ...options.tags },\n            };\n\n            // Clean up null values to reduce payload size\n            return this.removeNullValues(payload);\n        } catch (err) {\n            // If payload building completely fails, return minimal payload\n            console.error('ApplicationLogger: Failed to build payload', err);\n            return {\n                type: 'Error',\n                message: this.truncate('Failed to build error payload', 1000),\n                file: 'unknown',\n                line: 1, // API requires line > 0\n                stack_trace: [],\n                level: 'error',\n            };\n        }\n    }\n\n    /**\n     * Truncate string to maximum length.\n     *\n     * API has length constraints: type (255), message (1000), file (500).\n     * Truncation prevents validation failures.\n     *\n     * @param {string} value - String to truncate\n     * @param {number} maxLength - Maximum allowed length\n     * @returns {string} Truncated string\n     */\n    truncate(value, maxLength) {\n        if (!value || typeof value !== 'string') {\n            return value;\n        }\n\n        if (value.length <= maxLength) {\n            return value;\n        }\n\n        // Truncate and add ellipsis to indicate truncation\n        return value.substring(0, maxLength - 3) + '...';\n    }\n\n    /**\n   * Parse error stack trace with cross-browser support\n   *\n   * Returns array of frames matching API format:\n   * [{file, line, function, class, column}, ...]\n   */\n    parseStackTrace(error) {\n        if (!error.stack) {\n            return [{\n                file: 'unknown',\n                line: 1, // API requires line > 0\n                function: 'unknown',\n            }];\n        }\n\n        try {\n            const lines = error.stack.split('\\n');\n            const frames = [];\n\n            for (const line of lines) {\n                const frame = this.parseStackLine(line.trim());\n                if (frame) {\n                    frames.push(frame);\n                }\n            }\n\n            return frames.length > 0 ? frames : [{\n                file: 'unknown',\n                line: 1, // API requires line > 0\n                function: 'unknown',\n            }];\n        } catch {\n            return [{\n                file: 'unknown',\n                line: 1, // API requires line > 0\n                function: 'unknown',\n            }];\n        }\n    }\n\n    /**\n   * Parse a single stack trace line (cross-browser)\n   *\n   * Handles formats from Chrome, Firefox, Safari, Edge\n   */\n    parseStackLine(line) {\n        if (!line) {\n            return null;\n        }\n\n        // Chrome/V8: \"at functionName (file.js:line:col)\"\n        let match = line.match(/at\\s+(.+?)\\s+\\((.+?):(\\d+):(\\d+)\\)/);\n        if (match) {\n            return {\n                function: match[1].trim(),\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Chrome/V8 anonymous: \"at file.js:line:col\"\n        match = line.match(/at\\s+(.+?):(\\d+):(\\d+)/);\n        if (match) {\n            return {\n                function: 'anonymous',\n                file: match[1],\n                line: parseInt(match[2], 10),\n                column: parseInt(match[3], 10),\n            };\n        }\n\n        // Firefox: \"functionName@file.js:line:col\"\n        match = line.match(/(.+?)@(.+?):(\\d+):(\\d+)/);\n        if (match) {\n            return {\n                function: match[1] || 'anonymous',\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Safari/Firefox (no column): \"functionName@file.js:line\"\n        match = line.match(/(?:(.+)@)?(.+?):(\\d+)$/);\n        if (match) {\n            return {\n                function: match[1] || 'anonymous',\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: null,\n            };\n        }\n\n        // Edge legacy: \"at functionName (file.js:line:col)\"\n        match = line.match(/at\\s+(.+?)\\s+\\[(.+?):(\\d+):(\\d+)\\]/);\n        if (match) {\n            return {\n                function: match[1].trim(),\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Could not parse this line\n        return null;\n    }\n\n    /**\n   * Detect HTTP method for current page load\n   */\n    detectHttpMethod() {\n        try {\n            // Try to detect from performance API\n            const navigation = performance.getEntriesByType('navigation')[0];\n            if (navigation && navigation.type) {\n                // Navigation types: navigate, reload, back_forward, prerender\n                return 'GET'; // Page loads are always GET\n            }\n        } catch {\n            // Performance API not available\n        }\n\n        // Default to GET (most common for page loads)\n        return 'GET';\n    }\n\n    /**\n     * Extract HTTP status code from error context.\n     *\n     * Attempts to extract status code from:\n     * 1. Error object's status property (fetch Response)\n     * 2. Options extra data (manually passed)\n     * 3. Error message parsing (e.g., \"HTTP 404 Not Found\")\n     *\n     * @param {Error} error - The error object\n     * @param {Object} options - Additional options passed to captureException\n     * @returns {number|null} HTTP status code or null if not available\n     */\n    extractHttpStatusCode(error, options = {}) {\n        try {\n            // Check if error has status property (fetch Response errors)\n            if (error.status && typeof error.status === 'number') {\n                return error.status;\n            }\n\n            // Check if status was passed in options\n            if (options.httpStatusCode && typeof options.httpStatusCode === 'number') {\n                return options.httpStatusCode;\n            }\n\n            // Check extra context for status code\n            if (options.extra?.http_status_code && typeof options.extra.http_status_code === 'number') {\n                return options.extra.http_status_code;\n            }\n\n            if (options.extra?.httpStatusCode && typeof options.extra.httpStatusCode === 'number') {\n                return options.extra.httpStatusCode;\n            }\n\n            // Try to parse status code from error message (e.g., \"HTTP 404 Not Found\")\n            if (error.message) {\n                const match = error.message.match(/HTTP\\s+(\\d{3})/i);\n                if (match) {\n                    const status = parseInt(match[1], 10);\n                    if (status >= 100 && status < 600) {\n                        return status;\n                    }\n                }\n            }\n\n            // No HTTP status code available\n            return null;\n        } catch {\n            // If extraction fails, return null\n            return null;\n        }\n    }\n\n    /**\n   * Get browser info from user agent\n   */\n    getBrowserInfo() {\n        const ua = navigator.userAgent;\n\n        if (ua.includes('Chrome') && !ua.includes('Edge')) {\n            return 'Chrome';\n        }\n        if (ua.includes('Firefox')) {\n            return 'Firefox';\n        }\n        if (ua.includes('Safari') && !ua.includes('Chrome')) {\n            return 'Safari';\n        }\n        if (ua.includes('Edge') || ua.includes('Edg/')) {\n            return 'Edge';\n        }\n        if (ua.includes('MSIE') || ua.includes('Trident/')) {\n            return 'IE';\n        }\n\n        return 'Unknown';\n    }\n\n    /**\n     * Get session hash for GDPR-compliant session tracking.\n     *\n     * Returns the pre-computed SHA-256 hash from initSessionHash().\n     * If hash is not yet computed (async init pending), returns null.\n     *\n     * Priority:\n     * 1. Use sessionHash from config if provided by server (Symfony bundle)\n     * 2. Return cached session hash (computed by initSessionHash)\n     * 3. Return null (errors will be tracked without session linkage)\n     *\n     * @returns {string|null} SHA-256 hash of session ID (64 hex chars)\n     */\n    getSessionHash() {\n        try {\n            // 1. Check if server provided session hash (Symfony bundle sets this)\n            if (this.config.sessionHash) {\n                return this.config.sessionHash;\n            }\n\n            // 2. Return cached session hash (computed asynchronously on init)\n            if (this.cachedSessionHash) {\n                return this.cachedSessionHash;\n            }\n\n            // 3. Fallback to synchronous djb2Hash if async hash not yet computed\n            //    This ensures we always return a valid hash for error tracking\n            const sessionId = this.getOrCreateSessionId();\n            return this.djb2Hash(sessionId);\n        } catch {\n            // If session tracking fails, return null (errors still captured)\n            return null;\n        }\n    }\n\n    /**\n     * Generate a unique session ID for client-side session tracking\n     *\n     * @returns {string} Random session ID\n     */\n    generateSessionId() {\n        // Use crypto.randomUUID if available (modern browsers)\n        if (crypto && crypto.randomUUID) {\n            return crypto.randomUUID();\n        }\n\n        // Fallback: Generate random string\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = Math.random() * 16 | 0;\n            const v = c === 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n\n    /**\n     * Initialize session hash asynchronously using Web Crypto API.\n     *\n     * Pre-computes the SHA-256 hash once on startup, then caches it for\n     * synchronous access in getSessionHash(). This avoids cascading async\n     * changes through the codebase while still using real SHA-256.\n     *\n     * @returns {Promise<void>}\n     */\n    async initSessionHash() {\n        try {\n            // Get or create session ID\n            const sessionId = this.getOrCreateSessionId();\n\n            // Use Web Crypto API for real SHA-256 (modern browsers)\n            if (crypto && crypto.subtle) {\n                const encoder = new TextEncoder();\n                const data = encoder.encode(sessionId);\n                const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n                const hashArray = Array.from(new Uint8Array(hashBuffer));\n                this.cachedSessionHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Session hash initialized (Web Crypto)');\n                }\n            } else {\n                // Fallback for old browsers (rare)\n                this.cachedSessionHash = this.djb2Hash(sessionId);\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Session hash initialized (fallback)');\n                }\n            }\n        } catch (error) {\n            // If crypto fails, use fallback\n            try {\n                this.cachedSessionHash = this.djb2Hash(this.getOrCreateSessionId());\n            } catch {\n                // Complete failure - session hash will be null\n                if (this.config.debug) {\n                    console.error('ApplicationLogger: Failed to initialize session hash', error);\n                }\n            }\n        }\n    }\n\n    /**\n     * Get or create session ID for hashing.\n     *\n     * @returns {string} Session ID\n     */\n    getOrCreateSessionId() {\n        if (typeof sessionStorage !== 'undefined') {\n            let sessionId = sessionStorage.getItem('_app_logger_session_id');\n\n            if (!sessionId) {\n                sessionId = this.generateSessionId();\n                sessionStorage.setItem('_app_logger_session_id', sessionId);\n            }\n\n            return sessionId;\n        }\n\n        // Fallback if sessionStorage not available\n        return this.generateSessionId();\n    }\n\n    /**\n     * DJB2 hash function (fallback for browsers without Web Crypto API).\n     *\n     * This is a simple hash function used as fallback. It's not SHA-256\n     * but produces consistent results that pass regex validation.\n     *\n     * @param {string} str - String to hash\n     * @returns {string} 64-character hexadecimal hash\n     */\n    djb2Hash(str) {\n        let hash = 5381;\n        for (let i = 0; i < str.length; i++) {\n            hash = ((hash << 5) + hash) + str.charCodeAt(i);\n        }\n\n        // Convert to hex and pad to 64 characters\n        const hex = Math.abs(hash).toString(16);\n        return hex.padStart(64, '0');\n    }\n\n    /**\n   * Remove null/undefined values from object to reduce payload size\n   */\n    removeNullValues(obj) {\n        const cleaned = {};\n\n        for (const [key, value] of Object.entries(obj)) {\n            if (value !== null && value !== undefined) {\n                cleaned[key] = value;\n            }\n        }\n\n        return cleaned;\n    }\n\n    setUser(user) {\n        this.userContext = user;\n    }\n\n    setTags(tags) {\n        this.tags = { ...this.tags, ...tags };\n    }\n\n    setExtra(extra) {\n        this.extra = { ...this.extra, ...extra };\n    }\n\n    /**\n     * Flush pending errors using Beacon API\n     * Called on page unload to ensure critical errors are sent\n     */\n    flushBeaconErrors() {\n        try {\n            // Check if Beacon API is available\n            if (!navigator.sendBeacon) {\n                return;\n            }\n\n            // Get transport stats to check for pending errors\n            const stats = this.transport.getStats();\n\n            if (stats.storedErrors === 0 && stats.queueSize === 0) {\n                return; // Nothing to flush\n            }\n\n            // Delegate to transport's beacon flush method\n            this.transport.flushWithBeacon();\n        } catch {\n            // Never crash on flush - but this is our last chance to send errors\n            // So we silently fail\n        }\n    }\n}\n","/**\n * Breadcrumb collector for tracking user actions\n *\n * ZERO-CONFIG ERROR CAPTURE:\n * When console.error() is called with an Error object, automatically\n * captures it and sends to API. This provides zero-config tracking for\n * the common pattern: .catch(err => console.error('Failed:', err))\n */\nexport class BreadcrumbCollector {\n    constructor(maxBreadcrumbs = 50, errorCaptureCallback = null) {\n        this.breadcrumbs = [];\n        this.maxBreadcrumbs = maxBreadcrumbs;\n        this.installed = false; // Track installation state\n        this.errorCaptureCallback = errorCaptureCallback; // Callback to capture errors automatically\n    }\n\n    /**\n   * Get className as string (handles both HTML and SVG elements)\n   * @param {Element} element - DOM element\n   * @returns {string} - className as string\n   */\n    getClassName(element) {\n        if (!element.className) return '';\n        // For SVG elements, className is an SVGAnimatedString\n        if (typeof element.className === 'object' && element.className.baseVal !== undefined) {\n            return element.className.baseVal;\n        }\n        // For HTML elements, className is a string\n        return element.className;\n    }\n\n    /**\n   * Install automatic breadcrumb tracking (idempotent)\n   */\n    install() {\n        // Guard against multiple installations\n        if (this.installed) {\n            return;\n        }\n\n        this.installed = true;\n\n        // Track clicks\n        document.addEventListener('click', (event) => {\n            const target = event.target;\n            const tagName = target.tagName.toLowerCase();\n            let message = `Clicked ${tagName}`;\n\n            const className = this.getClassName(target);\n\n            if (target.id) {\n                message += `#${target.id}`;\n            } else if (className) {\n                const firstClass = className.split(' ')[0];\n                if (firstClass) {\n                    message += `.${firstClass}`;\n                }\n            }\n\n            this.add({\n                type: 'ui',\n                category: 'click',\n                message,\n                data: {\n                    tag: tagName,\n                    id: target.id,\n                    class: className,\n                },\n            });\n        }, true);\n\n        // Track navigation\n        const originalPushState = history.pushState;\n        const originalReplaceState = history.replaceState;\n\n        history.pushState = (...args) => {\n            this.add({\n                type: 'navigation',\n                category: 'navigation',\n                message: `Navigated to ${args[2]}`,\n                data: { to: args[2] },\n            });\n            return originalPushState.apply(history, args);\n        };\n\n        history.replaceState = (...args) => {\n            this.add({\n                type: 'navigation',\n                category: 'navigation',\n                message: `Replaced state ${args[2]}`,\n                data: { to: args[2] },\n            });\n            return originalReplaceState.apply(history, args);\n        };\n\n        // Track console messages\n        this.wrapConsole();\n\n        // Track fetch requests\n        this.wrapFetch();\n    }\n\n    /**\n   * Add a breadcrumb\n   */\n    add(breadcrumb) {\n        this.breadcrumbs.push({\n            timestamp: new Date().toISOString(),\n            level: breadcrumb.level || 'info',\n            ...breadcrumb,\n        });\n\n        // Limit breadcrumbs\n        if (this.breadcrumbs.length > this.maxBreadcrumbs) {\n            this.breadcrumbs.shift();\n        }\n    }\n\n    /**\n   * Get all breadcrumbs\n   */\n    get() {\n        return this.breadcrumbs;\n    }\n\n    /**\n   * Clear breadcrumbs\n   */\n    clear() {\n        this.breadcrumbs = [];\n    }\n\n    /**\n   * Wrap console methods for breadcrumb tracking\n   *\n   * CRITICAL: Original console method is called FIRST to ensure console works\n   * even if breadcrumb tracking fails. Breadcrumb logic is wrapped in try-catch\n   * to prevent any failures from breaking console functionality.\n   *\n   * ZERO-CONFIG ERROR CAPTURE:\n   * When console.error() is called with an Error object, automatically captures\n   * it via errorCaptureCallback. This enables zero-config error tracking for the\n   * common pattern: .catch(err => console.error('message', err))\n   */\n    wrapConsole() {\n        const levels = ['log', 'info', 'warn', 'error', 'debug'];\n\n        levels.forEach(level => {\n            // eslint-disable-next-line no-console\n            const original = console[level];\n\n            // Safety check - ensure original is a function\n            if (typeof original !== 'function') {\n                return; // Skip this level if not a function\n            }\n\n            // eslint-disable-next-line no-console\n            console[level] = (...args) => {\n                // ZERO-CONFIG ERROR CAPTURE (BEFORE console output)\n                // Must happen BEFORE original.apply to avoid recursion issues\n                if (level === 'error' && this.errorCaptureCallback) {\n                    try {\n                        // Look for Error objects in arguments\n                        const errorObj = args.find(arg => arg instanceof Error);\n                        if (errorObj) {\n                            // Automatically capture this error\n                            if (typeof this.errorCaptureCallback === 'function') {\n                                this.errorCaptureCallback(errorObj, {\n                                    extra: {\n                                        consoleError: true,\n                                        consoleMessage: args.filter(arg => !(arg instanceof Error))\n                                            .map(arg => String(arg))\n                                            .join(' '),\n                                    },\n                                });\n                            }\n                        }\n                    } catch (captureError) {\n                        // Log the actual error instead of silently failing\n                        // Use native console to avoid recursion\n                        if (typeof original === 'function') {\n                            try {\n                                original.call(console, 'ApplicationLogger: Failed to auto-capture error:', captureError);\n                            } catch {\n                                // Absolute last resort - do nothing\n                            }\n                        }\n                    }\n                }\n\n                let result;\n\n                // Call original console method\n                try {\n                    result = original.apply(console, args);\n                } catch {\n                    // Native console threw (very rare) - fail silently\n                    // Don't rethrow - would break all console calls\n                }\n\n                // Then try to add breadcrumb (wrapped in try-catch)\n                try {\n                    // Safely serialize arguments to prevent:\n                    // - toString() errors\n                    // - Circular reference errors\n                    // - Non-serializable objects (DOM nodes, functions)\n                    const safeArgs = args.map(arg => {\n                        if (arg === null) return 'null';\n                        if (arg === undefined) return 'undefined';\n\n                        // Special handling for Error objects\n                        if (arg instanceof Error) {\n                            return `${arg.name}: ${arg.message}`;\n                        }\n\n                        // Handle objects (try JSON serialization, fallback to string)\n                        if (typeof arg === 'object') {\n                            try {\n                                return JSON.stringify(arg);\n                            } catch {\n                                // Circular reference or non-serializable\n                                return Object.prototype.toString.call(arg);\n                            }\n                        }\n\n                        // Primitives\n                        return String(arg);\n                    });\n\n                    this.add({\n                        type: 'console',\n                        category: 'console',\n                        message: safeArgs.join(' '),\n                        level: level === 'log' ? 'info' : level,\n                        data: { arguments: safeArgs },\n                    });\n                } catch {\n                    // Never crash breadcrumb tracking\n                    // Don't use console.error here to avoid infinite recursion\n                    // Silently fail - breadcrumb loss is better than breaking console\n                }\n\n                return result;\n            };\n        });\n    }\n\n    /**\n   * Wrap fetch for HTTP request breadcrumbs\n   */\n    wrapFetch() {\n        const originalFetch = window.fetch;\n\n        window.fetch = async (...args) => {\n            const url = typeof args[0] === 'string' ? args[0] : args[0].url;\n            const method = args[1]?.method || 'GET';\n            const startTime = Date.now();\n\n            try {\n                const response = await originalFetch.apply(window, args);\n                const duration = Date.now() - startTime;\n\n                this.add({\n                    type: 'http',\n                    category: 'fetch',\n                    message: `${method} ${url}`,\n                    data: {\n                        url,\n                        method,\n                        status_code: response.status,\n                        duration,\n                    },\n                    level: response.ok ? 'info' : 'warning',\n                });\n\n                return response;\n            } catch (error) {\n                const duration = Date.now() - startTime;\n\n                this.add({\n                    type: 'http',\n                    category: 'fetch',\n                    message: `${method} ${url} failed`,\n                    data: {\n                        url,\n                        method,\n                        error: error.message,\n                        duration,\n                    },\n                    level: 'error',\n                });\n\n                throw error;\n            }\n        };\n    }\n}\n","/**\n * Circuit Breaker for JavaScript\n *\n * Implements the circuit breaker pattern to prevent repeated calls to a failing service.\n * Uses sessionStorage to persist state across page reloads within the same session.\n *\n * States:\n * - CLOSED: Normal operation, requests go through\n * - OPEN: Service is down, requests are blocked immediately\n * - HALF_OPEN: Testing if service has recovered\n *\n * @example\n * const breaker = new CircuitBreaker({ failureThreshold: 5, timeout: 60000 });\n * if (!breaker.isOpen()) {\n *   try {\n *     await sendRequest();\n *     breaker.recordSuccess();\n *   } catch (error) {\n *     breaker.recordFailure();\n *   }\n * }\n */\nexport class CircuitBreaker {\n    /** @type {string} Circuit is functioning normally */\n    static STATE_CLOSED = 'closed';\n    /** @type {string} Circuit is open, blocking requests */\n    static STATE_OPEN = 'open';\n    /** @type {string} Circuit is testing if service recovered */\n    static STATE_HALF_OPEN = 'half_open';\n\n    /**\n     * Create a new CircuitBreaker instance\n     *\n     * @param {Object} [config={}] - Configuration options\n     * @param {number} [config.failureThreshold=5] - Number of failures before opening circuit\n     * @param {number} [config.timeout=60000] - Milliseconds before attempting reset (default 60s)\n     */\n    constructor(config = {}) {\n        /** @type {number} */\n        this.failureThreshold = config.failureThreshold || 5;\n        /** @type {number} */\n        this.timeout = config.timeout || 60000;\n        /** @type {string} */\n        this.storageKey = 'app_logger_circuit_breaker';\n\n        this.loadState();\n    }\n\n    /**\n     * Check if circuit is open (service down, reject requests)\n     *\n     * Also triggers transition from OPEN to HALF_OPEN if timeout has elapsed.\n     *\n     * @returns {boolean} True if circuit is open and requests should be blocked\n     */\n    isOpen() {\n        // Check if we should transition from OPEN to HALF_OPEN\n        if (this.state === CircuitBreaker.STATE_OPEN && this.shouldAttemptReset()) {\n            this.halfOpen();\n        }\n\n        return this.state === CircuitBreaker.STATE_OPEN;\n    }\n\n    /**\n     * Check if circuit is in half-open state (testing recovery)\n     *\n     * @returns {boolean} True if circuit is half-open\n     */\n    isHalfOpen() {\n        return this.state === CircuitBreaker.STATE_HALF_OPEN;\n    }\n\n    /**\n     * Record a successful request\n     *\n     * In HALF_OPEN state, closes the circuit (service recovered).\n     * In CLOSED state, resets failure count.\n     *\n     * @returns {void}\n     */\n    recordSuccess() {\n        if (this.state === CircuitBreaker.STATE_HALF_OPEN) {\n            // Success in half-open = circuit closes (service recovered)\n            this.close();\n        } else if (this.state === CircuitBreaker.STATE_CLOSED) {\n            // Reset failure count on success\n            this.failureCount = 0;\n            this.saveState();\n        }\n    }\n\n    /**\n     * Record a failed request\n     *\n     * In HALF_OPEN state, reopens the circuit.\n     * In CLOSED state, increments failure count and opens circuit if threshold reached.\n     *\n     * @returns {void}\n     */\n    recordFailure() {\n        if (this.state === CircuitBreaker.STATE_HALF_OPEN) {\n            // Failure in half-open = circuit opens again\n            this.open();\n        } else if (this.state === CircuitBreaker.STATE_CLOSED) {\n            this.failureCount++;\n\n            if (this.failureCount >= this.failureThreshold) {\n                this.open();\n            } else {\n                this.saveState();\n            }\n        }\n    }\n\n    /**\n     * Get current state for monitoring/debugging\n     *\n     * @returns {{state: string, failureCount: number, openedAt: number|null}} Current circuit state\n     */\n    getState() {\n        return {\n            state: this.state,\n            failureCount: this.failureCount,\n            openedAt: this.openedAt,\n        };\n    }\n\n    /**\n     * Manually reset circuit breaker to CLOSED state\n     *\n     * @returns {void}\n     */\n    reset() {\n        this.close();\n    }\n\n    /**\n     * Transition to CLOSED state (internal)\n     *\n     * @private\n     * @returns {void}\n     */\n    close() {\n        this.state = CircuitBreaker.STATE_CLOSED;\n        this.failureCount = 0;\n        this.openedAt = null;\n        this.saveState();\n    }\n\n    /**\n     * Transition to OPEN state (internal)\n     *\n     * @private\n     * @returns {void}\n     */\n    open() {\n        this.state = CircuitBreaker.STATE_OPEN;\n        this.openedAt = Date.now();\n        this.saveState();\n    }\n\n    /**\n     * Transition to HALF_OPEN state (internal)\n     *\n     * @private\n     * @returns {void}\n     */\n    halfOpen() {\n        this.state = CircuitBreaker.STATE_HALF_OPEN;\n        this.saveState();\n    }\n\n    /**\n     * Check if enough time has passed to attempt reset (internal)\n     *\n     * @private\n     * @returns {boolean} True if timeout has elapsed since circuit opened\n     */\n    shouldAttemptReset() {\n        if (!this.openedAt) {\n            return false;\n        }\n\n        return (Date.now() - this.openedAt) >= this.timeout;\n    }\n\n    /**\n     * Load state from sessionStorage (internal)\n     *\n     * @private\n     * @returns {void}\n     */\n    loadState() {\n        try {\n            const stored = sessionStorage.getItem(this.storageKey);\n\n            if (stored) {\n                const state = JSON.parse(stored);\n                this.state = state.state || CircuitBreaker.STATE_CLOSED;\n                this.failureCount = state.failureCount || 0;\n                this.openedAt = state.openedAt || null;\n            } else {\n                this.state = CircuitBreaker.STATE_CLOSED;\n                this.failureCount = 0;\n                this.openedAt = null;\n            }\n        } catch {\n            // If storage fails, default to closed state\n            this.state = CircuitBreaker.STATE_CLOSED;\n            this.failureCount = 0;\n            this.openedAt = null;\n        }\n    }\n\n    /**\n     * Save state to sessionStorage (internal)\n     *\n     * @private\n     * @returns {void}\n     */\n    saveState() {\n        try {\n            const state = {\n                state: this.state,\n                failureCount: this.failureCount,\n                openedAt: this.openedAt,\n            };\n\n            sessionStorage.setItem(this.storageKey, JSON.stringify(state));\n        } catch {\n            // Storage failure should never crash the app\n            // Circuit breaker still works in-memory for this page\n        }\n    }\n}\n","/**\n * Local Storage Queue for JavaScript\n *\n * Buffers failed error submissions in localStorage for later retry.\n * Used when the API is unreachable or circuit breaker is open.\n *\n * Features:\n * - FIFO queue with size limits\n * - Automatic expiration of old errors\n * - Safe storage operations (never crash on quota exceeded)\n *\n * @example\n * const queue = new StorageQueue({ maxSize: 50, maxAge: 86400000 });\n * queue.enqueue({ message: 'Error', stack: '...' });\n * const error = queue.dequeue(); // Returns oldest error or null\n */\nexport class StorageQueue {\n    /**\n     * Create a new StorageQueue instance\n     *\n     * @param {Object} [config={}] - Configuration options\n     * @param {number} [config.maxSize=50] - Maximum items to store\n     * @param {number} [config.maxAge=86400000] - Maximum age in ms (default 24h)\n     */\n    constructor(config = {}) {\n        /** @type {string} localStorage key for the queue */\n        this.storageKey = 'app_logger_queue';\n        /** @type {number} Maximum items to store */\n        this.maxSize = config.maxSize || 50;\n        /** @type {number} Maximum age in milliseconds */\n        this.maxAge = config.maxAge || 86400000;\n    }\n\n    /**\n     * Add an error to the queue\n     *\n     * Adds the payload with a timestamp for expiration tracking.\n     * Automatically removes oldest items if maxSize is exceeded.\n     *\n     * @param {Object} payload - Error data to queue\n     * @returns {void}\n     */\n    enqueue(payload) {\n        try {\n            const queue = this.getQueue();\n\n            // Add timestamp for expiration\n            const item = {\n                payload,\n                timestamp: Date.now(),\n            };\n\n            queue.push(item);\n\n            // Limit queue size (FIFO - remove oldest)\n            if (queue.length > this.maxSize) {\n                queue.shift();\n            }\n\n            this.saveQueue(queue);\n        } catch (error) {\n            // Storage failures should never crash the app\n            // Common causes: quota exceeded, private browsing mode\n            console.warn('ApplicationLogger: Failed to queue error', error);\n        }\n    }\n\n    /**\n     * Get and remove next error from queue (FIFO)\n     *\n     * @returns {Object|null} Oldest queued payload, or null if empty\n     */\n    dequeue() {\n        try {\n            const queue = this.getQueue();\n\n            if (queue.length === 0) {\n                return null;\n            }\n\n            const item = queue.shift();\n            this.saveQueue(queue);\n\n            return item.payload;\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Get all queued errors without removing them\n     *\n     * @returns {Object[]} Array of queued payloads\n     */\n    getAll() {\n        const queue = this.getQueue();\n        return queue.map(item => item.payload);\n    }\n\n    /**\n     * Get current queue size\n     *\n     * @returns {number} Number of items in queue\n     */\n    size() {\n        const queue = this.getQueue();\n        return queue.length;\n    }\n\n    /**\n     * Clear all items from the queue\n     *\n     * @returns {void}\n     */\n    clear() {\n        try {\n            localStorage.removeItem(this.storageKey);\n        } catch {\n            // Ignore\n        }\n    }\n\n    /**\n     * Get queue from localStorage with expiration cleanup (internal)\n     *\n     * Automatically removes expired items based on maxAge.\n     *\n     * @private\n     * @returns {Array<{payload: Object, timestamp: number}>} Queue items with metadata\n     */\n    getQueue() {\n        try {\n            const stored = localStorage.getItem(this.storageKey);\n\n            if (!stored) {\n                return [];\n            }\n\n            const queue = JSON.parse(stored);\n\n            if (!Array.isArray(queue)) {\n                return [];\n            }\n\n            // Remove expired items\n            const now = Date.now();\n            const filtered = queue.filter(item => {\n                return item.timestamp && (now - item.timestamp) < this.maxAge;\n            });\n\n            // If we removed expired items, save the cleaned queue\n            if (filtered.length !== queue.length) {\n                this.saveQueue(filtered);\n            }\n\n            return filtered;\n        } catch {\n            return [];\n        }\n    }\n\n    /**\n     * Save queue to localStorage (internal)\n     *\n     * Handles QuotaExceededError by trimming oldest items.\n     *\n     * @private\n     * @param {Array<{payload: Object, timestamp: number}>} queue - Queue items to save\n     * @returns {void}\n     */\n    saveQueue(queue) {\n        try {\n            localStorage.setItem(this.storageKey, JSON.stringify(queue));\n        } catch (error) {\n            // Handle quota exceeded or other storage errors\n            if (error.name === 'QuotaExceededError') {\n                // Try to make space by removing oldest items\n                const halfSize = Math.floor(queue.length / 2);\n                const trimmed = queue.slice(-halfSize);\n\n                try {\n                    localStorage.setItem(this.storageKey, JSON.stringify(trimmed));\n                } catch {\n                    // If still failing, clear the queue\n                    this.clear();\n                }\n            }\n        }\n    }\n}\n","/**\n * Rate Limiter for JavaScript\n *\n * Prevents error storms by limiting the number of errors sent per minute.\n * Uses token bucket algorithm for smooth rate limiting.\n *\n * This is critical for resilience - prevents overwhelming the API\n * and consuming excessive bandwidth during error cascades.\n *\n * @example\n * const limiter = new RateLimiter({ maxTokens: 10, refillRate: 1 });\n * if (limiter.consume()) {\n *   await sendError(error);\n * } else {\n *   queue.enqueue(error); // Rate limited, queue for later\n * }\n */\nexport class RateLimiter {\n    /**\n     * Create a new RateLimiter instance\n     *\n     * @param {Object} [config={}] - Configuration options\n     * @param {number} [config.maxTokens=10] - Maximum tokens (burst capacity)\n     * @param {number} [config.refillRate=1] - Tokens added per second\n     */\n    constructor(config = {}) {\n        /** @type {number} Maximum tokens (burst capacity) */\n        this.maxTokens = config.maxTokens || 10;\n        /** @type {number} Tokens added per second */\n        this.refillRate = config.refillRate || 1;\n        /** @type {number} Current available tokens */\n        this.tokens = this.maxTokens;\n        /** @type {number} Timestamp of last refill */\n        this.lastRefill = Date.now();\n    }\n\n    /**\n     * Check if request is allowed (without consuming a token)\n     *\n     * @returns {boolean} True if tokens are available\n     */\n    isAllowed() {\n        this.refillTokens();\n        return this.tokens > 0;\n    }\n\n    /**\n     * Consume a token (record an error sent)\n     *\n     * Call this when successfully sending an error to track rate limits.\n     *\n     * @returns {boolean} True if token was consumed, false if rate limited\n     */\n    consume() {\n        if (!this.isAllowed()) {\n            return false;\n        }\n\n        this.tokens--;\n        return true;\n    }\n\n    /**\n     * Refill tokens based on time elapsed (internal)\n     *\n     * Called automatically by isAllowed() and getTokens().\n     * Adds tokens based on elapsed time since last refill.\n     *\n     * @private\n     * @returns {void}\n     */\n    refillTokens() {\n        const now = Date.now();\n        const elapsed = (now - this.lastRefill) / 1000; // Convert to seconds\n        const tokensToAdd = Math.floor(elapsed * this.refillRate);\n\n        if (tokensToAdd > 0) {\n            this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);\n            this.lastRefill = now;\n        }\n    }\n\n    /**\n     * Get current token count (for debugging/monitoring)\n     *\n     * @returns {number} Current available tokens\n     */\n    getTokens() {\n        this.refillTokens();\n        return this.tokens;\n    }\n\n    /**\n     * Reset rate limiter to full capacity\n     *\n     * Restores all tokens and resets the refill timer.\n     *\n     * @returns {void}\n     */\n    reset() {\n        this.tokens = this.maxTokens;\n        this.lastRefill = Date.now();\n    }\n}\n","import { CircuitBreaker } from './circuit-breaker.js';\nimport { StorageQueue } from './storage-queue.js';\nimport { RateLimiter } from './rate-limiter.js';\n\n/**\n * Transport layer for sending errors to the platform\n *\n * RESILIENCE FEATURES:\n * - 3-second timeout with AbortController\n * - Circuit breaker prevents repeated calls to failing service\n * - Smart retry with exponential backoff\n * - Local storage queue for offline errors\n * - Rate limiting to prevent error storms\n * - Deduplication to avoid duplicate errors\n */\nexport class Transport {\n    constructor(config) {\n        this.config = config;\n        this.apiKey = config.apiKey; // Store API key separately (not in DSN)\n        this.dsn = this.parseDsn(config.dsn);\n        this.queue = [];\n        this.sending = false;\n\n        // Initialize resilience components (configurable via SDK config)\n        this.circuitBreaker = new CircuitBreaker({\n            failureThreshold: config.circuitBreakerFailureThreshold ?? 5,\n            timeout: config.circuitBreakerTimeoutMs ?? 60000,\n        });\n\n        this.storageQueue = new StorageQueue({\n            maxSize: config.storageQueueMaxSize ?? 50,\n            maxAge: config.storageQueueMaxAgeMs ?? 86400000,\n        });\n\n        this.rateLimiter = new RateLimiter({\n            maxTokens: config.rateLimiterMaxTokens ?? 10,\n            refillRate: config.rateLimiterRefillRate ?? 0.167,\n        });\n\n        // Deduplication cache (configurable via SDK config)\n        this.recentErrors = new Map();\n        this.deduplicationWindow = config.deduplicationWindowMs ?? 5000;\n\n        // Try to flush stored errors on init\n        this.flushStoredErrors();\n    }\n\n    /**\n   * Parse DSN into components\n   *\n   * DSN format: {protocol}://{host}/{projectId}\n   * Example: https://localhost:8111/b6d8ed85-c0af-4c02-b6bb-bfb0f3609b37\n   *\n   * Note: API key is NOT in the DSN. It's passed separately via config.apiKey.\n   */\n    parseDsn(dsn) {\n        if (!dsn) {\n            throw new Error('DSN is required');\n        }\n\n        try {\n            const url = new URL(dsn);\n            const projectId = url.pathname.replace(/^\\//, ''); // Remove leading slash\n\n            if (!projectId) {\n                throw new Error('DSN must include a project ID in the path');\n            }\n\n            return {\n                protocol: url.protocol.replace(':', ''),\n                host: url.host,\n                projectId: projectId,\n                endpoint: `${url.protocol}//${url.host}/api/errors/ingest`,\n            };\n        } catch (error) {\n            throw new Error(`Invalid DSN format: ${error.message}. Expected: https://host/project-id`);\n        }\n    }\n\n    /**\n   * Send error payload to platform\n   *\n   * @param {Object} payload - Error payload\n   * @param {Object|null} replayData - Optional session replay data\n   * @param {string} replayData.sessionId - Session ID from SessionManager\n   * @param {Array} replayData.events - Buffered events (before + after error)\n   */\n    async send(payload, replayData = null) {\n        try {\n            // Merge replay data into payload if provided\n            let enhancedPayload = payload;\n            if (replayData) {\n                enhancedPayload = {\n                    ...payload,\n                    replay_session_id: replayData.sessionId,\n                    replay_data: replayData.events,\n                };\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Sending error with replay data', {\n                        sessionId: replayData.sessionId,\n                        eventCount: replayData.events?.length || 0,\n                    });\n                }\n            }\n\n            // Scrub sensitive data\n            const scrubbedPayload = this.scrubSensitiveData(enhancedPayload);\n\n            // Check for duplicates\n            if (this.isDuplicate(scrubbedPayload)) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Duplicate error ignored');\n                }\n                return;\n            }\n\n            // Check rate limit\n            if (!this.rateLimiter.consume()) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Rate limit exceeded, error queued');\n                }\n                this.storageQueue.enqueue(scrubbedPayload);\n                return;\n            }\n\n            // Add to queue\n            this.queue.push(scrubbedPayload);\n\n            // Process queue\n            if (!this.sending) {\n                await this.processQueue();\n            }\n        } catch (error) {\n            // Never crash on send errors\n            console.error('ApplicationLogger: Send failed', error);\n        }\n    }\n\n    /**\n     * Send recovery session (Phase 2 of two-phase session replay)\n     *\n     * This is sent separately after the initial error + pre-error data.\n     * Recovery sessions show user actions AFTER the error occurred.\n     *\n     * @param {Object} recoveryPayload - Recovery session payload\n     * @param {string} recoveryPayload.sessionId - Session ID\n     * @param {Array} recoveryPayload.events - Recovery events (after error)\n     * @param {string} [recoveryPayload.capturedAt] - ISO 8601 timestamp\n     * @param {string} [recoveryPayload.url] - Current URL\n     * @param {boolean} [useBeacon=false] - Use sendBeacon API for reliable unload transmission\n     */\n    async sendRecoverySession(recoveryPayload, useBeacon = false) {\n        try {\n            // Use dedicated recovery session endpoint\n            const endpoint = `${this.dsn.protocol}://${this.dsn.host}/api/errors/recovery-session`;\n\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Sending recovery session', {\n                    sessionId: recoveryPayload.sessionId,\n                    eventCount: recoveryPayload.events?.length || 0,\n                    method: useBeacon ? 'sendBeacon' : 'fetch',\n                });\n            }\n\n            // Use sendBeacon for page unload (synchronous, guaranteed delivery)\n            if (useBeacon && navigator.sendBeacon) {\n                // sendBeacon cannot send custom headers, so include API key in body\n                const payloadWithAuth = {\n                    ...recoveryPayload,\n                    apiKey: this.apiKey,\n                };\n\n                const blob = new Blob([JSON.stringify(payloadWithAuth)], {\n                    type: 'application/json',\n                });\n\n                const sent = navigator.sendBeacon(endpoint, blob);\n\n                if (sent) {\n                    if (this.config.debug) {\n                        console.warn('ApplicationLogger: Recovery session queued via sendBeacon');\n                    }\n                    return { success: true, method: 'beacon' };\n                } else {\n                    throw new Error('sendBeacon failed (queue full or too large)');\n                }\n            }\n\n            // Fallback to fetch (normal case)\n            // Create AbortController for timeout\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), 5000); // 5-second timeout (longer for recovery)\n\n            const response = await fetch(endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey,\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify(recoveryPayload),\n                signal: controller.signal,\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                throw new Error(`Recovery session send failed: ${response.status}`);\n            }\n\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Recovery session sent successfully');\n            }\n\n            return response.json();\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to send recovery session', error);\n\n            // Store in queue for retry (best effort)\n            try {\n                this.storageQueue.enqueue({\n                    type: 'recovery',\n                    payload: recoveryPayload,\n                });\n            } catch (queueError) {\n                console.error('ApplicationLogger: Failed to queue recovery session', queueError);\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n   * Process queued errors\n   */\n    async processQueue() {\n        if (this.queue.length === 0 || this.sending) {\n            return;\n        }\n\n        this.sending = true;\n\n        while (this.queue.length > 0) {\n            const payload = this.queue.shift();\n\n            try {\n                await this.sendToApi(payload);\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Error sent successfully');\n                }\n            } catch {\n                // Error already handled in sendToApi\n                // Don't re-queue here as sendToApi handles storage\n            }\n        }\n\n        this.sending = false;\n    }\n\n    /**\n   * Send payload to API with timeout and retry\n   */\n    async sendToApi(payload, attempt = 0) {\n        // Check circuit breaker\n        if (this.circuitBreaker.isOpen()) {\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Circuit breaker is open, error queued to storage');\n            }\n            this.storageQueue.enqueue(payload);\n            return;\n        }\n\n        // Create AbortController for timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 3000); // 3-second timeout\n\n        try {\n            const response = await fetch(this.dsn.endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey, // Use separate API key, not from DSN\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify(payload),\n                signal: controller.signal,\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n\n            // Success!\n            this.circuitBreaker.recordSuccess();\n\n            // Try to flush stored errors on success\n            this.flushStoredErrors();\n\n            return response.json();\n        } catch (error) {\n            clearTimeout(timeoutId);\n\n            // Handle timeout\n            if (error.name === 'AbortError') {\n                this.circuitBreaker.recordFailure();\n\n                if (this.config.debug) {\n                    console.error('ApplicationLogger: Request timeout');\n                }\n\n                this.storageQueue.enqueue(payload);\n                return;\n            }\n\n            // Handle network errors with retry\n            if (attempt < 2) {\n                // Exponential backoff: 1s, 2s\n                const delay = Math.pow(2, attempt) * 1000;\n                await this.delay(delay);\n\n                return this.sendToApi(payload, attempt + 1);\n            }\n\n            // Max retries reached\n            this.circuitBreaker.recordFailure();\n\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Max retries reached', error);\n            }\n\n            this.storageQueue.enqueue(payload);\n        }\n    }\n\n    /**\n   * Check if error is a duplicate\n   *\n   * Payload uses flat structure (not nested exception object):\n   * {type, message, file, line, stack_trace, ...}\n   */\n    isDuplicate(payload) {\n        try {\n            // Create hash from error signature (flat payload structure)\n            const signature = JSON.stringify({\n                type: payload.type,\n                message: payload.message,\n                stack: payload.stack_trace?.slice(0, 3), // Top 3 frames\n            });\n\n            const hash = this.simpleHash(signature);\n\n            // Check if we've seen this recently\n            if (this.recentErrors.has(hash)) {\n                return true;\n            }\n\n            // Add to recent errors\n            this.recentErrors.set(hash, Date.now());\n\n            // Clean up old entries\n            const now = Date.now();\n            for (const [key, timestamp] of this.recentErrors) {\n                if (now - timestamp > this.deduplicationWindow) {\n                    this.recentErrors.delete(key);\n                }\n            }\n\n            return false;\n        } catch {\n            return false; // If deduplication fails, allow the error through\n        }\n    }\n\n    /**\n   * Simple hash function\n   */\n    simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            const char = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // Convert to 32bit integer\n        }\n        return hash.toString();\n    }\n\n    /**\n   * Flush errors from storage queue\n   */\n    async flushStoredErrors() {\n        try {\n            const queueSize = this.storageQueue.size();\n\n            if (queueSize === 0) {\n                return;\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Flushing ${queueSize} stored errors`);\n            }\n\n            // Limit flush to 5 errors at a time to avoid overwhelming\n            const limit = Math.min(queueSize, 5);\n\n            for (let i = 0; i < limit; i++) {\n                const payload = this.storageQueue.dequeue();\n\n                if (payload) {\n                    // Add to queue (but don't recurse infinitely)\n                    this.queue.push(payload);\n                }\n            }\n\n            // Process the queue\n            if (!this.sending && this.queue.length > 0) {\n                await this.processQueue();\n            }\n        } catch (error) {\n            // Never crash on flush\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Flush failed', error);\n            }\n        }\n    }\n\n    /**\n   * Delay helper for retry backoff\n   */\n    delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    /**\n   * Scrub sensitive data from payload\n   */\n    scrubSensitiveData(payload) {\n        const scrubFields = this.config.scrubFields || [];\n        const scrubPatterns = [\n            ...scrubFields,\n            'password',\n            'passwd',\n            'pwd',\n            'secret',\n            'api_key',\n            'apikey',\n            'token',\n            'auth',\n            'authorization',\n            'private_key',\n            'access_token',\n            'refresh_token',\n        ];\n\n        // Deep clone payload (handle circular references)\n        let scrubbed;\n        try {\n            scrubbed = JSON.parse(JSON.stringify(payload));\n        } catch {\n            // Circular reference detected - work with original and remove circular refs\n            scrubbed = this.removeCircularReferences(payload);\n        }\n\n        // Recursively scrub object\n        const scrubObject = (obj) => {\n            if (!obj || typeof obj !== 'object') {\n                return obj;\n            }\n\n            for (const key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    // Check if key matches scrub pattern\n                    const shouldScrub = scrubPatterns.some(pattern =>\n                        key.toLowerCase().includes(pattern.toLowerCase()),\n                    );\n\n                    if (shouldScrub) {\n                        obj[key] = '[REDACTED]';\n                    } else if (typeof obj[key] === 'object') {\n                        scrubObject(obj[key]);\n                    }\n                }\n            }\n\n            return obj;\n        };\n\n        return scrubObject(scrubbed);\n    }\n\n    /**\n     * Remove circular references from an object.\n     * Uses a WeakSet to track visited objects and prevent infinite loops.\n     *\n     * @param {Object} obj - Object to process\n     * @param {WeakSet} [seen] - Set of already visited objects\n     * @returns {Object} Object with circular references replaced\n     */\n    removeCircularReferences(obj, seen = new WeakSet()) {\n        // Handle primitives and null\n        if (obj === null || typeof obj !== 'object') {\n            return obj;\n        }\n\n        // Handle circular reference\n        if (seen.has(obj)) {\n            return '[Circular Reference]';\n        }\n\n        // Add to seen set\n        seen.add(obj);\n\n        // Handle arrays\n        if (Array.isArray(obj)) {\n            return obj.map(item => this.removeCircularReferences(item, seen));\n        }\n\n        // Handle objects\n        const result = {};\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                try {\n                    result[key] = this.removeCircularReferences(obj[key], seen);\n                } catch {\n                    // Skip properties that throw errors when accessed\n                    result[key] = '[Error accessing property]';\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Send session event to API\n     */\n    async sendSessionEvent(sessionId, eventData) {\n        if (!sessionId || !eventData) {\n            return;\n        }\n\n        try {\n            const url = `${this.dsn.protocol}://${this.dsn.host}/api/v1/sessions/${sessionId}/events`;\n\n            const response = await fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey,\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify(eventData),\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}`);\n            }\n\n            return response.json();\n        } catch (error) {\n            // Silently fail - session tracking is non-critical\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Failed to send session event', error);\n            }\n        }\n    }\n\n    /**\n     * Send session replay click data to API (batch)\n     */\n    async sendReplayClicks(sessionId, clicks) {\n        if (!sessionId || !clicks || clicks.length === 0) {\n            return;\n        }\n\n        try {\n            const url = `${this.dsn.protocol}://${this.dsn.host}/api/v1/sessions/${sessionId}/replay`;\n\n            const response = await fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey,\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify({ clicks }),\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}`);\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Sent ${clicks.length} heatmap clicks`);\n            }\n\n            return response.json();\n        } catch (error) {\n            // Silently fail - heatmap tracking is non-critical\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Failed to send heatmap data', error);\n            }\n        }\n    }\n\n    /**\n   * Get stats for monitoring\n   */\n    getStats() {\n        return {\n            queueSize: this.queue.length,\n            storedErrors: this.storageQueue.size(),\n            circuitBreaker: this.circuitBreaker.getState(),\n            rateLimitTokens: this.rateLimiter.getTokens(),\n        };\n    }\n\n    /**\n   * Flush pending errors using Beacon API\n   * Called on page unload to ensure errors are sent even as page closes\n   */\n    flushWithBeacon() {\n        try {\n            // Get all stored errors (from offline queue)\n            const storedErrors = this.storageQueue.getAll();\n\n            // Also include current queue\n            const allErrors = [...this.queue, ...storedErrors];\n\n            if (allErrors.length === 0) {\n                return;\n            }\n\n            // Limit to 10 most recent errors to avoid payload size issues\n            const errorsToSend = allErrors.slice(-10);\n\n            // Beacon API has limitations with headers, so we include DSN in body\n            const beaconPayload = {\n                dsn: this.config.dsn,\n                errors: errorsToSend,\n            };\n\n            const blob = new Blob([JSON.stringify(beaconPayload)], {\n                type: 'application/json',\n            });\n\n            // Try to send via Beacon API\n            const sent = navigator.sendBeacon(this.dsn.endpoint, blob);\n\n            if (sent) {\n                // Successfully queued for sending\n                // Clear the storage queue and current queue\n                this.storageQueue.clear();\n                this.queue = [];\n\n                if (this.config.debug) {\n                    console.warn(`ApplicationLogger: Flushed ${errorsToSend.length} errors via Beacon API`);\n                }\n            }\n        } catch (error) {\n            // Beacon flush failed - errors remain in storage for next session\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Beacon flush failed', error);\n            }\n        }\n    }\n}\n","/**\n * DOM Serializer - Privacy-First Visual Structure Capture\n *\n * CRITICAL: This module captures ONLY visual DOM structure for session replay.\n * It is designed with privacy as the #1 priority.\n *\n *  WHAT IS CAPTURED:\n * - Element tag names (div, button, input, etc.)\n * - Bounding rectangles (x, y, width, height)\n * - Background colors (computed styles)\n * - Layout types (flex, grid, block, inline)\n * - Parent-child relationships (tree structure)\n *\n *  WHAT IS NEVER CAPTURED:\n * - Text content (NO textContent, innerText, innerHTML)\n * - Attribute values (NO id, class, href, src, data-*)\n * - Form values (NO input values, textarea, select options)\n * - User-generated content (NO comments, user text)\n * - Sensitive styles (NO font-family, content properties)\n * - URLs or file paths (NO src, href, background-image)\n *\n * PRIVACY GUARANTEE:\n * All data is sanitized client-side. The server receives ONLY:\n * - Visual block structure (colored rectangles)\n * - Element types (for rendering context)\n * - Layout information (for accurate replay)\n *\n * This allows session replay visualization without exposing any user data.\n */\nexport class DOMSerializer {\n    constructor(options = {}) {\n        this.maxDepth = options.maxDepth || 10; // Prevent deep recursion\n        this.minSize = options.minSize || 5; // Skip tiny elements (px)\n        this.skipInvisible = options.skipInvisible !== false; // Skip hidden elements\n        this.captureColors = options.captureColors !== false; // Capture bg colors\n        this.debug = options.debug || false;\n\n        // Performance tracking\n        this.stats = {\n            totalElements: 0,\n            skippedInvisible: 0,\n            skippedTiny: 0,\n            skippedNonVisual: 0,\n            maxDepthReached: 0,\n        };\n    }\n\n    /**\n     * Serialize the current DOM tree to a privacy-safe structure.\n     *\n     * @param {Element} [rootElement=document.body] - Root element to serialize\n     * @returns {Object} Serialized DOM structure\n     */\n    serialize(rootElement = document.body) {\n        // Reset stats\n        this.stats = {\n            totalElements: 0,\n            skippedInvisible: 0,\n            skippedTiny: 0,\n            skippedNonVisual: 0,\n            maxDepthReached: 0,\n        };\n\n        const startTime = performance.now();\n\n        try {\n            // Get viewport dimensions for context\n            const viewport = {\n                width: window.innerWidth,\n                height: window.innerHeight,\n                scrollX: window.scrollX,\n                scrollY: window.scrollY,\n            };\n\n            // Serialize the tree\n            const tree = this.serializeElement(rootElement, 0);\n\n            const elapsed = performance.now() - startTime;\n\n            if (this.debug) {\n                console.warn('DOM Serialization Stats:', {\n                    ...this.stats,\n                    elapsedMs: elapsed.toFixed(2),\n                });\n            }\n\n            return {\n                viewport,\n                tree,\n                timestamp: Date.now(),\n                stats: this.stats,\n            };\n        } catch (error) {\n            console.error('DOM serialization failed:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Serialize a single element and its children recursively.\n     *\n     * @private\n     * @param {Element} element - Element to serialize\n     * @param {number} depth - Current recursion depth\n     * @returns {Object|null} Serialized element or null if skipped\n     */\n    serializeElement(element, depth) {\n        // Check depth limit\n        if (depth >= this.maxDepth) {\n            this.stats.maxDepthReached++;\n            return null;\n        }\n\n        // Skip non-visual elements\n        if (this.isNonVisualElement(element)) {\n            this.stats.skippedNonVisual++;\n            return null;\n        }\n\n        // Get computed style (for visibility and color)\n        const style = window.getComputedStyle(element);\n\n        // Skip invisible elements\n        if (this.skipInvisible && this.isInvisible(element, style)) {\n            this.stats.skippedInvisible++;\n            return null;\n        }\n\n        // Get bounding rectangle\n        const rect = element.getBoundingClientRect();\n\n        // Skip tiny elements (noise)\n        if (rect.width < this.minSize || rect.height < this.minSize) {\n            this.stats.skippedTiny++;\n            return null;\n        }\n\n        this.stats.totalElements++;\n\n        // Build serialized element\n        const serialized = {\n            // Element type (tag name)\n            type: element.tagName.toLowerCase(),\n\n            // Bounding box (relative to viewport)\n            bounds: {\n                x: Math.round(rect.left + window.scrollX),\n                y: Math.round(rect.top + window.scrollY),\n                width: Math.round(rect.width),\n                height: Math.round(rect.height),\n            },\n\n            // Visual properties\n            bgColor: this.captureColors ? this.extractBackgroundColor(style) : null,\n            layout: this.detectLayoutType(style),\n\n            // Meta information (for better rendering)\n            isInteractive: this.isInteractive(element),\n            isText: this.isTextContainer(element),\n        };\n\n        // Serialize children recursively\n        const children = [];\n        const childElements = Array.from(element.children);\n\n        for (const child of childElements) {\n            const serializedChild = this.serializeElement(child, depth + 1);\n            if (serializedChild) {\n                children.push(serializedChild);\n            }\n        }\n\n        if (children.length > 0) {\n            serialized.children = children;\n        }\n\n        return serialized;\n    }\n\n    /**\n     * Check if element is non-visual (script, style, etc.).\n     *\n     * @private\n     * @param {Element} element\n     * @returns {boolean}\n     */\n    isNonVisualElement(element) {\n        const nonVisualTags = [\n            'SCRIPT',\n            'STYLE',\n            'LINK',\n            'META',\n            'NOSCRIPT',\n            'TITLE',\n            'HEAD',\n            'BASE',\n        ];\n\n        return nonVisualTags.includes(element.tagName);\n    }\n\n    /**\n     * Check if element is invisible (display:none, visibility:hidden, etc.).\n     *\n     * @private\n     * @param {Element} element\n     * @param {CSSStyleDeclaration} style - Computed style\n     * @returns {boolean}\n     */\n    isInvisible(element, style) {\n        // Display none\n        if (style.display === 'none') {\n            return true;\n        }\n\n        // Visibility hidden\n        if (style.visibility === 'hidden') {\n            return true;\n        }\n\n        // Fully transparent\n        if (parseFloat(style.opacity) === 0) {\n            return true;\n        }\n\n        // Outside viewport (way off-screen)\n        const rect = element.getBoundingClientRect();\n        if (\n            rect.bottom < -1000 ||\n            rect.top > window.innerHeight + 1000 ||\n            rect.right < -1000 ||\n            rect.left > window.innerWidth + 1000\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Extract background color from computed style (privacy-safe).\n     *\n     * @private\n     * @param {CSSStyleDeclaration} style\n     * @returns {string|null} Hex color or null\n     */\n    extractBackgroundColor(style) {\n        try {\n            const bgColor = style.backgroundColor;\n\n            // Skip transparent\n            if (!bgColor || bgColor === 'transparent' || bgColor === 'rgba(0, 0, 0, 0)') {\n                return null;\n            }\n\n            // Convert to hex (simpler storage)\n            return this.rgbToHex(bgColor);\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Convert RGB/RGBA color to hex format.\n     *\n     * @private\n     * @param {string} rgb - RGB/RGBA color string\n     * @returns {string|null} Hex color\n     */\n    rgbToHex(rgb) {\n        try {\n            // Match rgb(r, g, b) or rgba(r, g, b, a)\n            const match = rgb.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*[\\d.]+)?\\)/);\n            if (!match) {\n                return null;\n            }\n\n            const r = parseInt(match[1], 10);\n            const g = parseInt(match[2], 10);\n            const b = parseInt(match[3], 10);\n\n            // Convert to hex\n            const toHex = (n) => {\n                const hex = n.toString(16);\n                return hex.length === 1 ? '0' + hex : hex;\n            };\n\n            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Detect layout type (flex, grid, block, inline).\n     *\n     * @private\n     * @param {CSSStyleDeclaration} style\n     * @returns {string}\n     */\n    detectLayoutType(style) {\n        const display = style.display;\n\n        if (display.includes('flex')) {\n            return 'flex';\n        }\n\n        if (display.includes('grid')) {\n            return 'grid';\n        }\n\n        if (display === 'inline' || display === 'inline-block') {\n            return 'inline';\n        }\n\n        return 'block';\n    }\n\n    /**\n     * Check if element is interactive (button, link, input, etc.).\n     *\n     * @private\n     * @param {Element} element\n     * @returns {boolean}\n     */\n    isInteractive(element) {\n        const interactiveTags = [\n            'A',\n            'BUTTON',\n            'INPUT',\n            'SELECT',\n            'TEXTAREA',\n            'LABEL',\n        ];\n\n        if (interactiveTags.includes(element.tagName)) {\n            return true;\n        }\n\n        // Check for click handlers (heuristic)\n        if (element.onclick || element.hasAttribute('onclick')) {\n            return true;\n        }\n\n        // Check for cursor pointer\n        const style = window.getComputedStyle(element);\n        if (style.cursor === 'pointer') {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if element is a text container (p, span, h1-h6, etc.).\n     *\n     * @private\n     * @param {Element} element\n     * @returns {boolean}\n     */\n    isTextContainer(element) {\n        const textTags = [\n            'P',\n            'SPAN',\n            'H1',\n            'H2',\n            'H3',\n            'H4',\n            'H5',\n            'H6',\n            'LI',\n            'LABEL',\n            'TD',\n            'TH',\n            'CODE',\n            'PRE',\n        ];\n\n        return textTags.includes(element.tagName);\n    }\n\n    /**\n     * Get statistics about the last serialization.\n     *\n     * @returns {Object} Statistics\n     */\n    getStats() {\n        return { ...this.stats };\n    }\n\n    /**\n     * Calculate approximate payload size (for debugging).\n     *\n     * @param {Object} serialized - Serialized DOM structure\n     * @returns {number} Approximate size in bytes\n     */\n    estimateSize(serialized) {\n        try {\n            const json = JSON.stringify(serialized);\n            return json.length;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Compress serialized structure (remove nulls, optimize).\n     *\n     * @param {Object} serialized - Serialized DOM structure\n     * @returns {Object} Compressed structure\n     */\n    compress(serialized) {\n        // Remove null/undefined values\n        const removeNulls = (obj) => {\n            if (Array.isArray(obj)) {\n                return obj.map(removeNulls);\n            }\n\n            if (obj !== null && typeof obj === 'object') {\n                const cleaned = {};\n                for (const key in obj) {\n                    if (obj[key] !== null && obj[key] !== undefined) {\n                        cleaned[key] = removeNulls(obj[key]);\n                    }\n                }\n                return cleaned;\n            }\n\n            return obj;\n        };\n\n        return removeNulls(serialized);\n    }\n}\n\n/**\n * Throttled DOM Serializer - Prevents excessive snapshots.\n *\n * Wraps DOMSerializer with throttling to limit snapshot frequency.\n * This prevents performance issues and excessive data collection.\n */\nexport class ThrottledDOMSerializer {\n    constructor(options = {}) {\n        this.serializer = new DOMSerializer(options);\n        this.throttleMs = options.throttleMs || 1000; // Default: 1 snapshot per second\n        this.lastCaptureTime = 0;\n        this.pendingCapture = null;\n    }\n\n    /**\n     * Serialize DOM with throttling.\n     *\n     * @param {Element} [rootElement] - Root element to serialize\n     * @returns {Object|null} Serialized structure or null if throttled\n     */\n    serialize(rootElement) {\n        const now = Date.now();\n        const timeSinceLastCapture = now - this.lastCaptureTime;\n\n        // Check if throttled\n        if (timeSinceLastCapture < this.throttleMs) {\n            // Throttled - schedule capture for later\n            if (!this.pendingCapture) {\n                const remainingTime = this.throttleMs - timeSinceLastCapture;\n                this.pendingCapture = setTimeout(() => {\n                    this.pendingCapture = null;\n                    this.lastCaptureTime = Date.now();\n                    // Capture will happen on next call\n                }, remainingTime);\n            }\n            return null;\n        }\n\n        // Not throttled - perform capture\n        this.lastCaptureTime = now;\n        return this.serializer.serialize(rootElement);\n    }\n\n    /**\n     * Get serializer statistics.\n     *\n     * @returns {Object}\n     */\n    getStats() {\n        return this.serializer.getStats();\n    }\n\n    /**\n     * Clear pending throttle timer.\n     */\n    clearThrottle() {\n        if (this.pendingCapture) {\n            clearTimeout(this.pendingCapture);\n            this.pendingCapture = null;\n        }\n    }\n}\n","import { ThrottledDOMSerializer } from './dom-serializer.js';\n\n/**\n * Click Tracker - Captures user clicks and interactions for Session Replay\n *\n * ERROR-TRIGGERED RECORDING ONLY:\n * - Records clicks to buffer (not sent immediately)\n * - Buffer sent only when error detected (via ErrorDetector)\n * - Captures N seconds/clicks before and after error\n *\n * FEATURES:\n * - Click coordinate tracking with viewport dimensions\n * - Element selector generation (CSS selectors)\n * - DOM structure capture for session replay (privacy-safe)\n * - Page transition tracking (for cross-page sessions)\n * - Privacy-respecting (no PII in selectors or DOM snapshots)\n * - Click debouncing to prevent localStorage spam from rapid clicking\n */\nexport class ClickTracker {\n    /**\n     * @param {ReplayBuffer} replayBuffer - Replay buffer instance\n     * @param {SessionManager} sessionManager - Session manager instance\n     * @param {Object} config - Configuration options\n     */\n    constructor(replayBuffer, sessionManager, config) {\n        this.replayBuffer = replayBuffer;\n        this.sessionManager = sessionManager;\n        this.config = config;\n        this.isInstalled = false;\n\n        // Initialize DOM serializer with configurable throttling\n        const throttleMs = Math.max(config.snapshotThrottleMs || 1000, 500); // Min 500ms\n        this.domSerializer = new ThrottledDOMSerializer({\n            maxDepth: 10,           // Limit tree depth\n            minSize: 5,             // Skip tiny elements\n            skipInvisible: true,    // Skip hidden elements\n            captureColors: true,    // Capture background colors\n            throttleMs,             // Configurable throttle\n            maxSize: config.maxSnapshotSize || 1048576, // Default 1MB\n            debug: config.debug || false,\n        });\n\n        // Track DOM capture stats\n        this.domCaptureStats = {\n            total: 0,\n            throttled: 0,\n            captured: 0,\n            errors: 0,\n        };\n\n        // Click debouncing to prevent localStorage spam\n        this.lastClickTime = 0;\n        this.clickDebounceMs = Math.max(config.clickDebounceMs || 1000, 100); // Min 100ms\n        this.debounceStats = {\n            totalClicks: 0,\n            debouncedClicks: 0,\n        };\n    }\n\n    /**\n     * Install click tracking listeners\n     */\n    install() {\n        if (this.isInstalled) {\n            return;\n        }\n\n        try {\n            // Track clicks\n            document.addEventListener('click', (event) => {\n                this.captureClick(event);\n            }, true);\n\n            this.isInstalled = true;\n\n            if (this.config.debug) {\n                console.warn('ClickTracker: Installed (buffer-based recording)');\n            }\n        } catch (error) {\n            console.error('ClickTracker: Failed to install', error);\n        }\n    }\n\n    /**\n     * Capture click event with DOM snapshot\n     *\n     * Events are buffered (not sent immediately) and only transmitted\n     * when an error is detected via ErrorDetector.\n     *\n     * Includes debouncing to prevent localStorage spam from rapid clicking.\n     */\n    captureClick(event) {\n        try {\n            // Debounce: Ignore clicks that are too close together\n            const now = Date.now();\n            this.debounceStats.totalClicks++;\n\n            if (now - this.lastClickTime < this.clickDebounceMs) {\n                this.debounceStats.debouncedClicks++;\n                if (this.config.debug) {\n                    console.warn('ClickTracker: Click debounced', {\n                        timeSinceLastClick: now - this.lastClickTime,\n                        debounceThreshold: this.clickDebounceMs,\n                    });\n                }\n                return; // Skip this click\n            }\n\n            this.lastClickTime = now;\n\n            // Create click event data\n            const clickEvent = {\n                type: 'click',\n                url: window.location.href,\n                timestamp: Date.now(),\n                clickData: {\n                    x: event.pageX,\n                    y: event.pageY,\n                    viewportWidth: window.innerWidth,\n                    viewportHeight: window.innerHeight,\n                    elementSelector: this.generateSelector(event.target),\n                },\n                sessionId: this.sessionManager.getSessionId(),\n            };\n\n            // Capture DOM snapshot (throttled based on config)\n            this.domCaptureStats.total++;\n            try {\n                const domSnapshot = this.domSerializer.serialize();\n\n                if (domSnapshot) {\n                    // Snapshot captured successfully\n                    clickEvent.domSnapshot = domSnapshot;\n                    this.domCaptureStats.captured++;\n\n                    if (this.config.debug) {\n                        const size = this.domSerializer.serializer.estimateSize(domSnapshot);\n                        console.warn('ClickTracker: DOM snapshot captured', {\n                            elements: domSnapshot.stats?.totalElements || 0,\n                            sizeBytes: size,\n                            sizeKB: (size / 1024).toFixed(2),\n                        });\n                    }\n                } else {\n                    // Snapshot throttled\n                    this.domCaptureStats.throttled++;\n\n                    if (this.config.debug) {\n                        console.warn('ClickTracker: DOM snapshot throttled');\n                    }\n                }\n            } catch (domError) {\n                // DOM serialization failed - don't block the click capture\n                this.domCaptureStats.errors++;\n                if (this.config.debug) {\n                    console.error('ClickTracker: DOM serialization failed', domError);\n                }\n                // Continue without DOM snapshot\n            }\n\n            // Add event to replay buffer (not sent immediately)\n            const added = this.replayBuffer.addEvent(clickEvent);\n\n            if (!added && this.config.debug) {\n                console.warn('ClickTracker: Failed to add click to buffer');\n            }\n        } catch (error) {\n            // Never crash on tracking\n            console.error('ClickTracker: Failed to capture click', error);\n        }\n    }\n\n    /**\n     * Generate CSS selector for element\n     *\n     * Creates a unique but privacy-respecting selector:\n     * - Uses tag name, ID, classes\n     * - Limits depth to 5 levels\n     * - Removes sensitive attributes (data-*, ng-*, etc.)\n     */\n    generateSelector(element) {\n        if (!element || element === document) {\n            return '';\n        }\n\n        try {\n            const parts = [];\n            let current = element;\n            let depth = 0;\n            const maxDepth = 5;\n\n            while (current && current !== document && depth < maxDepth) {\n                let selector = current.tagName.toLowerCase();\n\n                // Add ID if available (most specific)\n                if (current.id && !this.containsSensitiveData(current.id)) {\n                    selector += `#${CSS.escape(current.id)}`;\n                    parts.unshift(selector);\n                    break; // ID is unique, stop here\n                }\n\n                // Add classes (filter out utility/dynamic classes)\n                const classes = this.getCleanClasses(current);\n                if (classes.length > 0) {\n                    selector += `.${classes.join('.')}`;\n                }\n\n                // Add nth-child if needed for uniqueness\n                const siblings = current.parentElement ?\n                    Array.from(current.parentElement.children).filter(\n                        child => child.tagName === current.tagName,\n                    ) : [];\n\n                if (siblings.length > 1) {\n                    const index = siblings.indexOf(current) + 1;\n                    selector += `:nth-child(${index})`;\n                }\n\n                parts.unshift(selector);\n                current = current.parentElement;\n                depth++;\n            }\n\n            return parts.join(' > ');\n        } catch {\n            // If selector generation fails, return basic info\n            return element.tagName ? element.tagName.toLowerCase() : 'unknown';\n        }\n    }\n\n    /**\n     * Get cleaned class list (remove utility and sensitive classes)\n     */\n    getCleanClasses(element) {\n        if (!element.classList || element.classList.length === 0) {\n            return [];\n        }\n\n        const classes = Array.from(element.classList);\n        return classes\n            .filter(cls => {\n                // Filter out utility classes (Tailwind, Bootstrap, etc.)\n                if (cls.match(/^(active|hover|focus|disabled|hidden|show)$/)) {\n                    return false;\n                }\n\n                // Filter out generated classes\n                if (cls.match(/^(ng-|v-|data-|_)/)) {\n                    return false;\n                }\n\n                // Filter out classes that look like they contain sensitive data\n                if (this.containsSensitiveData(cls)) {\n                    return false;\n                }\n\n                return true;\n            })\n            .map(cls => CSS.escape(cls))\n            .slice(0, 3); // Limit to 3 classes\n    }\n\n    /**\n     * Check if string contains potentially sensitive data\n     */\n    containsSensitiveData(str) {\n        const sensitivePatterns = [\n            /user[-_]?id/i,\n            /email/i,\n            /token/i,\n            /session/i,\n            /auth/i,\n            /key/i,\n            /\\d{10,}/,  // Long numbers (could be IDs)\n        ];\n\n        return sensitivePatterns.some(pattern => pattern.test(str));\n    }\n\n\n    /**\n     * Get DOM capture statistics for monitoring\n     *\n     * @returns {Object} Statistics about DOM snapshot captures\n     */\n    getDOMCaptureStats() {\n        return {\n            ...this.domCaptureStats,\n            serializerStats: this.domSerializer.getStats(),\n        };\n    }\n\n    /**\n     * Get click debounce statistics\n     *\n     * @returns {Object} Statistics about debounced clicks\n     */\n    getDebounceStats() {\n        return {\n            ...this.debounceStats,\n            debounceRate: this.debounceStats.totalClicks > 0\n                ? (this.debounceStats.debouncedClicks / this.debounceStats.totalClicks * 100).toFixed(2) + '%'\n                : '0%',\n            clickDebounceMs: this.clickDebounceMs,\n        };\n    }\n\n    /**\n     * Clean up resources\n     */\n    cleanup() {\n        try {\n            // Clear DOM serializer throttle timer\n            if (this.domSerializer && this.domSerializer.clearThrottle) {\n                this.domSerializer.clearThrottle();\n            }\n\n            if (this.config.debug) {\n                console.warn('ClickTracker: Cleanup complete');\n            }\n        } catch (error) {\n            console.error('ClickTracker: Cleanup failed', error);\n        }\n    }\n}\n","/**\n * Replay Buffer - Circular Buffer for Session Replay Data\n *\n * Implements a circular buffer that stores clicks and DOM snapshots\n * before an error occurs. Only sends data when an error is detected.\n *\n * Features:\n * - Time-based buffering (e.g., last 30 seconds)\n * - Click-based buffering (e.g., last 10 clicks)\n * - Memory-efficient circular buffer (FIFO)\n * - Configurable hard caps\n * - Serialization for localStorage\n * - Automatic pruning of old data\n */\nexport class ReplayBuffer {\n    /**\n     * @param {Object} config Configuration options\n     * @param {number} [config.bufferBeforeErrorSeconds=30] - Seconds of activity before error\n     * @param {number} [config.bufferBeforeErrorClicks=10] - Number of clicks before error\n     * @param {number} [config.bufferAfterErrorSeconds=30] - Seconds to continue after error\n     * @param {number} [config.bufferAfterErrorClicks=10] - Clicks to continue after error\n     * @param {number} [config.maxBufferSizeMB=5] - Maximum localStorage buffer size\n     * @param {boolean} [config.debug=false] - Enable debug logging\n     */\n    constructor(config = {}) {\n        // Configuration with hard caps enforced\n        this.config = {\n            bufferBeforeErrorSeconds: Math.min(config.bufferBeforeErrorSeconds || 30, 60),\n            bufferBeforeErrorClicks: Math.min(config.bufferBeforeErrorClicks || 10, 15),\n            bufferAfterErrorSeconds: Math.min(config.bufferAfterErrorSeconds || 30, 60),\n            bufferAfterErrorClicks: Math.min(config.bufferAfterErrorClicks || 10, 15),\n            maxBufferSizeMB: Math.min(config.maxBufferSizeMB || 5, 20),\n            debug: config.debug || false,\n        };\n\n        // Buffer state\n        this.buffer = []; // Circular buffer of events\n        this.isRecordingAfterError = false;\n        this.recordingStartedAt = null;\n        this.errorOccurredAt = null;\n        this.postErrorEventCount = 0;\n\n        // Statistics\n        this.stats = {\n            totalEvents: 0,\n            eventsDropped: 0,\n            bufferFullCount: 0,\n            currentBufferSize: 0,\n        };\n\n        if (this.config.debug) {\n            console.warn('ReplayBuffer initialized with config:', this.config);\n        }\n    }\n\n    /**\n     * Add an event to the buffer\n     *\n     * @param {Object} event - Event data (click, page transition, etc.)\n     * @param {string} event.type - Event type (click, pageTransition)\n     * @param {string} event.url - Current URL\n     * @param {number} event.timestamp - Event timestamp (milliseconds)\n     * @param {Object} [event.clickData] - Click-specific data\n     * @param {Object} [event.domSnapshot] - DOM snapshot (optional)\n     * @returns {boolean} True if event was added, false if dropped\n     */\n    addEvent(event) {\n        try {\n            if (!event || !event.timestamp) {\n                console.warn('ReplayBuffer: Invalid event (missing timestamp)');\n                return false;\n            }\n\n            // Mark event phase (before_error, error, or after_error)\n            event.phase = this.isRecordingAfterError ? 'after_error' : 'before_error';\n            event.capturedAt = Date.now();\n\n            // Add to buffer\n            this.buffer.push(event);\n            this.stats.totalEvents++;\n\n            // If recording after error, track count\n            if (this.isRecordingAfterError) {\n                this.postErrorEventCount++;\n\n                // Check if we should stop recording\n                if (this.shouldStopRecording()) {\n                    this.stopRecording();\n                }\n            } else {\n                // Prune old events from buffer (before error)\n                this.pruneOldEvents();\n            }\n\n            // Update stats\n            this.updateStats();\n\n            return true;\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to add event:', error);\n            this.stats.eventsDropped++;\n            return false;\n        }\n    }\n\n    /**\n     * Mark the start of error-triggered recording\n     *\n     * Call this when an error is detected. It will:\n     * 1. Mark the buffer as \"recording after error\"\n     * 2. Reset post-error counters\n     * 3. Prepare to stop after configured buffer is filled\n     *\n     * @param {Object} errorContext - Error context information\n     * @param {string} errorContext.errorId - Error ID from backend\n     * @param {string} errorContext.message - Error message\n     * @param {number} errorContext.timestamp - Error timestamp\n     */\n    startRecordingAfterError(errorContext) {\n        try {\n            this.errorOccurredAt = errorContext.timestamp || Date.now();\n            this.postErrorEventCount = 0;\n\n            // Add error marker event to buffer (manually, before setting isRecordingAfterError)\n            // This ensures the error marker itself is not counted in postErrorEventCount\n            this.buffer.push({\n                type: 'error',\n                phase: 'error',\n                timestamp: this.errorOccurredAt,\n                capturedAt: Date.now(),\n                url: window.location.href,\n                errorContext,\n            });\n            this.stats.totalEvents++;\n\n            // Now mark as recording after error (subsequent events will be counted)\n            this.isRecordingAfterError = true;\n\n            if (this.config.debug) {\n                console.warn('ReplayBuffer: Started recording after error', {\n                    errorId: errorContext.errorId,\n                    bufferSize: this.buffer.length,\n                    willRecordFor: `${this.config.bufferAfterErrorSeconds}s or ${this.config.bufferAfterErrorClicks} clicks`,\n                });\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to start post-error recording:', error);\n        }\n    }\n\n    /**\n     * Stop recording after error buffer is full\n     */\n    stopRecording() {\n        try {\n            if (!this.isRecordingAfterError) {\n                return;\n            }\n\n            this.isRecordingAfterError = false;\n\n            if (this.config.debug) {\n                console.warn('ReplayBuffer: Stopped recording after error', {\n                    totalEvents: this.buffer.length,\n                    postErrorEvents: this.postErrorEventCount,\n                });\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to stop recording:', error);\n        }\n    }\n\n    /**\n     * Check if we should stop recording after error\n     *\n     * Stops when either condition is met:\n     * - Time limit reached (bufferAfterErrorSeconds)\n     * - Click limit reached (bufferAfterErrorClicks)\n     *\n     * @returns {boolean}\n     */\n    shouldStopRecording() {\n        if (!this.isRecordingAfterError || !this.errorOccurredAt) {\n            return false;\n        }\n\n        const now = Date.now();\n        const elapsedSeconds = (now - this.errorOccurredAt) / 1000;\n\n        // Check time limit\n        if (elapsedSeconds >= this.config.bufferAfterErrorSeconds) {\n            if (this.config.debug) {\n                console.warn(`ReplayBuffer: Time limit reached (${elapsedSeconds.toFixed(1)}s)`);\n            }\n            return true;\n        }\n\n        // Check click limit\n        if (this.postErrorEventCount >= this.config.bufferAfterErrorClicks) {\n            if (this.config.debug) {\n                console.warn(`ReplayBuffer: Click limit reached (${this.postErrorEventCount} clicks)`);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Prune old events from buffer (keep only recent N seconds/clicks)\n     */\n    pruneOldEvents() {\n        try {\n            const now = Date.now();\n            const cutoffTime = now - (this.config.bufferBeforeErrorSeconds * 1000);\n\n            // Filter events: keep events within time window\n            const timeFiltered = this.buffer.filter(event =>\n                event.capturedAt >= cutoffTime || event.phase === 'error',\n            );\n\n            // Also enforce click limit: keep last N clicks\n            const clickEvents = timeFiltered.filter(e => e.type === 'click');\n            const otherEvents = timeFiltered.filter(e => e.type !== 'click');\n\n            // Keep last N clicks + all other events (page transitions, errors)\n            const recentClicks = clickEvents.slice(-this.config.bufferBeforeErrorClicks);\n\n            this.buffer = [...otherEvents, ...recentClicks]\n                .sort((a, b) => a.capturedAt - b.capturedAt);\n\n            // Update stats if buffer was pruned\n            if (this.buffer.length < timeFiltered.length) {\n                const dropped = timeFiltered.length - this.buffer.length;\n                this.stats.eventsDropped += dropped;\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to prune old events:', error);\n        }\n    }\n\n    /**\n     * Get all events in the buffer\n     *\n     * @returns {Array<Object>} Array of events\n     */\n    getEvents() {\n        return [...this.buffer]; // Return copy\n    }\n\n    /**\n     * Get events by phase\n     *\n     * @param {string} phase - Phase to filter by (before_error, error, after_error)\n     * @returns {Array<Object>}\n     */\n    getEventsByPhase(phase) {\n        return this.buffer.filter(event => event.phase === phase);\n    }\n\n    /**\n     * Clear the buffer\n     */\n    clear() {\n        try {\n            this.buffer = [];\n            this.isRecordingAfterError = false;\n            this.recordingStartedAt = null;\n            this.errorOccurredAt = null;\n            this.postErrorEventCount = 0;\n\n            if (this.config.debug) {\n                console.warn('ReplayBuffer: Cleared');\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to clear buffer:', error);\n        }\n    }\n\n    /**\n     * Check if buffer is currently recording after an error\n     *\n     * @returns {boolean}\n     */\n    isRecording() {\n        return this.isRecordingAfterError;\n    }\n\n    /**\n     * Get buffer statistics\n     *\n     * @returns {Object} Statistics\n     */\n    getStats() {\n        return {\n            ...this.stats,\n            bufferLength: this.buffer.length,\n            isRecording: this.isRecordingAfterError,\n            postErrorEventCount: this.postErrorEventCount,\n        };\n    }\n\n    /**\n     * Update buffer statistics\n     */\n    updateStats() {\n        try {\n            // Calculate approximate buffer size\n            const approximateSize = this.estimateBufferSize();\n            this.stats.currentBufferSize = approximateSize;\n\n            // Check if buffer is getting too large\n            const maxSizeBytes = this.config.maxBufferSizeMB * 1024 * 1024;\n            if (approximateSize > maxSizeBytes) {\n                this.stats.bufferFullCount++;\n                // Aggressive pruning\n                this.buffer = this.buffer.slice(-Math.floor(this.buffer.length / 2));\n            }\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to update stats:', error);\n        }\n    }\n\n    /**\n     * Estimate buffer size in bytes\n     *\n     * @returns {number} Approximate size in bytes\n     */\n    estimateBufferSize() {\n        try {\n            const json = JSON.stringify(this.buffer);\n            return json.length;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Serialize buffer for storage\n     *\n     * @returns {Object} Serialized data\n     */\n    serialize() {\n        return {\n            buffer: this.buffer,\n            isRecordingAfterError: this.isRecordingAfterError,\n            errorOccurredAt: this.errorOccurredAt,\n            postErrorEventCount: this.postErrorEventCount,\n            stats: this.stats,\n        };\n    }\n\n    /**\n     * Deserialize buffer from storage\n     *\n     * @param {Object} data - Serialized data\n     * @returns {boolean} Success\n     */\n    deserialize(data) {\n        try {\n            if (!data || typeof data !== 'object') {\n                if (this.config.debug) {\n                    console.warn('ReplayBuffer: No data to deserialize');\n                }\n                return false;\n            }\n\n            this.buffer = Array.isArray(data.buffer) ? data.buffer : [];\n            this.isRecordingAfterError = !!data.isRecordingAfterError;\n            this.errorOccurredAt = data.errorOccurredAt || null;\n            this.postErrorEventCount = data.postErrorEventCount || 0;\n\n            if (data.stats && typeof data.stats === 'object') {\n                this.stats = { ...this.stats, ...data.stats };\n            }\n\n            // MIGRATION: Ensure all events have phase property\n            // Old localStorage data might not have phase property\n            let migratedCount = 0;\n            this.buffer = this.buffer.map(event => {\n                if (!event.phase) {\n                    migratedCount++;\n                    // Default to 'before_error' for old events\n                    return { ...event, phase: 'before_error' };\n                }\n                return event;\n            });\n\n            if (this.config.debug) {\n                const phaseBreakdown = this.buffer.reduce((acc, event) => {\n                    acc[event.phase] = (acc[event.phase] || 0) + 1;\n                    return acc;\n                }, {});\n\n                console.warn('ReplayBuffer: Deserialized from localStorage', {\n                    totalEvents: this.buffer.length,\n                    migratedEvents: migratedCount,\n                    phaseBreakdown,\n                    isRecording: this.isRecordingAfterError,\n                    byteSize: this.estimateBufferSize(),\n                });\n            }\n\n            return true;\n        } catch (error) {\n            console.error('ReplayBuffer: Failed to deserialize:', error);\n            return false;\n        }\n    }\n}\n","/**\n * Error Detector - Triggers Session Replay on Errors\n *\n * Hooks into global error handlers and triggers replay buffer capture\n * when errors are detected. Coordinates with ReplayBuffer to send\n * buffered events along with error context.\n *\n * Features:\n * - Hooks window.onerror and unhandledrejection\n * - Triggers replay capture on error\n * - Links replay data to error ID\n * - Prevents duplicate captures\n * - Configurable error filtering\n */\nexport class ErrorDetector {\n    /**\n     * @param {ReplayBuffer} replayBuffer - Replay buffer instance\n     * @param {SessionManager} sessionManager - Session manager instance\n     * @param {Function} onErrorDetected - Callback when error detected (receives errorContext)\n     * @param {Transport|null} transport - Transport layer for sending recovery sessions\n     * @param {Object} [config] - Configuration options\n     * @param {boolean} [config.debug=false] - Enable debug logging\n     * @param {Array<string>} [config.ignoreErrors=[]] - Error messages to ignore\n     */\n    constructor(replayBuffer, sessionManager, onErrorDetected, transport = null, config = {}) {\n        this.replayBuffer = replayBuffer;\n        this.sessionManager = sessionManager;\n        this.onErrorDetected = onErrorDetected;\n        this.transport = transport;\n        this.config = {\n            debug: config.debug || false,\n            ignoreErrors: config.ignoreErrors || [],\n        };\n\n        // State\n        this.isInstalled = false;\n        this.recentErrors = new Set(); // Prevent duplicate captures\n        this.recentErrorsCleanupInterval = null;\n        this.isRecordingRecovery = false; // Prevent concurrent recovery recordings\n        this.recoveryRecordingCleanup = null; // Store cleanup function\n\n        // Statistics\n        this.stats = {\n            errorsDetected: 0,\n            errorsIgnored: 0,\n            replaysCaptured: 0,\n            duplicatesPrevented: 0,\n            recoveryRecordingsStarted: 0,\n            recoveryRecordingsCancelled: 0,\n        };\n\n        if (this.config.debug) {\n            console.warn('ErrorDetector initialized');\n        }\n    }\n\n    /**\n     * Install error detection handlers\n     */\n    install() {\n        if (this.isInstalled) {\n            console.warn('ErrorDetector: Already installed');\n            return;\n        }\n\n        try {\n            // Note: We intentionally do NOT add new handlers here\n            // The Client class already handles window.onerror and unhandledrejection\n            // This detector will be called FROM the Client class when errors occur\n            // This design prevents double-handling of errors\n\n            // Set up cleanup for recent errors (prevent duplicates)\n            this.recentErrorsCleanupInterval = setInterval(() => {\n                this.recentErrors.clear();\n            }, 60000); // Clear every 60 seconds\n\n            this.isInstalled = true;\n\n            if (this.config.debug) {\n                console.warn('ErrorDetector: Installed');\n            }\n        } catch (error) {\n            console.error('ErrorDetector: Failed to install:', error);\n        }\n    }\n\n    /**\n     * Uninstall error detection handlers\n     */\n    uninstall() {\n        try {\n            if (this.recentErrorsCleanupInterval) {\n                clearInterval(this.recentErrorsCleanupInterval);\n                this.recentErrorsCleanupInterval = null;\n            }\n\n            this.isInstalled = false;\n\n            if (this.config.debug) {\n                console.warn('ErrorDetector: Uninstalled');\n            }\n        } catch (error) {\n            console.error('ErrorDetector: Failed to uninstall:', error);\n        }\n    }\n\n    /**\n     * Handle detected error (called by Client)\n     *\n     * This is the main entry point called by the Client class when an error occurs.\n     *\n     * @param {Error} error - The error object\n     * @param {Object} errorPayload - The error payload being sent to backend\n     * @returns {Promise<Object|null>} Error context with replay data, or null\n     */\n    async handleError(error, errorPayload) {\n        try {\n            this.stats.errorsDetected++;\n\n            // Check if error should be ignored\n            if (this.shouldIgnoreError(error)) {\n                this.stats.errorsIgnored++;\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: Error ignored:', error.message);\n                }\n                return null;\n            }\n\n            // Generate error fingerprint for deduplication\n            const errorFingerprint = this.generateErrorFingerprint(error);\n\n            // Check if we recently captured this error\n            if (this.recentErrors.has(errorFingerprint)) {\n                this.stats.duplicatesPrevented++;\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: Duplicate error prevented');\n                }\n                return null;\n            }\n\n            // Mark error as recently seen\n            this.recentErrors.add(errorFingerprint);\n\n            // Create error context\n            const errorContext = {\n                errorId: null, // Will be set by backend response\n                message: error.message || 'Unknown error',\n                type: error.name || 'Error',\n                timestamp: Date.now(),\n                stack: error.stack || '',\n                url: window.location.href,\n            };\n\n            // Start recording after error (continue for N seconds/clicks)\n            this.replayBuffer.startRecordingAfterError(errorContext);\n\n            // Get buffered events\n            const events = this.replayBuffer.getEvents();\n\n            if (this.config.debug) {\n                console.warn('ErrorDetector: Replay captured', {\n                    errorMessage: errorContext.message,\n                    eventCount: events.length,\n                    beforeError: this.replayBuffer.getEventsByPhase('before_error').length,\n                    afterError: this.replayBuffer.getEventsByPhase('after_error').length,\n                });\n            }\n\n            this.stats.replaysCaptured++;\n\n            // Call the callback with error context and replay data\n            if (this.onErrorDetected) {\n                await this.onErrorDetected(errorContext, events, errorPayload);\n            }\n\n            return {\n                errorContext,\n                events,\n                sessionId: this.sessionManager.getSessionId(),\n                stats: this.replayBuffer.getStats(),\n            };\n        } catch (handlingError) {\n            console.error('ErrorDetector: Failed to handle error:', handlingError);\n            return null;\n        }\n    }\n\n    /**\n     * Check if error should be ignored\n     *\n     * @param {Error} error\n     * @returns {boolean}\n     */\n    shouldIgnoreError(error) {\n        try {\n            if (!error || !error.message) {\n                return false;\n            }\n\n            const message = error.message.toLowerCase();\n\n            // Check configured ignore patterns\n            for (const pattern of this.config.ignoreErrors) {\n                if (message.includes(pattern.toLowerCase())) {\n                    return true;\n                }\n            }\n\n            // Ignore common non-actionable errors\n            const commonIgnorePatterns = [\n                'script error', // Cross-origin script errors\n                'network error', // Network failures (not code bugs)\n                'loading chunk', // Webpack/bundler chunk loading issues\n                'dynamically imported module', // Dynamic import failures\n            ];\n\n            for (const pattern of commonIgnorePatterns) {\n                if (message.includes(pattern)) {\n                    return true;\n                }\n            }\n\n            return false;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Generate error fingerprint for deduplication\n     *\n     * @param {Error} error\n     * @returns {string}\n     */\n    generateErrorFingerprint(error) {\n        try {\n            const message = error.message || '';\n            const stack = error.stack || '';\n\n            // Extract first line of stack (most specific)\n            const stackFirstLine = stack.split('\\n')[1] || '';\n\n            // Combine message + first stack line for fingerprint\n            return `${message}:${stackFirstLine}`;\n        } catch {\n            return `${Date.now()}:${Math.random()}`;\n        }\n    }\n\n    /**\n     * Start recording recovery session after error (Phase 2 of two-phase replay)\n     *\n     * This method is called AFTER the error + pre-error replay has been sent.\n     * It continues recording user actions for the configured duration/clicks,\n     * then sends the recovery session as a separate request.\n     *\n     * EDGE CASES HANDLED:\n     * - Prevents multiple concurrent recovery recordings\n     * - Cleans up previous recording if new error occurs\n     * - Proper cleanup of intervals and event listeners\n     * - Handles page unload gracefully\n     * - Uses sendBeacon for reliable unload transmission\n     * - Handles null/undefined buffer states\n     *\n     * @param {Error} error - The error object\n     * @returns {Promise<void>}\n     */\n    async startRecoveryRecording(error) {\n        try {\n            // EDGE CASE 1: Check if already recording recovery\n            if (this.isRecordingRecovery) {\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: Already recording recovery, cleaning up previous recording');\n                }\n\n                // Clean up previous recording\n                if (this.recoveryRecordingCleanup) {\n                    this.recoveryRecordingCleanup();\n                }\n\n                this.stats.recoveryRecordingsCancelled++;\n            }\n\n            // EDGE CASE 2: Validate dependencies\n            if (!this.replayBuffer || !this.sessionManager) {\n                console.error('ErrorDetector: Cannot start recovery recording - missing dependencies');\n                return;\n            }\n\n            // EDGE CASE 3: Validate error object\n            if (!error || typeof error !== 'object') {\n                console.error('ErrorDetector: Invalid error object for recovery recording');\n                return;\n            }\n\n            this.isRecordingRecovery = true;\n            this.stats.recoveryRecordingsStarted++;\n\n            if (this.config.debug) {\n                console.warn('ErrorDetector: Starting recovery recording (phase 2)');\n            }\n\n            const errorContext = {\n                errorId: null, // Could be set from backend response if needed\n                message: error.message || 'Unknown error',\n                type: error.name || 'Error',\n                timestamp: Date.now(),\n                url: window.location.href,\n            };\n\n            // Mark buffer as recording recovery (after error)\n            // EDGE CASE 4: Validate method exists\n            if (typeof this.replayBuffer.startRecordingAfterError === 'function') {\n                this.replayBuffer.startRecordingAfterError(errorContext);\n            } else {\n                console.error('ErrorDetector: Buffer missing startRecordingAfterError method');\n                this.isRecordingRecovery = false;\n                return;\n            }\n\n            // Wait for recording to complete (time limit or click limit)\n            return new Promise((resolve) => {\n                let checkCompleteInterval = null;\n                let unloadHandler = null;\n                let visibilityHandler = null;\n\n                // Create cleanup function to prevent memory leaks\n                const cleanup = () => {\n                    // Clear interval\n                    if (checkCompleteInterval) {\n                        clearInterval(checkCompleteInterval);\n                        checkCompleteInterval = null;\n                    }\n\n                    // Remove event listeners\n                    if (unloadHandler) {\n                        window.removeEventListener('beforeunload', unloadHandler);\n                        unloadHandler = null;\n                    }\n\n                    if (visibilityHandler) {\n                        document.removeEventListener('visibilitychange', visibilityHandler);\n                        visibilityHandler = null;\n                    }\n\n                    // Clear recovery state\n                    this.isRecordingRecovery = false;\n                    this.recoveryRecordingCleanup = null;\n                };\n\n                // Store cleanup function for external cancellation\n                this.recoveryRecordingCleanup = cleanup;\n\n                const finishRecording = (reason = 'unknown') => {\n                    if (this.config.debug) {\n                        console.warn(`ErrorDetector: Finishing recovery recording (reason: ${reason})`);\n                    }\n\n                    // Clean up listeners FIRST\n                    cleanup();\n\n                    // Get recovery events\n                    // EDGE CASE 5: Validate method exists and returns array\n                    let recoveryEvents = [];\n                    if (this.replayBuffer && typeof this.replayBuffer.getEventsByPhase === 'function') {\n                        recoveryEvents = this.replayBuffer.getEventsByPhase('after_error') || [];\n                    }\n\n                    if (recoveryEvents.length > 0) {\n                        // Use sendBeacon for page unload (more reliable)\n                        const useBeacon = reason === 'page-unload' || reason === 'page-hidden';\n\n                        // Send recovery session separately\n                        this.sendRecoverySession(errorContext, recoveryEvents, useBeacon);\n                    } else if (this.config.debug) {\n                        console.warn('ErrorDetector: No recovery events captured');\n                    }\n\n                    resolve();\n                };\n\n                // Check every second if recording is complete\n                checkCompleteInterval = setInterval(() => {\n                    try {\n                        // EDGE CASE 6: Validate buffer still exists\n                        if (!this.replayBuffer || typeof this.replayBuffer.shouldStopRecording !== 'function') {\n                            finishRecording('buffer-unavailable');\n                            return;\n                        }\n\n                        if (this.replayBuffer.shouldStopRecording()) {\n                            finishRecording('limit-reached');\n                        }\n                    } catch (error) {\n                        console.error('ErrorDetector: Error in recovery check interval', error);\n                        finishRecording('check-error');\n                    }\n                }, 1000);\n\n                // Listen for page unload (use sendBeacon for reliability)\n                unloadHandler = () => {\n                    finishRecording('page-unload');\n                };\n                window.addEventListener('beforeunload', unloadHandler, { once: true });\n\n                // Also listen for visibility change (mobile)\n                visibilityHandler = () => {\n                    if (document.visibilityState === 'hidden') {\n                        finishRecording('page-hidden');\n                    }\n                };\n                document.addEventListener('visibilitychange', visibilityHandler, { once: true });\n\n                // EDGE CASE 7: Safety timeout (absolute maximum)\n                // If something goes wrong, force finish after 2 minutes\n                setTimeout(() => {\n                    if (this.isRecordingRecovery) {\n                        if (this.config.debug) {\n                            console.warn('ErrorDetector: Recovery recording safety timeout (2 minutes)');\n                        }\n                        finishRecording('safety-timeout');\n                    }\n                }, 120000); // 2 minutes absolute maximum\n            });\n        } catch (error) {\n            console.error('ErrorDetector: Failed to start recovery recording', error);\n            this.isRecordingRecovery = false;\n            this.recoveryRecordingCleanup = null;\n        }\n    }\n\n    /**\n     * Send recovery session as separate request (Phase 2)\n     *\n     * @param {Object} errorContext - Error context information\n     * @param {Array} events - Recovery events (after error)\n     * @param {boolean} [useBeacon=false] - Use sendBeacon API for reliable unload transmission\n     */\n    sendRecoverySession(errorContext, events, useBeacon = false) {\n        try {\n            if (events.length === 0) {\n                return; // No recovery data\n            }\n\n            // Only send if there are click events (user interactions)\n            const clickCount = events.filter(e => e && e.type === 'click').length;\n            if (clickCount === 0) {\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: No click events in recovery session, skipping send', {\n                        totalEvents: events.length,\n                    });\n                }\n                return;\n            }\n\n            // Format payload to match backend API expectations\n            const recoveryPayload = {\n                sessionId: this.sessionManager.getSessionId(),\n                events: events,\n                capturedAt: new Date().toISOString(),\n                url: window.location.href,\n            };\n\n            // Send via transport if available\n            if (this.transport && typeof this.transport.sendRecoverySession === 'function') {\n                this.transport.sendRecoverySession(recoveryPayload, useBeacon).catch(error => {\n                    console.error('ErrorDetector: Failed to send recovery session via transport', error);\n                });\n\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: Recovery session sent via transport', {\n                        eventCount: events.length,\n                        sessionId: recoveryPayload.sessionId,\n                        method: useBeacon ? 'sendBeacon' : 'fetch',\n                    });\n                }\n            } else {\n                // Fallback: call onErrorDetected callback\n                if (this.onErrorDetected) {\n                    this.onErrorDetected(errorContext, events, { recovery: true });\n                }\n\n                if (this.config.debug) {\n                    console.warn('ErrorDetector: Recovery session sent via callback', {\n                        eventCount: events.length,\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('ErrorDetector: Failed to send recovery session', error);\n        }\n    }\n\n    /**\n     * Get error detection statistics\n     *\n     * @returns {Object}\n     */\n    getStats() {\n        return {\n            ...this.stats,\n            isInstalled: this.isInstalled,\n            recentErrorsCount: this.recentErrors.size,\n        };\n    }\n\n    /**\n     * Enable/disable error detection\n     *\n     * @param {boolean} enabled\n     */\n    setEnabled(enabled) {\n        if (enabled && !this.isInstalled) {\n            this.install();\n        } else if (!enabled && this.isInstalled) {\n            this.uninstall();\n        }\n    }\n\n    /**\n     * Check if error detection is enabled\n     *\n     * @returns {boolean}\n     */\n    isEnabled() {\n        return this.isInstalled;\n    }\n}\n","/**\n * Session Manager - Cross-Page Session Management\n *\n * Manages session ID persistence across page navigations using localStorage.\n * Tracks page transitions and session metadata for replay continuity.\n *\n * Features:\n * - Persistent session ID (UUID) in localStorage\n * - Cross-page session continuity\n * - Page transition tracking\n * - Session expiration (idle timeout)\n * - Session metadata (start time, page count)\n */\nexport class SessionManager {\n    /**\n     * @param {Object} [config] - Configuration options\n     * @param {number} [config.sessionTimeoutMinutes=30] - Session timeout in minutes\n     * @param {boolean} [config.debug=false] - Enable debug logging\n     */\n    constructor(config = {}) {\n        this.config = {\n            sessionTimeoutMinutes: Math.min(config.sessionTimeoutMinutes || 30, 120),\n            debug: config.debug || false,\n        };\n\n        // localStorage keys\n        this.STORAGE_KEY_SESSION_ID = '_app_logger_session_id';\n        this.STORAGE_KEY_SESSION_METADATA = '_app_logger_session_metadata';\n\n        // Session state\n        this.sessionId = null;\n        this.metadata = {\n            startedAt: null,\n            lastActivityAt: null,\n            pageCount: 0,\n            pages: [],\n        };\n\n        // Initialize\n        this.initialize();\n\n        if (this.config.debug) {\n            console.warn('SessionManager initialized', {\n                sessionId: this.sessionId,\n                metadata: this.metadata,\n            });\n        }\n    }\n\n    /**\n     * Initialize session (load or create)\n     */\n    initialize() {\n        try {\n            // Try to load existing session\n            const loaded = this.loadSession();\n\n            if (!loaded || this.isSessionExpired()) {\n                // Create new session\n                this.createNewSession();\n            } else {\n                // Update last activity\n                this.updateActivity();\n            }\n\n            // Track current page\n            this.trackPageView(window.location.href);\n\n            // Set up page transition tracking\n            this.setupPageTransitionTracking();\n        } catch (error) {\n            console.error('SessionManager: Failed to initialize:', error);\n            // Fallback: create new session\n            this.createNewSession();\n        }\n    }\n\n    /**\n     * Create a new session\n     */\n    createNewSession() {\n        try {\n            this.sessionId = this.generateSessionId();\n            this.metadata = {\n                startedAt: Date.now(),\n                lastActivityAt: Date.now(),\n                pageCount: 0,\n                pages: [],\n            };\n\n            this.saveSession();\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Created new session', this.sessionId);\n            }\n        } catch (error) {\n            console.error('SessionManager: Failed to create new session:', error);\n        }\n    }\n\n    /**\n     * Load session from localStorage\n     *\n     * @returns {boolean} True if session loaded successfully\n     */\n    loadSession() {\n        try {\n            const sessionId = localStorage.getItem(this.STORAGE_KEY_SESSION_ID);\n            const metadataJson = localStorage.getItem(this.STORAGE_KEY_SESSION_METADATA);\n\n            if (!sessionId || !metadataJson) {\n                return false;\n            }\n\n            const metadata = JSON.parse(metadataJson);\n\n            if (!metadata || !metadata.startedAt) {\n                return false;\n            }\n\n            this.sessionId = sessionId;\n            this.metadata = metadata;\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Loaded session', {\n                    sessionId,\n                    age: this.getSessionAge(),\n                });\n            }\n\n            return true;\n        } catch (error) {\n            console.error('SessionManager: Failed to load session:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Save session to localStorage\n     */\n    saveSession() {\n        try {\n            localStorage.setItem(this.STORAGE_KEY_SESSION_ID, this.sessionId);\n            localStorage.setItem(\n                this.STORAGE_KEY_SESSION_METADATA,\n                JSON.stringify(this.metadata),\n            );\n        } catch (error) {\n            console.error('SessionManager: Failed to save session:', error);\n        }\n    }\n\n    /**\n     * Check if session is expired\n     *\n     * @returns {boolean}\n     */\n    isSessionExpired() {\n        try {\n            if (!this.metadata.lastActivityAt) {\n                return true;\n            }\n\n            const now = Date.now();\n            const lastActivity = this.metadata.lastActivityAt;\n            const timeoutMs = this.config.sessionTimeoutMinutes * 60 * 1000;\n\n            return (now - lastActivity) > timeoutMs;\n        } catch {\n            return true;\n        }\n    }\n\n    /**\n     * Update last activity timestamp\n     */\n    updateActivity() {\n        try {\n            this.metadata.lastActivityAt = Date.now();\n            this.saveSession();\n        } catch (error) {\n            console.error('SessionManager: Failed to update activity:', error);\n        }\n    }\n\n    /**\n     * Track page view\n     *\n     * @param {string} url - Page URL\n     * @returns {Object} Page transition event\n     */\n    trackPageView(url) {\n        try {\n            // Increment page count\n            this.metadata.pageCount++;\n\n            // Add to pages array (keep last 50)\n            this.metadata.pages.push({\n                url,\n                timestamp: Date.now(),\n            });\n\n            if (this.metadata.pages.length > 50) {\n                this.metadata.pages = this.metadata.pages.slice(-50);\n            }\n\n            // Update activity\n            this.updateActivity();\n\n            // Create page transition event\n            const pageEvent = {\n                type: 'pageTransition',\n                url,\n                timestamp: Date.now(),\n                phase: 'before_error',\n                sessionId: this.sessionId,\n                pageCount: this.metadata.pageCount,\n            };\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Page view tracked', {\n                    url,\n                    pageCount: this.metadata.pageCount,\n                });\n            }\n\n            return pageEvent;\n        } catch (error) {\n            console.error('SessionManager: Failed to track page view:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Set up page transition tracking\n     */\n    setupPageTransitionTracking() {\n        try {\n            // Track history API navigation (pushState, replaceState)\n            const originalPushState = history.pushState;\n            const originalReplaceState = history.replaceState;\n\n            history.pushState = (...args) => {\n                originalPushState.apply(history, args);\n                this.handleNavigationChange();\n            };\n\n            history.replaceState = (...args) => {\n                originalReplaceState.apply(history, args);\n                this.handleNavigationChange();\n            };\n\n            // Track popstate (back/forward buttons)\n            window.addEventListener('popstate', () => {\n                this.handleNavigationChange();\n            });\n\n            // Track hash changes\n            window.addEventListener('hashchange', () => {\n                this.handleNavigationChange();\n            });\n        } catch (error) {\n            console.error('SessionManager: Failed to setup page transition tracking:', error);\n        }\n    }\n\n    /**\n     * Handle navigation change (for SPA routing)\n     */\n    handleNavigationChange() {\n        try {\n            const url = window.location.href;\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Navigation detected', url);\n            }\n\n            // Track the navigation as a page transition\n            this.trackPageView(url);\n        } catch (error) {\n            console.error('SessionManager: Failed to handle navigation change:', error);\n        }\n    }\n\n    /**\n     * Get current session ID\n     *\n     * @returns {string}\n     */\n    getSessionId() {\n        return this.sessionId;\n    }\n\n    /**\n     * Get session metadata\n     *\n     * @returns {Object}\n     */\n    getMetadata() {\n        return { ...this.metadata };\n    }\n\n    /**\n     * Get session age in milliseconds\n     *\n     * @returns {number}\n     */\n    getSessionAge() {\n        if (!this.metadata.startedAt) {\n            return 0;\n        }\n\n        return Date.now() - this.metadata.startedAt;\n    }\n\n    /**\n     * Generate a new session ID (UUID v4)\n     *\n     * @returns {string}\n     */\n    generateSessionId() {\n        try {\n            // Use crypto.randomUUID if available (modern browsers)\n            if (crypto && crypto.randomUUID) {\n                return crypto.randomUUID();\n            }\n\n            // Fallback: Generate UUID v4 manually\n            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n                const r = Math.random() * 16 | 0;\n                const v = c === 'x' ? r : (r & 0x3 | 0x8);\n                return v.toString(16);\n            });\n        } catch {\n            // Last resort: timestamp + random\n            return `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n        }\n    }\n\n    /**\n     * Clear session (force new session on next page load)\n     */\n    clearSession() {\n        try {\n            localStorage.removeItem(this.STORAGE_KEY_SESSION_ID);\n            localStorage.removeItem(this.STORAGE_KEY_SESSION_METADATA);\n\n            this.sessionId = null;\n            this.metadata = {\n                startedAt: null,\n                lastActivityAt: null,\n                pageCount: 0,\n                pages: [],\n            };\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Session cleared');\n            }\n        } catch (error) {\n            console.error('SessionManager: Failed to clear session:', error);\n        }\n    }\n\n    /**\n     * Extend session (reset idle timeout)\n     */\n    extendSession() {\n        try {\n            this.updateActivity();\n\n            if (this.config.debug) {\n                console.warn('SessionManager: Session extended');\n            }\n        } catch (error) {\n            console.error('SessionManager: Failed to extend session:', error);\n        }\n    }\n\n    /**\n     * Get session info for debugging\n     *\n     * @returns {Object}\n     */\n    getSessionInfo() {\n        return {\n            sessionId: this.sessionId,\n            age: this.getSessionAge(),\n            ageMinutes: Math.floor(this.getSessionAge() / 1000 / 60),\n            isExpired: this.isSessionExpired(),\n            pageCount: this.metadata.pageCount,\n            recentPages: this.metadata.pages.slice(-5),\n            timeoutMinutes: this.config.sessionTimeoutMinutes,\n        };\n    }\n}\n","/**\n * Storage Manager - localStorage Management for Replay Buffer\n *\n * Manages localStorage for replay buffer persistence across pages.\n * Handles quota management, compression, and cleanup.\n *\n * Features:\n * - Save/load replay buffer to/from localStorage\n * - Quota management (prevents quota exceeded errors)\n * - Automatic cleanup of old sessions\n * - LRU eviction when quota is tight\n * - Size monitoring and reporting\n */\nexport class StorageManager {\n    /**\n     * @param {Object} [config] - Configuration options\n     * @param {number} [config.maxBufferSizeMB=5] - Maximum buffer size in MB\n     * @param {boolean} [config.debug=false] - Enable debug logging\n     */\n    constructor(config = {}) {\n        this.config = {\n            maxBufferSizeMB: Math.min(config.maxBufferSizeMB || 5, 20),\n            debug: config.debug || false,\n        };\n\n        // localStorage keys\n        this.STORAGE_KEY_BUFFER = '_app_logger_replay_buffer';\n        this.STORAGE_KEY_METADATA = '_app_logger_replay_metadata';\n\n        // Statistics\n        this.stats = {\n            savesSuccessful: 0,\n            savesFailed: 0,\n            loadsSuccessful: 0,\n            loadsFailed: 0,\n            quotaExceededCount: 0,\n            cleanupCount: 0,\n        };\n\n        if (this.config.debug) {\n            console.warn('StorageManager initialized with config:', this.config);\n        }\n    }\n\n    /**\n     * Save replay buffer to localStorage\n     *\n     * @param {Object} bufferData - Serialized buffer data from ReplayBuffer\n     * @returns {boolean} Success\n     */\n    save(bufferData) {\n        try {\n            if (!bufferData || typeof bufferData !== 'object') {\n                console.warn('StorageManager: Invalid buffer data');\n                return false;\n            }\n\n            // Check size before saving\n            const estimatedSize = this.estimateSize(bufferData);\n            const maxSizeBytes = this.config.maxBufferSizeMB * 1024 * 1024;\n\n            if (estimatedSize > maxSizeBytes) {\n                if (this.config.debug) {\n                    console.warn('StorageManager: Buffer too large', {\n                        size: estimatedSize,\n                        max: maxSizeBytes,\n                        sizeMB: (estimatedSize / 1024 / 1024).toFixed(2),\n                    });\n                }\n\n                // Try to make space\n                this.cleanup();\n\n                // If still too large, prune the buffer\n                if (estimatedSize > maxSizeBytes) {\n                    bufferData = this.pruneBuffer(bufferData, maxSizeBytes);\n                }\n            }\n\n            // Save to localStorage\n            localStorage.setItem(this.STORAGE_KEY_BUFFER, JSON.stringify(bufferData));\n\n            // Save metadata\n            this.saveMetadata({\n                savedAt: Date.now(),\n                size: estimatedSize,\n            });\n\n            this.stats.savesSuccessful++;\n\n            if (this.config.debug) {\n                console.warn('StorageManager: Buffer saved', {\n                    size: estimatedSize,\n                    events: bufferData.buffer?.length || 0,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            this.stats.savesFailed++;\n\n            if (error.name === 'QuotaExceededError') {\n                this.stats.quotaExceededCount++;\n\n                if (this.config.debug) {\n                    console.warn('StorageManager: Quota exceeded, attempting cleanup');\n                }\n\n                // Try to make space and retry\n                this.cleanup();\n\n                try {\n                    // Retry with pruned buffer\n                    const prunedBuffer = this.pruneBuffer(\n                        bufferData,\n                        this.config.maxBufferSizeMB * 1024 * 1024 / 2, // Use half max size\n                    );\n\n                    localStorage.setItem(\n                        this.STORAGE_KEY_BUFFER,\n                        JSON.stringify(prunedBuffer),\n                    );\n\n                    this.stats.savesSuccessful++;\n                    return true;\n                } catch {\n                    console.error('StorageManager: Failed to save even after cleanup');\n                    return false;\n                }\n            }\n\n            console.error('StorageManager: Failed to save buffer:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Load replay buffer from localStorage\n     *\n     * @returns {Object|null} Buffer data or null if not found/invalid\n     */\n    load() {\n        try {\n            const stored = localStorage.getItem(this.STORAGE_KEY_BUFFER);\n\n            if (!stored) {\n                return null;\n            }\n\n            const bufferData = JSON.parse(stored);\n\n            if (!bufferData || typeof bufferData !== 'object') {\n                return null;\n            }\n\n            // Validate buffer structure\n            if (!Array.isArray(bufferData.buffer)) {\n                console.warn('StorageManager: Invalid buffer structure');\n                return null;\n            }\n\n            this.stats.loadsSuccessful++;\n\n            if (this.config.debug) {\n                console.warn('StorageManager: Buffer loaded', {\n                    events: bufferData.buffer.length,\n                    isRecording: bufferData.isRecordingAfterError,\n                });\n            }\n\n            return bufferData;\n        } catch (error) {\n            this.stats.loadsFailed++;\n            console.error('StorageManager: Failed to load buffer:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Clear replay buffer from localStorage\n     */\n    clear() {\n        try {\n            localStorage.removeItem(this.STORAGE_KEY_BUFFER);\n            localStorage.removeItem(this.STORAGE_KEY_METADATA);\n\n            if (this.config.debug) {\n                console.warn('StorageManager: Buffer cleared');\n            }\n        } catch (error) {\n            console.error('StorageManager: Failed to clear buffer:', error);\n        }\n    }\n\n    /**\n     * Clean up old/expired data\n     */\n    cleanup() {\n        try {\n            // Remove old buffer if it exists\n            const metadata = this.loadMetadata();\n\n            if (metadata && metadata.savedAt) {\n                const age = Date.now() - metadata.savedAt;\n                const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n\n                if (age > maxAge) {\n                    this.clear();\n                    this.stats.cleanupCount++;\n\n                    if (this.config.debug) {\n                        console.warn('StorageManager: Cleaned up old buffer', {\n                            ageHours: (age / 1000 / 60 / 60).toFixed(1),\n                        });\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('StorageManager: Cleanup failed:', error);\n        }\n    }\n\n    /**\n     * Save metadata\n     *\n     * @param {Object} metadata\n     */\n    saveMetadata(metadata) {\n        try {\n            localStorage.setItem(\n                this.STORAGE_KEY_METADATA,\n                JSON.stringify(metadata),\n            );\n        } catch (error) {\n            // Metadata save failure is not critical\n            if (this.config.debug) {\n                console.warn('StorageManager: Failed to save metadata:', error);\n            }\n        }\n    }\n\n    /**\n     * Load metadata\n     *\n     * @returns {Object|null}\n     */\n    loadMetadata() {\n        try {\n            const stored = localStorage.getItem(this.STORAGE_KEY_METADATA);\n\n            if (!stored) {\n                return null;\n            }\n\n            return JSON.parse(stored);\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Prune buffer to fit within size limit\n     *\n     * @param {Object} bufferData\n     * @param {number} maxSizeBytes\n     * @returns {Object} Pruned buffer\n     */\n    pruneBuffer(bufferData, maxSizeBytes) {\n        try {\n            if (!bufferData.buffer || !Array.isArray(bufferData.buffer)) {\n                return bufferData;\n            }\n\n            // Start by keeping all events\n            const pruned = { ...bufferData };\n            const events = [...bufferData.buffer];\n\n            // Remove oldest events until we fit\n            while (this.estimateSize(pruned) > maxSizeBytes && events.length > 1) {\n                // Remove oldest event (but keep error marker)\n                const removed = events.shift();\n\n                // If we removed an error marker, put it back\n                if (removed && removed.phase === 'error') {\n                    events.unshift(removed);\n                    break;\n                }\n\n                pruned.buffer = events;\n            }\n\n            if (this.config.debug) {\n                console.warn('StorageManager: Buffer pruned', {\n                    originalEvents: bufferData.buffer.length,\n                    prunedEvents: events.length,\n                    originalSize: this.estimateSize(bufferData),\n                    prunedSize: this.estimateSize(pruned),\n                });\n            }\n\n            return pruned;\n        } catch (error) {\n            console.error('StorageManager: Failed to prune buffer:', error);\n            return bufferData;\n        }\n    }\n\n    /**\n     * Estimate size of data in bytes\n     *\n     * @param {Object} data\n     * @returns {number} Size in bytes\n     */\n    estimateSize(data) {\n        try {\n            const json = JSON.stringify(data);\n            return json.length;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Get available localStorage space (approximate)\n     *\n     * @returns {Object} Space info\n     */\n    getSpaceInfo() {\n        try {\n            const testKey = '_app_logger_space_test';\n            const testData = '0'.repeat(1024); // 1KB test string\n\n            let available = 0;\n            let used = 0;\n\n            // Estimate used space\n            for (const key in localStorage) {\n                if (Object.prototype.hasOwnProperty.call(localStorage, key)) {\n                    used += localStorage[key].length + key.length;\n                }\n            }\n\n            // Estimate available space (crude test)\n            try {\n                for (let i = 0; i < 10000; i++) {\n                    localStorage.setItem(testKey, testData.repeat(i));\n                    available = i * 1024;\n                }\n            } catch {\n                // Quota exceeded - we found the limit\n            } finally {\n                localStorage.removeItem(testKey);\n            }\n\n            return {\n                usedBytes: used,\n                usedMB: (used / 1024 / 1024).toFixed(2),\n                availableMB: (available / 1024 / 1024).toFixed(2),\n                totalMB: ((used + available) / 1024 / 1024).toFixed(2),\n            };\n        } catch {\n            return {\n                usedBytes: 0,\n                usedMB: 'unknown',\n                availableMB: 'unknown',\n                totalMB: 'unknown',\n            };\n        }\n    }\n\n    /**\n     * Get storage statistics\n     *\n     * @returns {Object}\n     */\n    getStats() {\n        const spaceInfo = this.getSpaceInfo();\n\n        return {\n            ...this.stats,\n            ...spaceInfo,\n            maxBufferSizeMB: this.config.maxBufferSizeMB,\n        };\n    }\n\n    /**\n     * Check if localStorage is available\n     *\n     * @returns {boolean}\n     */\n    isAvailable() {\n        try {\n            const testKey = '_app_logger_test';\n            localStorage.setItem(testKey, 'test');\n            localStorage.removeItem(testKey);\n            return true;\n        } catch {\n            return false;\n        }\n    }\n}\n","/**\n * Application Logger JavaScript SDK\n *\n * ERROR-TRIGGERED SESSION REPLAY:\n * - Only captures replay when errors occur (not continuously)\n * - Buffers N seconds/clicks before and after error\n * - Cross-page session continuity via localStorage\n * - Privacy-first (no PII in DOM snapshots)\n *\n * FEATURES:\n * - JavaScript error capture and reporting\n * - Session replay on error (configurable buffer size)\n * - Breadcrumb tracking for debugging context\n * - Click heatmap for user behavior analysis\n *\n * @module ApplicationLogger\n */\n\nimport { Client } from './client.js';\nimport { BreadcrumbCollector } from './breadcrumbs.js';\nimport { Transport } from './transport.js';\nimport { ClickTracker } from './click-tracker.js';\nimport { ReplayBuffer } from './replay-buffer.js';\nimport { ErrorDetector } from './error-detector.js';\nimport { SessionManager } from './session-manager.js';\nimport { StorageManager } from './storage-manager.js';\n\n/**\n * Main ApplicationLogger class\n */\nclass ApplicationLogger {\n    /**\n     * @param {Object} config Configuration options\n     * @param {string} config.dsn Data Source Name (project endpoint URL)\n     * @param {string} config.apiKey API Key for authentication\n     * @param {string} [config.release] Application version/release\n     * @param {string} [config.environment] Environment (production, staging, etc.)\n     * @param {boolean} [config.debug=false] Enable debug logging\n     * @param {string[]} [config.scrubFields] Additional fields to scrub\n     *\n     * Session Replay Configuration (error-triggered only):\n     * @param {boolean} [config.sessionReplayEnabled=true] Enable session replay on errors\n     * @param {number} [config.bufferBeforeErrorSeconds=30] Seconds to buffer before error (max 60)\n     * @param {number} [config.bufferBeforeErrorClicks=10] Clicks to buffer before error (max 15)\n     * @param {number} [config.bufferAfterErrorSeconds=30] Seconds to buffer after error (max 60)\n     * @param {number} [config.bufferAfterErrorClicks=10] Clicks to buffer after error (max 15)\n     * @param {number} [config.snapshotThrottleMs=1000] DOM snapshot throttle (min 500ms)\n     * @param {number} [config.maxSnapshotSize=1048576] Max snapshot size (default 1MB)\n     * @param {number} [config.sessionTimeoutMinutes=30] Session timeout (max 120 min)\n     * @param {number} [config.maxBufferSizeMB=5] Max localStorage buffer size (max 20MB)\n     * @param {boolean} [config.exposeApi=true] Expose control API for developers\n     *\n     * Resilience Configuration (transport layer):\n     * @param {number} [config.circuitBreakerFailureThreshold=5] Failures before circuit opens\n     * @param {number} [config.circuitBreakerTimeoutMs=60000] Circuit breaker timeout (ms)\n     * @param {number} [config.storageQueueMaxSize=50] Max errors in offline queue\n     * @param {number} [config.storageQueueMaxAgeMs=86400000] Max age for queued errors (24h)\n     * @param {number} [config.rateLimiterMaxTokens=10] Max errors per minute\n     * @param {number} [config.rateLimiterRefillRate=0.167] Token refill rate (~10/min)\n     * @param {number} [config.deduplicationWindowMs=5000] Duplicate detection window (ms)\n     */\n    constructor(config) {\n        // Validate required configuration\n        if (!config || !config.dsn) {\n            throw new Error('ApplicationLogger: DSN is required. Expected format: https://host/project-id');\n        }\n\n        if (!config.apiKey) {\n            throw new Error('ApplicationLogger: API Key is required for authentication');\n        }\n\n        this.config = {\n            // Core config\n            debug: false,\n            scrubFields: ['password', 'token', 'api_key', 'secret'],\n\n            // Session replay config (error-triggered only)\n            sessionReplayEnabled: true,\n            bufferBeforeErrorSeconds: 30,\n            bufferBeforeErrorClicks: 10,\n            bufferAfterErrorSeconds: 30,\n            bufferAfterErrorClicks: 10,\n            snapshotThrottleMs: 1000,\n            maxSnapshotSize: 1048576, // 1MB\n            sessionTimeoutMinutes: 30,\n            maxBufferSizeMB: 5,\n            exposeApi: true,\n\n            // Resilience config (transport layer)\n            circuitBreakerFailureThreshold: 5,\n            circuitBreakerTimeoutMs: 60000, // 60 seconds\n            storageQueueMaxSize: 50,\n            storageQueueMaxAgeMs: 86400000, // 24 hours\n            rateLimiterMaxTokens: 10,\n            rateLimiterRefillRate: 0.167, // ~10 tokens per minute\n            deduplicationWindowMs: 5000, // 5 seconds\n\n            // Merge user config\n            ...config,\n        };\n\n        // Initialize core components\n        this.transport = new Transport(this.config);\n\n        // Initialize breadcrumbs with error capture callback\n        // This enables zero-config error tracking: console.error(err) automatically captures\n        this.breadcrumbs = new BreadcrumbCollector(\n            50, // maxBreadcrumbs\n            (error, options) => {\n                // Debug log\n                if (this.config && this.config.debug) {\n                    console.warn('ApplicationLogger: Auto-capturing error from console.error()', error);\n                }\n                this.captureException(error, options);\n            }, // errorCaptureCallback\n        );\n\n        // Initialize session replay components (if enabled)\n        this.sessionManager = null;\n        this.replayBuffer = null;\n        this.storageManager = null;\n        this.errorDetector = null;\n        this.heatmap = null;\n\n        if (this.config.sessionReplayEnabled) {\n            this.initializeSessionReplay();\n        }\n\n        // Initialize client (with optional errorDetector and sessionManager)\n        this.client = new Client(\n            this.config,\n            this.transport,\n            this.breadcrumbs,\n            this.errorDetector,\n            this.sessionManager,\n        );\n\n        this.initialized = false;\n    }\n\n    /**\n     * Initialize session replay components\n     */\n    initializeSessionReplay() {\n        try {\n            // Session manager (cross-page sessions)\n            this.sessionManager = new SessionManager({\n                sessionTimeoutMinutes: this.config.sessionTimeoutMinutes,\n                debug: this.config.debug,\n            });\n\n            // Replay buffer (circular buffer for events)\n            this.replayBuffer = new ReplayBuffer({\n                bufferBeforeErrorSeconds: this.config.bufferBeforeErrorSeconds,\n                bufferBeforeErrorClicks: this.config.bufferBeforeErrorClicks,\n                bufferAfterErrorSeconds: this.config.bufferAfterErrorSeconds,\n                bufferAfterErrorClicks: this.config.bufferAfterErrorClicks,\n                maxBufferSizeMB: this.config.maxBufferSizeMB,\n                debug: this.config.debug,\n            });\n\n            // Storage manager (localStorage persistence)\n            this.storageManager = new StorageManager({\n                maxBufferSizeMB: this.config.maxBufferSizeMB,\n                debug: this.config.debug,\n            });\n\n            // Error detector (triggers replay on error)\n            this.errorDetector = new ErrorDetector(\n                this.replayBuffer,\n                this.sessionManager,\n                this.handleReplayCapture.bind(this),\n                this.transport, // Pass transport for recovery session sending\n                {\n                    debug: this.config.debug,\n                    ignoreErrors: [],\n                },\n            );\n\n            // Click tracker (click recording to buffer for session replay)\n            this.heatmap = new ClickTracker(\n                this.replayBuffer,\n                this.sessionManager,\n                this.config,\n            );\n\n            // Load existing buffer from localStorage (cross-page continuity)\n            const savedBuffer = this.storageManager.load();\n            if (savedBuffer) {\n                this.replayBuffer.deserialize(savedBuffer);\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Loaded replay buffer from localStorage', {\n                        events: savedBuffer.buffer?.length || 0,\n                    });\n                }\n            }\n\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Session replay initialized');\n            }\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to initialize session replay', error);\n            // Disable session replay on initialization failure\n            this.config.sessionReplayEnabled = false;\n        }\n    }\n\n    /**\n     * Handle replay capture when error is detected\n     *\n     * Called by ErrorDetector after buffering is complete.\n     * Saves buffer to localStorage for cross-page continuity.\n     *\n     * Note: Replay data is sent WITH the error payload in client.captureException(),\n     * not as a separate request. This callback is just for localStorage persistence.\n     *\n     * @param {Object} errorContext - Error context\n     * @param {Array} events - Buffered events (before + after error)\n     * @param {Object} errorPayload - Original error payload sent to backend (unused here)\n     */\n    // eslint-disable-next-line no-unused-vars\n    async handleReplayCapture(errorContext, events, errorPayload) {\n        try {\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Replay captured for error', {\n                    errorMessage: errorContext.message,\n                    eventCount: events.length,\n                    sessionId: this.sessionManager.getSessionId(),\n                });\n            }\n\n            // Save buffer to localStorage for cross-page continuity\n            const serialized = this.replayBuffer.serialize();\n            this.storageManager.save(serialized);\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to save replay buffer', error);\n        }\n    }\n\n    /**\n     * Initialize the SDK and start capturing errors\n     *\n     * IMPORTANT: Initialization order matters for reliability:\n     * 1. Breadcrumbs install first (wraps console/fetch before errors occur)\n     * 2. Session replay components (heatmap, error detector)\n     * 3. Error handlers install last (processes buffered errors, then goes live)\n     */\n    init() {\n        if (this.initialized) {\n            console.warn('ApplicationLogger already initialized');\n            return;\n        }\n\n        // 1. Install breadcrumbs FIRST (wraps console/fetch immediately)\n        // This ensures we capture breadcrumbs for any errors that occur during init\n        this.breadcrumbs.install();\n\n        // 2. Install session replay tracking (if enabled)\n        if (this.config.sessionReplayEnabled && this.heatmap) {\n            this.heatmap.install();\n            this.errorDetector.install();\n\n            // Periodic saves to localStorage (every 5 seconds)\n            // This ensures buffer persists even if page closes unexpectedly\n            this.bufferSaveInterval = setInterval(() => {\n                this.saveBufferToStorage();\n            }, 5000);\n\n            // Save buffer to localStorage on page unload\n            window.addEventListener('beforeunload', () => {\n                this.saveBufferToStorage();\n            });\n\n            // Also save on visibility change (mobile)\n            document.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'hidden') {\n                    this.saveBufferToStorage();\n                }\n            });\n\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Session replay enabled (error-triggered, periodic saves every 5s)');\n            }\n        }\n\n        // 3. Install error capture LAST (processes buffered errors, then starts live capture)\n        // Note: breadcrumbs.install() is called again in client.install() but it's idempotent\n        this.client.install();\n\n        this.initialized = true;\n\n        if (this.config.debug) {\n            const sdkLoadTime = window._appLoggerBuffer?.startTime\n                ? Date.now() - window._appLoggerBuffer.startTime\n                : 'unknown';\n\n            console.warn('ApplicationLogger initialized', {\n                environment: this.config.environment,\n                release: this.config.release,\n                sessionReplayEnabled: this.config.sessionReplayEnabled,\n                sessionId: this.sessionManager?.getSessionId(),\n                sdkLoadTime: sdkLoadTime + 'ms',\n                bufferedErrors: window._appLoggerBuffer?.errors?.length || 0,\n            });\n        }\n    }\n\n    /**\n     * Save buffer to localStorage for cross-page continuity\n     */\n    saveBufferToStorage() {\n        try {\n            if (this.replayBuffer && this.storageManager) {\n                const serialized = this.replayBuffer.serialize();\n                this.storageManager.save(serialized);\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Buffer saved to localStorage');\n                }\n            }\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to save buffer', error);\n        }\n    }\n\n    /**\n   * Manually capture an exception\n   *\n   * @param {Error} error The error to capture\n   * @param {Object} [options] Additional options\n   * @param {Object} [options.tags] Key-value tags\n   * @param {Object} [options.extra] Additional context data\n   */\n    captureException(error, options = {}) {\n        this.client.captureException(error, options);\n    }\n\n    /**\n   * Manually capture a message\n   *\n   * @param {string} message The message to capture\n   * @param {string} [level='info'] Log level\n   * @param {Object} [options] Additional options\n   */\n    captureMessage(message, level = 'info', options = {}) {\n        this.client.captureMessage(message, level, options);\n    }\n\n    /**\n   * Add a breadcrumb\n   *\n   * @param {Object} breadcrumb Breadcrumb data\n   * @param {string} breadcrumb.type Breadcrumb type (navigation, http, user, etc.)\n   * @param {string} breadcrumb.category Category\n   * @param {string} breadcrumb.message Message\n   * @param {Object} [breadcrumb.data] Additional data\n   * @param {string} [breadcrumb.level='info'] Log level\n   */\n    addBreadcrumb(breadcrumb) {\n        this.breadcrumbs.add(breadcrumb);\n    }\n\n    /**\n   * Set user context\n   *\n   * @param {Object} user User data\n   * @param {string} [user.id] User ID\n   * @param {string} [user.email] User email\n   * @param {string} [user.username] Username\n   */\n    setUser(user) {\n        this.client.setUser(user);\n    }\n\n    /**\n   * Set tags\n   *\n   * @param {Object} tags Key-value tags\n   */\n    setTags(tags) {\n        this.client.setTags(tags);\n    }\n\n    /**\n     * Set extra context\n     *\n     * @param {Object} extra Key-value extra data\n     */\n    setExtra(extra) {\n        this.client.setExtra(extra);\n    }\n\n    /**\n     * Session Replay API - exposed for developer control\n     *\n     * Allows developers to let users control session replay:\n     * - window.ApplicationLogger.sessionReplay.enable()\n     * - window.ApplicationLogger.sessionReplay.disable()\n     * - window.ApplicationLogger.sessionReplay.isEnabled()\n     */\n    get sessionReplay() {\n        if (!this.config.exposeApi) {\n            return null;\n        }\n\n        return {\n            /**\n             * Enable session replay recording\n             */\n            enable: () => {\n                if (!this.config.sessionReplayEnabled) {\n                    this.config.sessionReplayEnabled = true;\n\n                    // Re-initialize if not already initialized\n                    if (!this.heatmap) {\n                        this.initializeSessionReplay();\n                        if (this.initialized && this.heatmap) {\n                            this.heatmap.install();\n                            this.errorDetector.install();\n                        }\n                    }\n\n                    if (this.config.debug) {\n                        console.warn('ApplicationLogger: Session replay enabled');\n                    }\n                }\n            },\n\n            /**\n             * Disable session replay recording\n             */\n            disable: () => {\n                if (this.config.sessionReplayEnabled) {\n                    this.config.sessionReplayEnabled = false;\n\n                    // Clear the buffer save interval (prevents memory leak in SPAs)\n                    if (this.bufferSaveInterval) {\n                        clearInterval(this.bufferSaveInterval);\n                        this.bufferSaveInterval = null;\n                    }\n\n                    // Clean up and save buffer\n                    if (this.heatmap) {\n                        this.heatmap.cleanup();\n                    }\n                    if (this.errorDetector) {\n                        this.errorDetector.uninstall();\n                    }\n                    this.saveBufferToStorage();\n\n                    if (this.config.debug) {\n                        console.warn('ApplicationLogger: Session replay disabled');\n                    }\n                }\n            },\n\n            /**\n             * Check if session replay is enabled\n             * @returns {boolean}\n             */\n            isEnabled: () => {\n                return this.config.sessionReplayEnabled;\n            },\n\n            /**\n             * Get session replay statistics for debugging\n             * @returns {Object}\n             */\n            getStats: () => {\n                if (!this.config.sessionReplayEnabled) {\n                    return { enabled: false };\n                }\n\n                return {\n                    enabled: true,\n                    sessionId: this.sessionManager?.getSessionId(),\n                    sessionAge: this.sessionManager?.getSessionAge(),\n                    bufferStats: this.replayBuffer?.getStats(),\n                    storageStats: this.storageManager?.getStats(),\n                    domCaptureStats: this.heatmap?.getDOMCaptureStats(),\n                    debounceStats: this.heatmap?.getDebounceStats(),\n                    errorDetectorStats: this.errorDetector?.getStats(),\n                };\n            },\n        };\n    }\n}\n\n// Export for ES modules\nexport default ApplicationLogger;\n\n// Export for UMD (window.ApplicationLogger)\nif (typeof window !== 'undefined') {\n    window.ApplicationLogger = ApplicationLogger;\n}\n"],"names":["Client","constructor","config","transport","breadcrumbs","errorDetector","sessionManager","this","userContext","tags","extra","pendingBeaconErrors","cachedSessionHash","install","initSessionHash","catch","processResurrectedErrors","processBufferedErrors","window","addEventListener","event","captureException","error","Error","message","filename","lineno","colno","console","reason","type","flushBeaconErrors","document","visibilityState","NUCLEAR_KEY","RESURRECTION_ATTEMPTS_KEY","MAX_ATTEMPTS","MAX_AGE_MS","attempts","parseInt","localStorage","getItem","debug","warn","removeItem","stored","errors","JSON","parse","parseError","Array","isArray","length","now","Date","validErrors","filter","err","t","succeeded","failed","m","String","name","errorAge","resurrected","nuclear","resurrectTimestamp","originalTimestamp","Math","floor","f","l","c","originalUrl","u","sessionGap","sendError","setItem","_appLoggerBuffer","buffered","processed","item","stack","bufferedAt","timestamp","itemError","countClickEvents","events","options","payload","buildPayload","replayBuffer","replayContext","handleError","replayData","preErrorEvents","phase","clickCount","sessionId","totalEvents","clickEvents","bufferStats","getStats","hasContext","hasEvents","eventCount","send","startRecoveryRecording","recoveryError","replayError","captureError","captureMessage","level","stackTrace","parseStackTrace","firstFrame","truncate","file","line","stack_trace","source","environment","release","url","location","href","http_method","detectHttpMethod","http_status_code","extractHttpStatusCode","session_hash","getSessionHash","session_id","getSessionId","toISOString","runtime","getBrowserInfo","user_agent","navigator","userAgent","get","context","removeNullValues","value","maxLength","substring","function","lines","split","frames","frame","parseStackLine","trim","push","match","column","navigation","performance","getEntriesByType","status","httpStatusCode","ua","includes","sessionHash","getOrCreateSessionId","djb2Hash","generateSessionId","crypto","randomUUID","replace","r","random","toString","subtle","data","TextEncoder","encode","hashBuffer","digest","hashArray","from","Uint8Array","map","b","padStart","join","sessionStorage","str","hash","i","charCodeAt","abs","obj","cleaned","key","Object","entries","setUser","user","setTags","setExtra","sendBeacon","stats","storedErrors","queueSize","flushWithBeacon","BreadcrumbCollector","maxBreadcrumbs","errorCaptureCallback","installed","getClassName","element","className","undefined","baseVal","target","tagName","toLowerCase","id","firstClass","add","category","tag","class","originalPushState","history","pushState","originalReplaceState","replaceState","args","to","apply","wrapConsole","wrapFetch","breadcrumb","shift","clear","forEach","original","errorObj","find","arg","consoleError","consoleMessage","call","result","safeArgs","stringify","prototype","arguments","originalFetch","fetch","async","method","startTime","response","duration","status_code","ok","CircuitBreaker","static","failureThreshold","timeout","storageKey","loadState","isOpen","state","STATE_OPEN","shouldAttemptReset","halfOpen","isHalfOpen","STATE_HALF_OPEN","recordSuccess","close","STATE_CLOSED","failureCount","saveState","recordFailure","open","getState","openedAt","reset","StorageQueue","maxSize","maxAge","enqueue","queue","getQueue","saveQueue","dequeue","getAll","size","filtered","halfSize","trimmed","slice","RateLimiter","maxTokens","refillRate","tokens","lastRefill","isAllowed","refillTokens","consume","elapsed","tokensToAdd","min","getTokens","Transport","apiKey","dsn","parseDsn","sending","circuitBreaker","circuitBreakerFailureThreshold","circuitBreakerTimeoutMs","storageQueue","storageQueueMaxSize","storageQueueMaxAgeMs","rateLimiter","rateLimiterMaxTokens","rateLimiterRefillRate","recentErrors","Map","deduplicationWindow","deduplicationWindowMs","flushStoredErrors","URL","projectId","pathname","protocol","host","endpoint","enhancedPayload","replay_session_id","replay_data","scrubbedPayload","scrubSensitiveData","isDuplicate","processQueue","sendRecoverySession","recoveryPayload","useBeacon","payloadWithAuth","blob","Blob","success","controller","AbortController","timeoutId","setTimeout","abort","headers","body","signal","clearTimeout","json","queueError","sendToApi","attempt","statusText","delay","pow","signature","simpleHash","has","set","delete","limit","ms","Promise","resolve","scrubPatterns","scrubFields","scrubbed","removeCircularReferences","scrubObject","hasOwnProperty","some","pattern","seen","WeakSet","sendSessionEvent","eventData","sendReplayClicks","clicks","rateLimitTokens","allErrors","errorsToSend","beaconPayload","DOMSerializer","maxDepth","minSize","skipInvisible","captureColors","totalElements","skippedInvisible","skippedTiny","skippedNonVisual","maxDepthReached","serialize","rootElement","viewport","width","innerWidth","height","innerHeight","scrollX","scrollY","tree","serializeElement","elapsedMs","toFixed","depth","isNonVisualElement","style","getComputedStyle","isInvisible","rect","getBoundingClientRect","serialized","bounds","x","round","left","y","top","bgColor","extractBackgroundColor","layout","detectLayoutType","isInteractive","isText","isTextContainer","children","childElements","child","serializedChild","display","visibility","parseFloat","opacity","bottom","right","backgroundColor","rgbToHex","rgb","g","toHex","n","hex","onclick","hasAttribute","cursor","estimateSize","compress","removeNulls","ThrottledDOMSerializer","serializer","throttleMs","lastCaptureTime","pendingCapture","timeSinceLastCapture","remainingTime","clearThrottle","ClickTracker","isInstalled","max","snapshotThrottleMs","domSerializer","maxSnapshotSize","domCaptureStats","total","throttled","captured","lastClickTime","clickDebounceMs","debounceStats","totalClicks","debouncedClicks","captureClick","timeSinceLastClick","debounceThreshold","clickEvent","clickData","pageX","pageY","viewportWidth","viewportHeight","elementSelector","generateSelector","domSnapshot","elements","sizeBytes","sizeKB","domError","addEvent","parts","current","selector","containsSensitiveData","CSS","escape","unshift","classes","getCleanClasses","siblings","parentElement","indexOf","classList","cls","test","getDOMCaptureStats","serializerStats","getDebounceStats","debounceRate","cleanup","ReplayBuffer","bufferBeforeErrorSeconds","bufferBeforeErrorClicks","bufferAfterErrorSeconds","bufferAfterErrorClicks","maxBufferSizeMB","buffer","isRecordingAfterError","recordingStartedAt","errorOccurredAt","postErrorEventCount","eventsDropped","bufferFullCount","currentBufferSize","capturedAt","shouldStopRecording","stopRecording","pruneOldEvents","updateStats","startRecordingAfterError","errorContext","errorId","bufferSize","willRecordFor","postErrorEvents","elapsedSeconds","cutoffTime","timeFiltered","e","otherEvents","recentClicks","sort","a","dropped","getEvents","getEventsByPhase","isRecording","bufferLength","approximateSize","estimateBufferSize","deserialize","migratedCount","phaseBreakdown","reduce","acc","migratedEvents","byteSize","ErrorDetector","onErrorDetected","ignoreErrors","Set","recentErrorsCleanupInterval","isRecordingRecovery","recoveryRecordingCleanup","errorsDetected","errorsIgnored","replaysCaptured","duplicatesPrevented","recoveryRecordingsStarted","recoveryRecordingsCancelled","setInterval","uninstall","clearInterval","errorPayload","shouldIgnoreError","errorFingerprint","generateErrorFingerprint","errorMessage","beforeError","afterError","handlingError","commonIgnorePatterns","checkCompleteInterval","unloadHandler","visibilityHandler","removeEventListener","finishRecording","recoveryEvents","once","recovery","recentErrorsCount","setEnabled","enabled","isEnabled","SessionManager","sessionTimeoutMinutes","STORAGE_KEY_SESSION_ID","STORAGE_KEY_SESSION_METADATA","metadata","startedAt","lastActivityAt","pageCount","pages","initialize","loadSession","isSessionExpired","createNewSession","updateActivity","trackPageView","setupPageTransitionTracking","saveSession","metadataJson","age","getSessionAge","lastActivity","pageEvent","handleNavigationChange","getMetadata","clearSession","extendSession","getSessionInfo","ageMinutes","isExpired","recentPages","timeoutMinutes","StorageManager","STORAGE_KEY_BUFFER","STORAGE_KEY_METADATA","savesSuccessful","savesFailed","loadsSuccessful","loadsFailed","quotaExceededCount","cleanupCount","save","bufferData","estimatedSize","maxSizeBytes","sizeMB","pruneBuffer","saveMetadata","savedAt","prunedBuffer","load","loadMetadata","ageHours","pruned","removed","originalEvents","prunedEvents","originalSize","prunedSize","getSpaceInfo","testKey","testData","repeat","available","used","usedBytes","usedMB","availableMB","totalMB","spaceInfo","isAvailable","ApplicationLogger","sessionReplayEnabled","exposeApi","storageManager","heatmap","initializeSessionReplay","client","initialized","handleReplayCapture","bind","savedBuffer","init","bufferSaveInterval","saveBufferToStorage","sdkLoadTime","bufferedErrors","addBreadcrumb","sessionReplay","enable","disable","sessionAge","storageStats","errorDetectorStats"],"mappings":"AAaO,MAAMA,EAQT,WAAAC,CAAYC,EAAQC,EAAWC,EAAaC,EAAgB,KAAMC,EAAiB,MAC/EC,KAAKL,OAASA,EACdK,KAAKJ,UAAYA,EACjBI,KAAKH,YAAcA,EACnBG,KAAKF,cAAgBA,EACrBE,KAAKD,eAAiBA,EACtBC,KAAKC,YAAc,KACnBD,KAAKE,KAAO,CAAA,EACZF,KAAKG,MAAQ,CAAA,EACbH,KAAKI,oBAAsB,GAC3BJ,KAAKK,kBAAoB,IAC7B,CAUA,OAAAC,GACI,IAGIN,KAAKO,kBAAkBC,MAAM,QAM7BR,KAAKS,2BAGLT,KAAKU,wBAGLC,OAAOC,iBAAiB,QAAUC,IAC9B,IACIb,KAAKc,iBAAiBD,EAAME,OAAS,IAAIC,MAAMH,EAAMI,SAAU,CAC3Dd,MAAO,CACHe,SAAUL,EAAMK,SAChBC,OAAQN,EAAMM,OACdC,MAAOP,EAAMO,QAGzB,CAAE,MAAOL,GAELM,QAAQN,MAAM,6CAA8CA,EAChE,IAIJJ,OAAOC,iBAAiB,qBAAuBC,IAC3C,IACIb,KAAKc,iBAAiBD,EAAMS,OAAQ,CAChCnB,MAAO,CACHoB,KAAM,uBAGlB,CAAE,MAAOR,GACLM,QAAQN,MAAM,iDAAkDA,EACpE,IAIJJ,OAAOC,iBAAiB,eAAgB,KACpCZ,KAAKwB,sBAITC,SAASb,iBAAiB,mBAAoB,KACT,WAA7Ba,SAASC,iBACT1B,KAAKwB,sBAKbxB,KAAKH,YAAYS,SACrB,CAAE,MAAOS,GAELM,QAAQN,MAAM,uCAAwCA,EAC1D,CACJ,CAsBA,wBAAAN,GACI,IACI,MAAMkB,EAAc,qBACdC,EAA4B,mCAC5BC,EAAe,EACfC,EAAa,MAGbC,EAAWC,SAASC,aAAaC,QAAQN,IAA8B,IAAK,IAClF,GAAIG,GAAYF,EAMZ,OALI7B,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,iFAEjBH,aAAaI,WAAWV,QACxBM,aAAaI,WAAWT,GAK5B,MAAMU,EAASL,aAAaC,QAAQP,GACpC,IAAKW,EAED,OAIJ,IAAIC,EACJ,IACIA,EAASC,KAAKC,MAAMH,EACxB,CAAE,MAAOI,GAML,OAJI1C,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,8DAA+D2B,QAEjFT,aAAaI,WAAWV,EAE5B,CAGA,IAAKgB,MAAMC,QAAQL,IAA6B,IAAlBA,EAAOM,OAEjC,YADAZ,aAAaI,WAAWV,GAIxB3B,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,mCAAmCG,EAAOM,iDAI3D,MAAMC,EAAMC,KAAKD,MACXE,EAAcT,EAAOU,OAAOC,GAClBJ,GAAOI,EAAIC,GAAK,GACfrB,GAGjB,GAA2B,IAAvBkB,EAAYH,OAKZ,OAJI7C,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,gEAEjBH,aAAaI,WAAWV,GAK5B,IAAIyB,EAAY,EACZC,EAAS,EAGb,IAAK,MAAMH,KAAOF,EACd,IAEI,MAAM/B,EAAUiC,EAAII,EACdC,OAAOL,EAAII,GACX,kDAEAvC,EAAQ,IAAIC,MAAMC,GACxBF,EAAMyC,KAAO,eAGb,MAAMC,EAAWX,GAAOI,EAAIC,GAAKL,GAGjC9C,KAAKc,iBAAiBC,EAAO,CACzBZ,MAAO,CACHuD,aAAa,EACbC,SAAS,EACTC,mBAAoBd,EACpBe,kBAAmBX,EAAIC,GAAK,EAC5BM,SAAUK,KAAKC,MAAMN,EAAW,KAChCvC,SAAUgC,EAAIc,GAAK,UACnB7C,OAAQ+B,EAAIe,GAAK,EACjB7C,MAAO8B,EAAIgB,GAAK,EAChBC,YAAajB,EAAIkB,GAAK,UACtBC,YAAY,KAIpBjB,GACJ,CAAE,MAAOkB,GACLjB,IACIrD,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,uDAAwDuD,EAE9E,CAIW,IAAXjB,GACApB,aAAaI,WAAWV,GACxBM,aAAaI,WAAWT,GAEpB5B,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,+CAA+CgB,wBAIhEnB,aAAasC,QAAQ3C,EAA2B2B,OAAOxB,EAAW,IAE9D/B,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,oDAAoDgB,gBAAwBC,sCAGrG,CAAE,MAAOtC,GAELM,QAAQN,MAAM,0DAA2DA,EAC7E,CACJ,CASA,qBAAAL,GACI,IAEI,IAAKC,OAAO6D,mBACP7B,MAAMC,QAAQjC,OAAO6D,iBAAiBjC,QACvC,OAGJ,MAAMkC,EAAW9D,OAAO6D,iBAAiBjC,OAGzC,GAAwB,IAApBkC,EAAS5B,OACT,OAGA7C,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,iCAAiCqC,EAAS5B,4BAI3DlC,OAAO6D,iBAAiBjC,OAAS,GAGjC,IAAImC,EAAY,EACZrB,EAAS,EAGb,IAAK,MAAMsB,KAAQF,EACf,IAEI,IAAKE,GAAwB,iBAATA,EAAmB,CACnCtB,IACA,QACJ,CAEA,GAAkB,UAAdsB,EAAKpD,KAAkB,CAEvB,MAAMN,EAAU0D,EAAK5D,OAAS4D,EAAK5D,MAAME,QACnCsC,OAAOoB,EAAK5D,MAAME,SACjB0D,EAAK1D,QAAUsC,OAAOoB,EAAK1D,SAAW,yBAEvCF,EAAQ,IAAIC,MAAMC,GAGpB0D,EAAK5D,OAA+B,iBAAf4D,EAAK5D,QACtB4D,EAAK5D,MAAMyC,OACXzC,EAAMyC,KAAOD,OAAOoB,EAAK5D,MAAMyC,OAE/BmB,EAAK5D,MAAM6D,QACX7D,EAAM6D,MAAQrB,OAAOoB,EAAK5D,MAAM6D,SAKxC5E,KAAKc,iBAAiBC,EAAO,CACzBZ,MAAO,CACHsE,UAAU,EACVI,WAAYF,EAAKG,WAAa/B,KAAKD,MACnC5B,SAAUyD,EAAKzD,UAAY,UAC3BC,OAA+B,iBAAhBwD,EAAKxD,OAAsBwD,EAAKxD,OAAS,EACxDC,MAA6B,iBAAfuD,EAAKvD,MAAqBuD,EAAKvD,MAAQ,KAI7DsD,GACJ,MAAO,GAAkB,cAAdC,EAAKpD,KAAsB,CAElC,MAAMD,EAASqD,EAAKrD,OACpB,IAAIP,EAEJ,GAAIO,GAA4B,iBAAXA,EAAqB,CACtC,MAAML,EAAUK,EAAOL,QACjBsC,OAAOjC,EAAOL,SACd,8BAENF,EAAQ,IAAIC,MAAMC,GAClBF,EAAMyC,KAAOlC,EAAOkC,KAAOD,OAAOjC,EAAOkC,MAAQ,qBAE7ClC,EAAOsD,QACP7D,EAAM6D,MAAQrB,OAAOjC,EAAOsD,OAEpC,KAAO,CAEH,MAAM3D,EAAU,MAACK,EACXiC,OAAOjC,GACP,0CAENP,EAAQ,IAAIC,MAAMC,GAClBF,EAAMyC,KAAO,oBACjB,CAEAxD,KAAKc,iBAAiBC,EAAO,CACzBZ,MAAO,CACHsE,UAAU,EACVI,WAAYF,EAAKG,WAAa/B,KAAKD,MACnCvB,KAAM,wBAIdmD,GACJ,MAEQ1E,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,iDAAkDuC,EAAKpD,MAExE8B,GAER,CAAE,MAAO0B,GAEL1B,IACIrD,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,qDAAsDgE,EAE5E,CAGA/E,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,iDAAiDsC,gBAAwBrB,YAE9F,CAAE,MAAOtC,GAELM,QAAQN,MAAM,uDAAwDA,EAC1E,CACJ,CAOA,gBAAAiE,CAAiBC,GACb,OAAKtC,MAAMC,QAAQqC,GAGZA,EAAOhC,OAAOpC,GAASA,GAAwB,UAAfA,EAAMU,MAAkBsB,OAFpD,CAGf,CAiBA,sBAAM/B,CAAiBC,EAAOmE,EAAU,IACpC,IAEI,MAAMC,EAAUnF,KAAKoF,aAAarE,EAAO,QAASmE,GAGlD,GAAIlF,KAAKF,eAAiBE,KAAKF,cAAcuF,cAAgBrF,KAAKF,cAAcC,eAC5E,IAOI,MAAMuF,QAAsBtF,KAAKF,cAAcyF,YAAYxE,EAAOoE,GAGlE,IAAIK,EAAa,KACjB,GAAIF,GAAiBA,EAAcL,QAAUK,EAAcL,OAAOpC,OAAS,EAAG,CAE1E,MAAM4C,EAAiBH,EAAcL,OAAOhC,OAAOpC,GAC/B,iBAAhBA,EAAM6E,OAA4C,UAAhB7E,EAAM6E,OAG5C,GAAID,EAAe5C,OAAS,EAAG,CAE3B,MAAM8C,EAAa3F,KAAKgF,iBAAiBS,GAErCE,EAAa,GACbH,EAAa,CACTI,UAAWN,EAAcM,UACzBX,OAAQQ,EACRC,MAAO,aAGP1F,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,mEAAoE,CAC7EyD,YAAaP,EAAcL,OAAOpC,OAClC4C,eAAgBA,EAAe5C,OAC/BiD,YAAaH,EACbC,UAAWJ,EAAWI,aAGvB5F,KAAKL,OAAOwC,OACnBd,QAAQe,KAAK,4EAA6E,CACtFyD,YAAaJ,EAAe5C,OAC5BkD,YAAa/F,KAAKF,cAAcuF,aAAaW,YAGzD,MAAWhG,KAAKL,OAAOwC,OACnBd,QAAQe,KAAK,mDAAoD,CAC7DyD,YAAaP,EAAcL,OAAOpC,OAClCkD,YAAa/F,KAAKF,cAAcuF,aAAaW,YAGzD,MAAWhG,KAAKL,OAAOwC,OACnBd,QAAQe,KAAK,2DAA4D,CACrE6D,aAAcX,EACdY,aAAcZ,IAAiBA,EAAcL,QAC7CkB,WAAYb,GAAeL,QAAQpC,QAAU,EAC7CkD,YAAa/F,KAAKF,cAAcuF,aAAaW,mBAK/ChG,KAAKJ,UAAUwG,KAAKjB,EAASK,GAKsB,mBAA9CxF,KAAKF,cAAcuG,wBAC1BrG,KAAKF,cAAcuG,uBAAuBtF,GAAOP,MAAM8F,IAC/CtG,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,+CAAgDuF,IAI9E,CAAE,MAAOC,GAEDvG,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,yEAA0EwF,SAEtFvG,KAAKJ,UAAUwG,KAAKjB,EAC9B,MAGInF,KAAKL,OAAOwC,QAAUnC,KAAKF,eAC3BuB,QAAQe,KAAK,wEAEXpC,KAAKJ,UAAUwG,KAAKjB,EAElC,CAAE,MAAOqB,GAELnF,QAAQN,MAAM,sCAAuCyF,EACzD,CACJ,CAKA,cAAAC,CAAexF,EAASyF,EAAQ,OAAQxB,EAAU,CAAA,GAC9C,MAAMC,EAAUnF,KAAKoF,aAAa,IAAIpE,MAAMC,GAAUyF,EAAOxB,GAC7DlF,KAAKJ,UAAUwG,KAAKjB,EACxB,CAQA,YAAAC,CAAarE,EAAO2F,EAAOxB,EAAU,CAAA,GACjC,IACI,MAAMyB,EAAa3G,KAAK4G,gBAAgB7F,GAClC8F,EAAaF,EAAW9D,OAAS,EAAI8D,EAAW,GAAK,KAIrDxB,EAAU,CAGZ5D,KAAMvB,KAAK8G,SAAS/F,EAAMyC,MAAQ,QAAS,KAC3CvC,QAASjB,KAAK8G,SAAS/F,EAAME,SAAW,gBAAiB,KACzD8F,KAAM/G,KAAK8G,SAASD,GAAYE,MAAQ7B,EAAQ/E,OAAOe,UAAY,UAAW,KAE9E8F,KAAMH,GAAYG,MAAQ9B,EAAQ/E,OAAOgB,QAAU,EACnD8F,YAAaN,EAGbD,MAAOA,GAAS,QAChBQ,OAAQ,WACRC,YAAanH,KAAKL,OAAOwH,aAAe,aACxCC,QAASpH,KAAKL,OAAOyH,SAAW,KAChCC,IAAK1G,OAAO2G,SAASC,KACrBC,YAAaxH,KAAKyH,mBAClBC,iBAAkB1H,KAAK2H,sBAAsB5G,EAAOmE,GACpD0C,aAAc5H,KAAK6H,iBACnBC,WAAY9H,KAAKD,eAAiBC,KAAKD,eAAegI,eAAiB,KACvEjD,WAAW,IAAI/B,MAAOiF,cACtBC,QAAS,cAAcjI,KAAKkI,mBAC5BC,WAAYC,UAAUC,UACtBxI,YAAaG,KAAKH,YAAYyI,MAC9BC,QAAS,IAAKvI,KAAKG,SAAU+E,EAAQ/E,OACrCD,KAAM,IAAKF,KAAKE,QAASgF,EAAQhF,OAIrC,OAAOF,KAAKwI,iBAAiBrD,EACjC,CAAE,MAAOjC,GAGL,OADA7B,QAAQN,MAAM,6CAA8CmC,GACrD,CACH3B,KAAM,QACNN,QAASjB,KAAK8G,SAAS,gCAAiC,KACxDC,KAAM,UACNC,KAAM,EACNC,YAAa,GACbP,MAAO,QAEf,CACJ,CAYA,QAAAI,CAAS2B,EAAOC,GACZ,OAAKD,GAA0B,iBAAVA,EAIjBA,EAAM5F,QAAU6F,EACTD,EAIJA,EAAME,UAAU,EAAGD,EAAY,GAAK,MARhCD,CASf,CAQA,eAAA7B,CAAgB7F,GACZ,IAAKA,EAAM6D,MACP,MAAO,CAAC,CACJmC,KAAM,UACNC,KAAM,EACN4B,SAAU,YAIlB,IACI,MAAMC,EAAQ9H,EAAM6D,MAAMkE,MAAM,MAC1BC,EAAS,GAEf,IAAK,MAAM/B,KAAQ6B,EAAO,CACtB,MAAMG,EAAQhJ,KAAKiJ,eAAejC,EAAKkC,QACnCF,GACAD,EAAOI,KAAKH,EAEpB,CAEA,OAAOD,EAAOlG,OAAS,EAAIkG,EAAS,CAAC,CACjChC,KAAM,UACNC,KAAM,EACN4B,SAAU,WAElB,CAAE,MACE,MAAO,CAAC,CACJ7B,KAAM,UACNC,KAAM,EACN4B,SAAU,WAElB,CACJ,CAOA,cAAAK,CAAejC,GACX,IAAKA,EACD,OAAO,KAIX,IAAIoC,EAAQpC,EAAKoC,MAAM,sCACvB,OAAIA,EACO,CACHR,SAAUQ,EAAM,GAAGF,OACnBnC,KAAMqC,EAAM,GACZpC,KAAMhF,SAASoH,EAAM,GAAI,IACzBC,OAAQrH,SAASoH,EAAM,GAAI,MAKnCA,EAAQpC,EAAKoC,MAAM,0BACfA,EACO,CACHR,SAAU,YACV7B,KAAMqC,EAAM,GACZpC,KAAMhF,SAASoH,EAAM,GAAI,IACzBC,OAAQrH,SAASoH,EAAM,GAAI,MAKnCA,EAAQpC,EAAKoC,MAAM,2BACfA,EACO,CACHR,SAAUQ,EAAM,IAAM,YACtBrC,KAAMqC,EAAM,GACZpC,KAAMhF,SAASoH,EAAM,GAAI,IACzBC,OAAQrH,SAASoH,EAAM,GAAI,MAKnCA,EAAQpC,EAAKoC,MAAM,0BACfA,EACO,CACHR,SAAUQ,EAAM,IAAM,YACtBrC,KAAMqC,EAAM,GACZpC,KAAMhF,SAASoH,EAAM,GAAI,IACzBC,OAAQ,OAKhBD,EAAQpC,EAAKoC,MAAM,sCACfA,EACO,CACHR,SAAUQ,EAAM,GAAGF,OACnBnC,KAAMqC,EAAM,GACZpC,KAAMhF,SAASoH,EAAM,GAAI,IACzBC,OAAQrH,SAASoH,EAAM,GAAI,KAK5B,QACX,CAKA,gBAAA3B,GACI,IAEI,MAAM6B,EAAaC,YAAYC,iBAAiB,cAAc,GAC9D,GAAIF,GAAcA,EAAW/H,KAEzB,MAAO,KAEf,CAAE,MAEF,CAGA,MAAO,KACX,CAcA,qBAAAoG,CAAsB5G,EAAOmE,EAAU,IACnC,IAEI,GAAInE,EAAM0I,QAAkC,iBAAjB1I,EAAM0I,OAC7B,OAAO1I,EAAM0I,OAIjB,GAAIvE,EAAQwE,gBAAoD,iBAA3BxE,EAAQwE,eACzC,OAAOxE,EAAQwE,eAInB,GAAIxE,EAAQ/E,OAAOuH,kBAA8D,iBAAnCxC,EAAQ/E,MAAMuH,iBACxD,OAAOxC,EAAQ/E,MAAMuH,iBAGzB,GAAIxC,EAAQ/E,OAAOuJ,gBAA0D,iBAAjCxE,EAAQ/E,MAAMuJ,eACtD,OAAOxE,EAAQ/E,MAAMuJ,eAIzB,GAAI3I,EAAME,QAAS,CACf,MAAMmI,EAAQrI,EAAME,QAAQmI,MAAM,mBAClC,GAAIA,EAAO,CACP,MAAMK,EAASzH,SAASoH,EAAM,GAAI,IAClC,GAAIK,GAAU,KAAOA,EAAS,IAC1B,OAAOA,CAEf,CACJ,CAGA,OAAO,IACX,CAAE,MAEE,OAAO,IACX,CACJ,CAKA,cAAAvB,GACI,MAAMyB,EAAKvB,UAAUC,UAErB,OAAIsB,EAAGC,SAAS,YAAcD,EAAGC,SAAS,QAC/B,SAEPD,EAAGC,SAAS,WACL,UAEPD,EAAGC,SAAS,YAAcD,EAAGC,SAAS,UAC/B,SAEPD,EAAGC,SAAS,SAAWD,EAAGC,SAAS,QAC5B,OAEPD,EAAGC,SAAS,SAAWD,EAAGC,SAAS,YAC5B,KAGJ,SACX,CAeA,cAAA/B,GACI,IAEI,GAAI7H,KAAKL,OAAOkK,YACZ,OAAO7J,KAAKL,OAAOkK,YAIvB,GAAI7J,KAAKK,kBACL,OAAOL,KAAKK,kBAKhB,MAAMuF,EAAY5F,KAAK8J,uBACvB,OAAO9J,KAAK+J,SAASnE,EACzB,CAAE,MAEE,OAAO,IACX,CACJ,CAOA,iBAAAoE,GAEI,OAAIC,QAAUA,OAAOC,WACVD,OAAOC,aAIX,uCAAuCC,QAAQ,QAAUjG,IAC5D,MAAMkG,EAAoB,GAAhBtG,KAAKuG,SAAgB,EAE/B,OADgB,MAANnG,EAAYkG,EAAS,EAAJA,EAAU,GAC5BE,SAAS,KAE1B,CAWA,qBAAM/J,GACF,IAEI,MAAMqF,EAAY5F,KAAK8J,uBAGvB,GAAIG,QAAUA,OAAOM,OAAQ,CACzB,MACMC,GADU,IAAIC,aACCC,OAAO9E,GACtB+E,QAAmBV,OAAOM,OAAOK,OAAO,UAAWJ,GACnDK,EAAYlI,MAAMmI,KAAK,IAAIC,WAAWJ,IAC5C3K,KAAKK,kBAAoBwK,EAAUG,IAAIC,GAAKA,EAAEX,SAAS,IAAIY,SAAS,EAAG,MAAMC,KAAK,IAE9EnL,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,2DAErB,MAEIpC,KAAKK,kBAAoBL,KAAK+J,SAASnE,GAEnC5F,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,yDAGzB,CAAE,MAAOrB,GAEL,IACIf,KAAKK,kBAAoBL,KAAK+J,SAAS/J,KAAK8J,uBAChD,CAAE,MAEM9J,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,uDAAwDA,EAE9E,CACJ,CACJ,CAOA,oBAAA+I,GACI,GAA8B,oBAAnBsB,eAAgC,CACvC,IAAIxF,EAAYwF,eAAelJ,QAAQ,0BAOvC,OALK0D,IACDA,EAAY5F,KAAKgK,oBACjBoB,eAAe7G,QAAQ,yBAA0BqB,IAG9CA,CACX,CAGA,OAAO5F,KAAKgK,mBAChB,CAWA,QAAAD,CAASsB,GACL,IAAIC,EAAO,KACX,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAIxI,OAAQ0I,IAC5BD,GAASA,GAAQ,GAAKA,EAAQD,EAAIG,WAAWD,GAKjD,OADYzH,KAAK2H,IAAIH,GAAMhB,SAAS,IACzBY,SAAS,GAAI,IAC5B,CAKA,gBAAA1C,CAAiBkD,GACb,MAAMC,EAAU,CAAA,EAEhB,IAAK,MAAOC,EAAKnD,KAAUoD,OAAOC,QAAQJ,GAClCjD,UACAkD,EAAQC,GAAOnD,GAIvB,OAAOkD,CACX,CAEA,OAAAI,CAAQC,GACJhM,KAAKC,YAAc+L,CACvB,CAEA,OAAAC,CAAQ/L,GACJF,KAAKE,KAAO,IAAKF,KAAKE,QAASA,EACnC,CAEA,QAAAgM,CAAS/L,GACLH,KAAKG,MAAQ,IAAKH,KAAKG,SAAUA,EACrC,CAMA,iBAAAqB,GACI,IAEI,IAAK4G,UAAU+D,WACX,OAIJ,MAAMC,EAAQpM,KAAKJ,UAAUoG,WAE7B,GAA2B,IAAvBoG,EAAMC,cAA0C,IAApBD,EAAME,UAClC,OAIJtM,KAAKJ,UAAU2M,iBACnB,CAAE,MAGF,CACJ,EC39BG,MAAMC,EACT,WAAA9M,CAAY+M,EAAiB,GAAIC,EAAuB,MACpD1M,KAAKH,YAAc,GACnBG,KAAKyM,eAAiBA,EACtBzM,KAAK2M,WAAY,EACjB3M,KAAK0M,qBAAuBA,CAChC,CAOA,YAAAE,CAAaC,GACT,OAAKA,EAAQC,UAEoB,iBAAtBD,EAAQC,gBAAwDC,IAA9BF,EAAQC,UAAUE,QACpDH,EAAQC,UAAUE,QAGtBH,EAAQC,UANgB,EAOnC,CAKA,OAAAxM,GAEI,GAAIN,KAAK2M,UACL,OAGJ3M,KAAK2M,WAAY,EAGjBlL,SAASb,iBAAiB,QAAUC,IAChC,MAAMoM,EAASpM,EAAMoM,OACfC,EAAUD,EAAOC,QAAQC,cAC/B,IAAIlM,EAAU,WAAWiM,IAEzB,MAAMJ,EAAY9M,KAAK4M,aAAaK,GAEpC,GAAIA,EAAOG,GACPnM,GAAW,IAAIgM,EAAOG,UACnB,GAAIN,EAAW,CAClB,MAAMO,EAAaP,EAAUhE,MAAM,KAAK,GACpCuE,IACApM,GAAW,IAAIoM,IAEvB,CAEArN,KAAKsN,IAAI,CACL/L,KAAM,KACNgM,SAAU,QACVtM,UACAuJ,KAAM,CACFgD,IAAKN,EACLE,GAAIH,EAAOG,GACXK,MAAOX,OAGhB,GAGH,MAAMY,EAAoBC,QAAQC,UAC5BC,EAAuBF,QAAQG,aAErCH,QAAQC,UAAY,IAAIG,KACpB/N,KAAKsN,IAAI,CACL/L,KAAM,aACNgM,SAAU,aACVtM,QAAS,gBAAgB8M,EAAK,KAC9BvD,KAAM,CAAEwD,GAAID,EAAK,MAEdL,EAAkBO,MAAMN,QAASI,IAG5CJ,QAAQG,aAAe,IAAIC,KACvB/N,KAAKsN,IAAI,CACL/L,KAAM,aACNgM,SAAU,aACVtM,QAAS,kBAAkB8M,EAAK,KAChCvD,KAAM,CAAEwD,GAAID,EAAK,MAEdF,EAAqBI,MAAMN,QAASI,IAI/C/N,KAAKkO,cAGLlO,KAAKmO,WACT,CAKA,GAAAb,CAAIc,GACApO,KAAKH,YAAYsJ,KAAK,CAClBrE,WAAW,IAAI/B,MAAOiF,cACtBtB,MAAO0H,EAAW1H,OAAS,UACxB0H,IAIHpO,KAAKH,YAAYgD,OAAS7C,KAAKyM,gBAC/BzM,KAAKH,YAAYwO,OAEzB,CAKA,GAAA/F,GACI,OAAOtI,KAAKH,WAChB,CAKA,KAAAyO,GACItO,KAAKH,YAAc,EACvB,CAcA,WAAAqO,GACmB,CAAC,MAAO,OAAQ,OAAQ,QAAS,SAEzCK,QAAQ7H,IAEX,MAAM8H,EAAWnN,QAAQqF,GAGD,mBAAb8H,IAKXnN,QAAQqF,GAAS,IAAIqH,KAGjB,GAAc,UAAVrH,GAAqB1G,KAAK0M,qBAC1B,IAEI,MAAM+B,EAAWV,EAAKW,KAAKC,GAAOA,aAAe3N,OAC7CyN,GAEyC,mBAA9BzO,KAAK0M,sBACZ1M,KAAK0M,qBAAqB+B,EAAU,CAChCtO,MAAO,CACHyO,cAAc,EACdC,eAAgBd,EAAK9K,OAAO0L,KAASA,aAAe3N,QAC/CgK,IAAI2D,GAAOpL,OAAOoL,IAClBxD,KAAK,OAK9B,CAAE,MAAO3E,GAGL,GAAwB,mBAAbgI,EACP,IACIA,EAASM,KAAKzN,QAAS,mDAAoDmF,EAC/E,CAAE,MAEF,CAER,CAGJ,IAAIuI,EAGJ,IACIA,EAASP,EAASP,MAAM5M,QAAS0M,EACrC,CAAE,MAGF,CAGA,IAKI,MAAMiB,EAAWjB,EAAK/C,IAAI2D,IACtB,GAAY,OAARA,EAAc,MAAO,OACzB,QAAY5B,IAAR4B,EAAmB,MAAO,YAG9B,GAAIA,aAAe3N,MACf,MAAO,GAAG2N,EAAInL,SAASmL,EAAI1N,UAI/B,GAAmB,iBAAR0N,EACP,IACI,OAAOnM,KAAKyM,UAAUN,EAC1B,CAAE,MAEE,OAAO9C,OAAOqD,UAAU5E,SAASwE,KAAKH,EAC1C,CAIJ,OAAOpL,OAAOoL,KAGlB3O,KAAKsN,IAAI,CACL/L,KAAM,UACNgM,SAAU,UACVtM,QAAS+N,EAAS7D,KAAK,KACvBzE,MAAiB,QAAVA,EAAkB,OAASA,EAClC8D,KAAM,CAAE2E,UAAWH,IAE3B,CAAE,MAIF,CAEA,OAAOD,KAGnB,CAKA,SAAAZ,GACI,MAAMiB,EAAgBzO,OAAO0O,MAE7B1O,OAAO0O,MAAQC,SAAUvB,KACrB,MAAM1G,EAAyB,iBAAZ0G,EAAK,GAAkBA,EAAK,GAAKA,EAAK,GAAG1G,IACtDkI,EAASxB,EAAK,IAAIwB,QAAU,MAC5BC,EAAYzM,KAAKD,MAEvB,IACI,MAAM2M,QAAiBL,EAAcnB,MAAMtN,OAAQoN,GAC7C2B,EAAW3M,KAAKD,MAAQ0M,EAe9B,OAbAxP,KAAKsN,IAAI,CACL/L,KAAM,OACNgM,SAAU,QACVtM,QAAS,GAAGsO,KAAUlI,IACtBmD,KAAM,CACFnD,MACAkI,SACAI,YAAaF,EAAShG,OACtBiG,YAEJhJ,MAAO+I,EAASG,GAAK,OAAS,YAG3BH,CACX,CAAE,MAAO1O,GACL,MAAM2O,EAAW3M,KAAKD,MAAQ0M,EAe9B,MAbAxP,KAAKsN,IAAI,CACL/L,KAAM,OACNgM,SAAU,QACVtM,QAAS,GAAGsO,KAAUlI,WACtBmD,KAAM,CACFnD,MACAkI,SACAxO,MAAOA,EAAME,QACbyO,YAEJhJ,MAAO,UAGL3F,CACV,EAER,ECjRG,MAAM8O,EAETC,oBAAsB,SAEtBA,kBAAoB,OAEpBA,uBAAyB,YASzB,WAAApQ,CAAYC,EAAS,IAEjBK,KAAK+P,iBAAmBpQ,EAAOoQ,kBAAoB,EAEnD/P,KAAKgQ,QAAUrQ,EAAOqQ,SAAW,IAEjChQ,KAAKiQ,WAAa,6BAElBjQ,KAAKkQ,WACT,CASA,MAAAC,GAMI,OAJInQ,KAAKoQ,QAAUP,EAAeQ,YAAcrQ,KAAKsQ,sBACjDtQ,KAAKuQ,WAGFvQ,KAAKoQ,QAAUP,EAAeQ,UACzC,CAOA,UAAAG,GACI,OAAOxQ,KAAKoQ,QAAUP,EAAeY,eACzC,CAUA,aAAAC,GACQ1Q,KAAKoQ,QAAUP,EAAeY,gBAE9BzQ,KAAK2Q,QACE3Q,KAAKoQ,QAAUP,EAAee,eAErC5Q,KAAK6Q,aAAe,EACpB7Q,KAAK8Q,YAEb,CAUA,aAAAC,GACQ/Q,KAAKoQ,QAAUP,EAAeY,gBAE9BzQ,KAAKgR,OACEhR,KAAKoQ,QAAUP,EAAee,eACrC5Q,KAAK6Q,eAED7Q,KAAK6Q,cAAgB7Q,KAAK+P,iBAC1B/P,KAAKgR,OAELhR,KAAK8Q,YAGjB,CAOA,QAAAG,GACI,MAAO,CACHb,MAAOpQ,KAAKoQ,MACZS,aAAc7Q,KAAK6Q,aACnBK,SAAUlR,KAAKkR,SAEvB,CAOA,KAAAC,GACInR,KAAK2Q,OACT,CAQA,KAAAA,GACI3Q,KAAKoQ,MAAQP,EAAee,aAC5B5Q,KAAK6Q,aAAe,EACpB7Q,KAAKkR,SAAW,KAChBlR,KAAK8Q,WACT,CAQA,IAAAE,GACIhR,KAAKoQ,MAAQP,EAAeQ,WAC5BrQ,KAAKkR,SAAWnO,KAAKD,MACrB9C,KAAK8Q,WACT,CAQA,QAAAP,GACIvQ,KAAKoQ,MAAQP,EAAeY,gBAC5BzQ,KAAK8Q,WACT,CAQA,kBAAAR,GACI,QAAKtQ,KAAKkR,UAIFnO,KAAKD,MAAQ9C,KAAKkR,UAAalR,KAAKgQ,OAChD,CAQA,SAAAE,GACI,IACI,MAAM5N,EAAS8I,eAAelJ,QAAQlC,KAAKiQ,YAE3C,GAAI3N,EAAQ,CACR,MAAM8N,EAAQ5N,KAAKC,MAAMH,GACzBtC,KAAKoQ,MAAQA,EAAMA,OAASP,EAAee,aAC3C5Q,KAAK6Q,aAAeT,EAAMS,cAAgB,EAC1C7Q,KAAKkR,SAAWd,EAAMc,UAAY,IACtC,MACIlR,KAAKoQ,MAAQP,EAAee,aAC5B5Q,KAAK6Q,aAAe,EACpB7Q,KAAKkR,SAAW,IAExB,CAAE,MAEElR,KAAKoQ,MAAQP,EAAee,aAC5B5Q,KAAK6Q,aAAe,EACpB7Q,KAAKkR,SAAW,IACpB,CACJ,CAQA,SAAAJ,GACI,IACI,MAAMV,EAAQ,CACVA,MAAOpQ,KAAKoQ,MACZS,aAAc7Q,KAAK6Q,aACnBK,SAAUlR,KAAKkR,UAGnB9F,eAAe7G,QAAQvE,KAAKiQ,WAAYzN,KAAKyM,UAAUmB,GAC3D,CAAE,MAGF,CACJ,EC1NG,MAAMgB,EAQT,WAAA1R,CAAYC,EAAS,IAEjBK,KAAKiQ,WAAa,mBAElBjQ,KAAKqR,QAAU1R,EAAO0R,SAAW,GAEjCrR,KAAKsR,OAAS3R,EAAO2R,QAAU,KACnC,CAWA,OAAAC,CAAQpM,GACJ,IACI,MAAMqM,EAAQxR,KAAKyR,WAGb9M,EAAO,CACTQ,UACAL,UAAW/B,KAAKD,OAGpB0O,EAAMrI,KAAKxE,GAGP6M,EAAM3O,OAAS7C,KAAKqR,SACpBG,EAAMnD,QAGVrO,KAAK0R,UAAUF,EACnB,CAAE,MAAOzQ,GAGLM,QAAQe,KAAK,2CAA4CrB,EAC7D,CACJ,CAOA,OAAA4Q,GACI,IACI,MAAMH,EAAQxR,KAAKyR,WAEnB,GAAqB,IAAjBD,EAAM3O,OACN,OAAO,KAGX,MAAM8B,EAAO6M,EAAMnD,QAGnB,OAFArO,KAAK0R,UAAUF,GAER7M,EAAKQ,OAChB,CAAE,MACE,OAAO,IACX,CACJ,CAOA,MAAAyM,GAEI,OADc5R,KAAKyR,WACNzG,IAAIrG,GAAQA,EAAKQ,QAClC,CAOA,IAAA0M,GAEI,OADc7R,KAAKyR,WACN5O,MACjB,CAOA,KAAAyL,GACI,IACIrM,aAAaI,WAAWrC,KAAKiQ,WACjC,CAAE,MAEF,CACJ,CAUA,QAAAwB,GACI,IACI,MAAMnP,EAASL,aAAaC,QAAQlC,KAAKiQ,YAEzC,IAAK3N,EACD,MAAO,GAGX,MAAMkP,EAAQhP,KAAKC,MAAMH,GAEzB,IAAKK,MAAMC,QAAQ4O,GACf,MAAO,GAIX,MAAM1O,EAAMC,KAAKD,MACXgP,EAAWN,EAAMvO,OAAO0B,GACnBA,EAAKG,WAAchC,EAAM6B,EAAKG,UAAa9E,KAAKsR,QAQ3D,OAJIQ,EAASjP,SAAW2O,EAAM3O,QAC1B7C,KAAK0R,UAAUI,GAGZA,CACX,CAAE,MACE,MAAO,EACX,CACJ,CAWA,SAAAJ,CAAUF,GACN,IACIvP,aAAasC,QAAQvE,KAAKiQ,WAAYzN,KAAKyM,UAAUuC,GACzD,CAAE,MAAOzQ,GAEL,GAAmB,uBAAfA,EAAMyC,KAA+B,CAErC,MAAMuO,EAAWjO,KAAKC,MAAMyN,EAAM3O,OAAS,GACrCmP,EAAUR,EAAMS,OAAOF,GAE7B,IACI9P,aAAasC,QAAQvE,KAAKiQ,WAAYzN,KAAKyM,UAAU+C,GACzD,CAAE,MAEEhS,KAAKsO,OACT,CACJ,CACJ,CACJ,EC3KG,MAAM4D,EAQT,WAAAxS,CAAYC,EAAS,IAEjBK,KAAKmS,UAAYxS,EAAOwS,WAAa,GAErCnS,KAAKoS,WAAazS,EAAOyS,YAAc,EAEvCpS,KAAKqS,OAASrS,KAAKmS,UAEnBnS,KAAKsS,WAAavP,KAAKD,KAC3B,CAOA,SAAAyP,GAEI,OADAvS,KAAKwS,eACExS,KAAKqS,OAAS,CACzB,CASA,OAAAI,GACI,QAAKzS,KAAKuS,cAIVvS,KAAKqS,UACE,EACX,CAWA,YAAAG,GACI,MAAM1P,EAAMC,KAAKD,MACX4P,GAAW5P,EAAM9C,KAAKsS,YAAc,IACpCK,EAAc7O,KAAKC,MAAM2O,EAAU1S,KAAKoS,YAE1CO,EAAc,IACd3S,KAAKqS,OAASvO,KAAK8O,IAAI5S,KAAKmS,UAAWnS,KAAKqS,OAASM,GACrD3S,KAAKsS,WAAaxP,EAE1B,CAOA,SAAA+P,GAEI,OADA7S,KAAKwS,eACExS,KAAKqS,MAChB,CASA,KAAAlB,GACInR,KAAKqS,OAASrS,KAAKmS,UACnBnS,KAAKsS,WAAavP,KAAKD,KAC3B,ECvFG,MAAMgQ,EACT,WAAApT,CAAYC,GACRK,KAAKL,OAASA,EACdK,KAAK+S,OAASpT,EAAOoT,OACrB/S,KAAKgT,IAAMhT,KAAKiT,SAAStT,EAAOqT,KAChChT,KAAKwR,MAAQ,GACbxR,KAAKkT,SAAU,EAGflT,KAAKmT,eAAiB,IAAItD,EAAe,CACrCE,iBAAkBpQ,EAAOyT,gCAAkC,EAC3DpD,QAASrQ,EAAO0T,yBAA2B,MAG/CrT,KAAKsT,aAAe,IAAIlC,EAAa,CACjCC,QAAS1R,EAAO4T,qBAAuB,GACvCjC,OAAQ3R,EAAO6T,sBAAwB,QAG3CxT,KAAKyT,YAAc,IAAIvB,EAAY,CAC/BC,UAAWxS,EAAO+T,sBAAwB,GAC1CtB,WAAYzS,EAAOgU,uBAAyB,OAIhD3T,KAAK4T,aAAe,IAAIC,IACxB7T,KAAK8T,oBAAsBnU,EAAOoU,uBAAyB,IAG3D/T,KAAKgU,mBACT,CAUA,QAAAf,CAASD,GACL,IAAKA,EACD,MAAM,IAAIhS,MAAM,mBAGpB,IACI,MAAMqG,EAAM,IAAI4M,IAAIjB,GACdkB,EAAY7M,EAAI8M,SAAShK,QAAQ,MAAO,IAE9C,IAAK+J,EACD,MAAM,IAAIlT,MAAM,6CAGpB,MAAO,CACHoT,SAAU/M,EAAI+M,SAASjK,QAAQ,IAAK,IACpCkK,KAAMhN,EAAIgN,KACVH,UAAWA,EACXI,SAAU,GAAGjN,EAAI+M,aAAa/M,EAAIgN,yBAE1C,CAAE,MAAOtT,GACL,MAAM,IAAIC,MAAM,uBAAuBD,EAAME,6CACjD,CACJ,CAUA,UAAMmF,CAAKjB,EAASK,EAAa,MAC7B,IAEI,IAAI+O,EAAkBpP,EAClBK,IACA+O,EAAkB,IACXpP,EACHqP,kBAAmBhP,EAAWI,UAC9B6O,YAAajP,EAAWP,QAGxBjF,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,oDAAqD,CAC9DwD,UAAWJ,EAAWI,UACtBO,WAAYX,EAAWP,QAAQpC,QAAU,KAMrD,MAAM6R,EAAkB1U,KAAK2U,mBAAmBJ,GAGhD,GAAIvU,KAAK4U,YAAYF,GAIjB,YAHI1U,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,+CAMrB,IAAKpC,KAAKyT,YAAYhB,UAKlB,OAJIzS,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,6DAEjBpC,KAAKsT,aAAa/B,QAAQmD,GAK9B1U,KAAKwR,MAAMrI,KAAKuL,GAGX1U,KAAKkT,eACAlT,KAAK6U,cAEnB,CAAE,MAAO9T,GAELM,QAAQN,MAAM,iCAAkCA,EACpD,CACJ,CAeA,yBAAM+T,CAAoBC,EAAiBC,GAAY,GACnD,IAEI,MAAMV,EAAW,GAAGtU,KAAKgT,IAAIoB,cAAcpU,KAAKgT,IAAIqB,mCAWpD,GATIrU,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,8CAA+C,CACxDwD,UAAWmP,EAAgBnP,UAC3BO,WAAY4O,EAAgB9P,QAAQpC,QAAU,EAC9C0M,OAAQyF,EAAY,aAAe,UAKvCA,GAAa5M,UAAU+D,WAAY,CAEnC,MAAM8I,EAAkB,IACjBF,EACHhC,OAAQ/S,KAAK+S,QAGXmC,EAAO,IAAIC,KAAK,CAAC3S,KAAKyM,UAAUgG,IAAmB,CACrD1T,KAAM,qBAKV,GAFa6G,UAAU+D,WAAWmI,EAAUY,GAMxC,OAHIlV,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,6DAEV,CAAEgT,SAAS,EAAM7F,OAAQ,UAEhC,MAAM,IAAIvO,MAAM,8CAExB,CAIA,MAAMqU,EAAa,IAAIC,gBACjBC,EAAYC,WAAW,IAAMH,EAAWI,QAAS,KAEjDhG,QAAiBJ,MAAMiF,EAAU,CACnC/E,OAAQ,OACRmG,QAAS,CACL,eAAgB,mBAChB,YAAa1V,KAAK+S,OAClB,aAAc,gCAElB4C,KAAMnT,KAAKyM,UAAU8F,GACrBa,OAAQP,EAAWO,SAKvB,GAFAC,aAAaN,IAER9F,EAASG,GACV,MAAM,IAAI5O,MAAM,iCAAiCyO,EAAShG,UAO9D,OAJIzJ,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,yDAGVqN,EAASqG,MACpB,CAAE,MAAO/U,GACLM,QAAQN,MAAM,qDAAsDA,GAGpE,IACIf,KAAKsT,aAAa/B,QAAQ,CACtBhQ,KAAM,WACN4D,QAAS4P,GAEjB,CAAE,MAAOgB,GACL1U,QAAQN,MAAM,sDAAuDgV,EACzE,CAEA,MAAMhV,CACV,CACJ,CAKA,kBAAM8T,GACF,GAA0B,IAAtB7U,KAAKwR,MAAM3O,SAAgB7C,KAAKkT,QAApC,CAMA,IAFAlT,KAAKkT,SAAU,EAERlT,KAAKwR,MAAM3O,OAAS,GAAG,CAC1B,MAAMsC,EAAUnF,KAAKwR,MAAMnD,QAE3B,UACUrO,KAAKgW,UAAU7Q,GAEjBnF,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,6CAErB,CAAE,MAGF,CACJ,CAEApC,KAAKkT,SAAU,CAnBf,CAoBJ,CAKA,eAAM8C,CAAU7Q,EAAS8Q,EAAU,GAE/B,GAAIjW,KAAKmT,eAAehD,SAKpB,OAJInQ,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,4EAEjBpC,KAAKsT,aAAa/B,QAAQpM,GAK9B,MAAMkQ,EAAa,IAAIC,gBACjBC,EAAYC,WAAW,IAAMH,EAAWI,QAAS,KAEvD,IACI,MAAMhG,QAAiBJ,MAAMrP,KAAKgT,IAAIsB,SAAU,CAC5C/E,OAAQ,OACRmG,QAAS,CACL,eAAgB,mBAChB,YAAa1V,KAAK+S,OAClB,aAAc,gCAElB4C,KAAMnT,KAAKyM,UAAU9J,GACrByQ,OAAQP,EAAWO,SAKvB,GAFAC,aAAaN,IAER9F,EAASG,GACV,MAAM,IAAI5O,MAAM,QAAQyO,EAAShG,WAAWgG,EAASyG,cASzD,OALAlW,KAAKmT,eAAezC,gBAGpB1Q,KAAKgU,oBAEEvE,EAASqG,MACpB,CAAE,MAAO/U,GAIL,GAHA8U,aAAaN,GAGM,eAAfxU,EAAMyC,KAQN,OAPAxD,KAAKmT,eAAepC,gBAEhB/Q,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,2CAGlBf,KAAKsT,aAAa/B,QAAQpM,GAK9B,GAAI8Q,EAAU,EAAG,CAEb,MAAME,EAA+B,IAAvBrS,KAAKsS,IAAI,EAAGH,GAG1B,aAFMjW,KAAKmW,MAAMA,GAEVnW,KAAKgW,UAAU7Q,EAAS8Q,EAAU,EAC7C,CAGAjW,KAAKmT,eAAepC,gBAEhB/Q,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,yCAA0CA,GAG5Df,KAAKsT,aAAa/B,QAAQpM,EAC9B,CACJ,CAQA,WAAAyP,CAAYzP,GACR,IAEI,MAAMkR,EAAY7T,KAAKyM,UAAU,CAC7B1N,KAAM4D,EAAQ5D,KACdN,QAASkE,EAAQlE,QACjB2D,MAAOO,EAAQ8B,aAAagL,MAAM,EAAG,KAGnC3G,EAAOtL,KAAKsW,WAAWD,GAG7B,GAAIrW,KAAK4T,aAAa2C,IAAIjL,GACtB,OAAO,EAIXtL,KAAK4T,aAAa4C,IAAIlL,EAAMvI,KAAKD,OAGjC,MAAMA,EAAMC,KAAKD,MACjB,IAAK,MAAO8I,EAAK9G,KAAc9E,KAAK4T,aAC5B9Q,EAAMgC,EAAY9E,KAAK8T,qBACvB9T,KAAK4T,aAAa6C,OAAO7K,GAIjC,OAAO,CACX,CAAE,MACE,OAAO,CACX,CACJ,CAKA,UAAA0K,CAAWjL,GACP,IAAIC,EAAO,EACX,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAIxI,OAAQ0I,IAAK,CAEjCD,GAASA,GAAQ,GAAKA,EADTD,EAAIG,WAAWD,GAE5BD,GAAcA,CAClB,CACA,OAAOA,EAAKhB,UAChB,CAKA,uBAAM0J,GACF,IACI,MAAM1H,EAAYtM,KAAKsT,aAAazB,OAEpC,GAAkB,IAAdvF,EACA,OAGAtM,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,+BAA+BkK,mBAIhD,MAAMoK,EAAQ5S,KAAK8O,IAAItG,EAAW,GAElC,IAAK,IAAIf,EAAI,EAAGA,EAAImL,EAAOnL,IAAK,CAC5B,MAAMpG,EAAUnF,KAAKsT,aAAa3B,UAE9BxM,GAEAnF,KAAKwR,MAAMrI,KAAKhE,EAExB,EAGKnF,KAAKkT,SAAWlT,KAAKwR,MAAM3O,OAAS,SAC/B7C,KAAK6U,cAEnB,CAAE,MAAO9T,GAEDf,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,kCAAmCA,EAEzD,CACJ,CAKA,KAAAoV,CAAMQ,GACF,OAAO,IAAIC,QAAQC,GAAWrB,WAAWqB,EAASF,GACtD,CAKA,kBAAAhC,CAAmBxP,GACf,MACM2R,EAAgB,IADF9W,KAAKL,OAAOoX,aAAe,GAG3C,WACA,SACA,MACA,SACA,UACA,SACA,QACA,OACA,gBACA,cACA,eACA,iBAIJ,IAAIC,EACJ,IACIA,EAAWxU,KAAKC,MAAMD,KAAKyM,UAAU9J,GACzC,CAAE,MAEE6R,EAAWhX,KAAKiX,yBAAyB9R,EAC7C,CAGA,MAAM+R,EAAexL,IACjB,IAAKA,GAAsB,iBAARA,EACf,OAAOA,EAGX,IAAK,MAAME,KAAOF,EACd,GAAIG,OAAOqD,UAAUiI,eAAerI,KAAKpD,EAAKE,GAAM,CAE5BkL,EAAcM,KAAKC,GACnCzL,EAAIuB,cAAcvD,SAASyN,EAAQlK,gBAInCzB,EAAIE,GAAO,aACgB,iBAAbF,EAAIE,IAClBsL,EAAYxL,EAAIE,GAExB,CAGJ,OAAOF,GAGX,OAAOwL,EAAYF,EACvB,CAUA,wBAAAC,CAAyBvL,EAAK4L,EAAO,IAAIC,SAErC,GAAY,OAAR7L,GAA+B,iBAARA,EACvB,OAAOA,EAIX,GAAI4L,EAAKf,IAAI7K,GACT,MAAO,uBAOX,GAHA4L,EAAKhK,IAAI5B,GAGL/I,MAAMC,QAAQ8I,GACd,OAAOA,EAAIV,IAAIrG,GAAQ3E,KAAKiX,yBAAyBtS,EAAM2S,IAI/D,MAAMvI,EAAS,CAAA,EACf,IAAK,MAAMnD,KAAOF,EACd,GAAIG,OAAOqD,UAAUiI,eAAerI,KAAKpD,EAAKE,GAC1C,IACImD,EAAOnD,GAAO5L,KAAKiX,yBAAyBvL,EAAIE,GAAM0L,EAC1D,CAAE,MAEEvI,EAAOnD,GAAO,4BAClB,CAIR,OAAOmD,CACX,CAKA,sBAAMyI,CAAiB5R,EAAW6R,GAC9B,GAAK7R,GAAc6R,EAInB,IACI,MAAMpQ,EAAM,GAAGrH,KAAKgT,IAAIoB,cAAcpU,KAAKgT,IAAIqB,wBAAwBzO,WAEjE6J,QAAiBJ,MAAMhI,EAAK,CAC9BkI,OAAQ,OACRmG,QAAS,CACL,eAAgB,mBAChB,YAAa1V,KAAK+S,OAClB,aAAc,gCAElB4C,KAAMnT,KAAKyM,UAAUwI,KAGzB,IAAKhI,EAASG,GACV,MAAM,IAAI5O,MAAM,QAAQyO,EAAShG,UAGrC,OAAOgG,EAASqG,MACpB,CAAE,MAAO/U,GAEDf,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,kDAAmDA,EAEzE,CACJ,CAKA,sBAAM2W,CAAiB9R,EAAW+R,GAC9B,GAAK/R,GAAc+R,GAA4B,IAAlBA,EAAO9U,OAIpC,IACI,MAAMwE,EAAM,GAAGrH,KAAKgT,IAAIoB,cAAcpU,KAAKgT,IAAIqB,wBAAwBzO,WAEjE6J,QAAiBJ,MAAMhI,EAAK,CAC9BkI,OAAQ,OACRmG,QAAS,CACL,eAAgB,mBAChB,YAAa1V,KAAK+S,OAClB,aAAc,gCAElB4C,KAAMnT,KAAKyM,UAAU,CAAE0I,aAG3B,IAAKlI,EAASG,GACV,MAAM,IAAI5O,MAAM,QAAQyO,EAAShG,UAOrC,OAJIzJ,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,2BAA2BuV,EAAO9U,yBAG5C4M,EAASqG,MACpB,CAAE,MAAO/U,GAEDf,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,iDAAkDA,EAExE,CACJ,CAKA,QAAAiF,GACI,MAAO,CACHsG,UAAWtM,KAAKwR,MAAM3O,OACtBwJ,aAAcrM,KAAKsT,aAAazB,OAChCsB,eAAgBnT,KAAKmT,eAAelC,WACpC2G,gBAAiB5X,KAAKyT,YAAYZ,YAE1C,CAMA,eAAAtG,GACI,IAEI,MAAMF,EAAerM,KAAKsT,aAAa1B,SAGjCiG,EAAY,IAAI7X,KAAKwR,SAAUnF,GAErC,GAAyB,IAArBwL,EAAUhV,OACV,OAIJ,MAAMiV,EAAeD,EAAU5F,OAAO,IAGhC8F,EAAgB,CAClB/E,IAAKhT,KAAKL,OAAOqT,IACjBzQ,OAAQuV,GAGN5C,EAAO,IAAIC,KAAK,CAAC3S,KAAKyM,UAAU8I,IAAiB,CACnDxW,KAAM,qBAIG6G,UAAU+D,WAAWnM,KAAKgT,IAAIsB,SAAUY,KAKjDlV,KAAKsT,aAAahF,QAClBtO,KAAKwR,MAAQ,GAETxR,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,8BAA8B0V,EAAajV,gCAGpE,CAAE,MAAO9B,GAEDf,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,yCAA0CA,EAEhE,CACJ,EC/nBG,MAAMiX,EACT,WAAAtY,CAAYwF,EAAU,IAClBlF,KAAKiY,SAAW/S,EAAQ+S,UAAY,GACpCjY,KAAKkY,QAAUhT,EAAQgT,SAAW,EAClClY,KAAKmY,eAA0C,IAA1BjT,EAAQiT,cAC7BnY,KAAKoY,eAA0C,IAA1BlT,EAAQkT,cAC7BpY,KAAKmC,MAAQ+C,EAAQ/C,QAAS,EAG9BnC,KAAKoM,MAAQ,CACTiM,cAAe,EACfC,iBAAkB,EAClBC,YAAa,EACbC,iBAAkB,EAClBC,gBAAiB,EAEzB,CAQA,SAAAC,CAAUC,EAAclX,SAASkU,MAE7B3V,KAAKoM,MAAQ,CACTiM,cAAe,EACfC,iBAAkB,EAClBC,YAAa,EACbC,iBAAkB,EAClBC,gBAAiB,GAGrB,MAAMjJ,EAAYjG,YAAYzG,MAE9B,IAEI,MAAM8V,EAAW,CACbC,MAAOlY,OAAOmY,WACdC,OAAQpY,OAAOqY,YACfC,QAAStY,OAAOsY,QAChBC,QAASvY,OAAOuY,SAIdC,EAAOnZ,KAAKoZ,iBAAiBT,EAAa,GAE1CjG,EAAUnJ,YAAYzG,MAAQ0M,EASpC,OAPIxP,KAAKmC,OACLd,QAAQe,KAAK,2BAA4B,IAClCpC,KAAKoM,MACRiN,UAAW3G,EAAQ4G,QAAQ,KAI5B,CACHV,WACAO,OACArU,UAAW/B,KAAKD,MAChBsJ,MAAOpM,KAAKoM,MAEpB,CAAE,MAAOrL,GAEL,OADAM,QAAQN,MAAM,4BAA6BA,GACpC,IACX,CACJ,CAUA,gBAAAqY,CAAiBvM,EAAS0M,GAEtB,GAAIA,GAASvZ,KAAKiY,SAEd,OADAjY,KAAKoM,MAAMqM,kBACJ,KAIX,GAAIzY,KAAKwZ,mBAAmB3M,GAExB,OADA7M,KAAKoM,MAAMoM,mBACJ,KAIX,MAAMiB,EAAQ9Y,OAAO+Y,iBAAiB7M,GAGtC,GAAI7M,KAAKmY,eAAiBnY,KAAK2Z,YAAY9M,EAAS4M,GAEhD,OADAzZ,KAAKoM,MAAMkM,mBACJ,KAIX,MAAMsB,EAAO/M,EAAQgN,wBAGrB,GAAID,EAAKf,MAAQ7Y,KAAKkY,SAAW0B,EAAKb,OAAS/Y,KAAKkY,QAEhD,OADAlY,KAAKoM,MAAMmM,cACJ,KAGXvY,KAAKoM,MAAMiM,gBAGX,MAAMyB,EAAa,CAEfvY,KAAMsL,EAAQK,QAAQC,cAGtB4M,OAAQ,CACJC,EAAGlW,KAAKmW,MAAML,EAAKM,KAAOvZ,OAAOsY,SACjCkB,EAAGrW,KAAKmW,MAAML,EAAKQ,IAAMzZ,OAAOuY,SAChCL,MAAO/U,KAAKmW,MAAML,EAAKf,OACvBE,OAAQjV,KAAKmW,MAAML,EAAKb,SAI5BsB,QAASra,KAAKoY,cAAgBpY,KAAKsa,uBAAuBb,GAAS,KACnEc,OAAQva,KAAKwa,iBAAiBf,GAG9BgB,cAAeza,KAAKya,cAAc5N,GAClC6N,OAAQ1a,KAAK2a,gBAAgB9N,IAI3B+N,EAAW,GACXC,EAAgBlY,MAAMmI,KAAK+B,EAAQ+N,UAEzC,IAAK,MAAME,KAASD,EAAe,CAC/B,MAAME,EAAkB/a,KAAKoZ,iBAAiB0B,EAAOvB,EAAQ,GACzDwB,GACAH,EAASzR,KAAK4R,EAEtB,CAMA,OAJIH,EAAS/X,OAAS,IAClBiX,EAAWc,SAAWA,GAGnBd,CACX,CASA,kBAAAN,CAAmB3M,GAYf,MAXsB,CAClB,SACA,QACA,OACA,OACA,WACA,QACA,OACA,QAGiBjD,SAASiD,EAAQK,QAC1C,CAUA,WAAAyM,CAAY9M,EAAS4M,GAEjB,GAAsB,SAAlBA,EAAMuB,QACN,OAAO,EAIX,GAAyB,WAArBvB,EAAMwB,WACN,OAAO,EAIX,GAAkC,IAA9BC,WAAWzB,EAAM0B,SACjB,OAAO,EAIX,MAAMvB,EAAO/M,EAAQgN,wBACrB,OACID,EAAKwB,QAAS,KACdxB,EAAKQ,IAAMzZ,OAAOqY,YAAc,KAChCY,EAAKyB,OAAQ,KACbzB,EAAKM,KAAOvZ,OAAOmY,WAAa,GAMxC,CASA,sBAAAwB,CAAuBb,GACnB,IACI,MAAMY,EAAUZ,EAAM6B,gBAGtB,OAAKjB,GAAuB,gBAAZA,GAAyC,qBAAZA,EAKtCra,KAAKub,SAASlB,GAJV,IAKf,CAAE,MACE,OAAO,IACX,CACJ,CASA,QAAAkB,CAASC,GACL,IAEI,MAAMpS,EAAQoS,EAAIpS,MAAM,mDACxB,IAAKA,EACD,OAAO,KAGX,MAAMgB,EAAIpI,SAASoH,EAAM,GAAI,IACvBqS,EAAIzZ,SAASoH,EAAM,GAAI,IACvB6B,EAAIjJ,SAASoH,EAAM,GAAI,IAGvBsS,EAASC,IACX,MAAMC,EAAMD,EAAErR,SAAS,IACvB,OAAsB,IAAfsR,EAAI/Y,OAAe,IAAM+Y,EAAMA,GAG1C,MAAO,IAAIF,EAAMtR,KAAKsR,EAAMD,KAAKC,EAAMzQ,IAC3C,CAAE,MACE,OAAO,IACX,CACJ,CASA,gBAAAuP,CAAiBf,GACb,MAAMuB,EAAUvB,EAAMuB,QAEtB,OAAIA,EAAQpR,SAAS,QACV,OAGPoR,EAAQpR,SAAS,QACV,OAGK,WAAZoR,GAAoC,iBAAZA,EACjB,SAGJ,OACX,CASA,aAAAP,CAAc5N,GAUV,GATwB,CACpB,IACA,SACA,QACA,SACA,WACA,SAGgBjD,SAASiD,EAAQK,SACjC,OAAO,EAIX,GAAIL,EAAQgP,SAAWhP,EAAQiP,aAAa,WACxC,OAAO,EAKX,MAAqB,YADPnb,OAAO+Y,iBAAiB7M,GAC5BkP,MAKd,CASA,eAAApB,CAAgB9N,GAkBZ,MAjBiB,CACb,IACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,QACA,KACA,KACA,OACA,OAGYjD,SAASiD,EAAQK,QACrC,CAOA,QAAAlH,GACI,MAAO,IAAKhG,KAAKoM,MACrB,CAQA,YAAA4P,CAAalC,GACT,IAEI,OADatX,KAAKyM,UAAU6K,GAChBjX,MAChB,CAAE,MACE,OAAO,CACX,CACJ,CAQA,QAAAoZ,CAASnC,GAEL,MAAMoC,EAAexQ,IACjB,GAAI/I,MAAMC,QAAQ8I,GACd,OAAOA,EAAIV,IAAIkR,GAGnB,GAAY,OAARxQ,GAA+B,iBAARA,EAAkB,CACzC,MAAMC,EAAU,CAAA,EAChB,IAAK,MAAMC,KAAOF,EACG,OAAbA,EAAIE,SAA8BmB,IAAbrB,EAAIE,KACzBD,EAAQC,GAAOsQ,EAAYxQ,EAAIE,KAGvC,OAAOD,CACX,CAEA,OAAOD,GAGX,OAAOwQ,EAAYpC,EACvB,EASG,MAAMqC,EACT,WAAAzc,CAAYwF,EAAU,IAClBlF,KAAKoc,WAAa,IAAIpE,EAAc9S,GACpClF,KAAKqc,WAAanX,EAAQmX,YAAc,IACxCrc,KAAKsc,gBAAkB,EACvBtc,KAAKuc,eAAiB,IAC1B,CAQA,SAAA7D,CAAUC,GACN,MAAM7V,EAAMC,KAAKD,MACX0Z,EAAuB1Z,EAAM9C,KAAKsc,gBAGxC,GAAIE,EAAuBxc,KAAKqc,WAAY,CAExC,IAAKrc,KAAKuc,eAAgB,CACtB,MAAME,EAAgBzc,KAAKqc,WAAaG,EACxCxc,KAAKuc,eAAiB/G,WAAW,KAC7BxV,KAAKuc,eAAiB,KACtBvc,KAAKsc,gBAAkBvZ,KAAKD,OAE7B2Z,EACP,CACA,OAAO,IACX,CAIA,OADAzc,KAAKsc,gBAAkBxZ,EAChB9C,KAAKoc,WAAW1D,UAAUC,EACrC,CAOA,QAAA3S,GACI,OAAOhG,KAAKoc,WAAWpW,UAC3B,CAKA,aAAA0W,GACQ1c,KAAKuc,iBACL1G,aAAa7V,KAAKuc,gBAClBvc,KAAKuc,eAAiB,KAE9B,EC7dG,MAAMI,EAMT,WAAAjd,CAAY2F,EAActF,EAAgBJ,GACtCK,KAAKqF,aAAeA,EACpBrF,KAAKD,eAAiBA,EACtBC,KAAKL,OAASA,EACdK,KAAK4c,aAAc,EAGnB,MAAMP,EAAavY,KAAK+Y,IAAIld,EAAOmd,oBAAsB,IAAM,KAC/D9c,KAAK+c,cAAgB,IAAIZ,EAAuB,CAC5ClE,SAAU,GACVC,QAAS,EACTC,eAAe,EACfC,eAAe,EACfiE,aACAhL,QAAS1R,EAAOqd,iBAAmB,QACnC7a,MAAOxC,EAAOwC,QAAS,IAI3BnC,KAAKid,gBAAkB,CACnBC,MAAO,EACPC,UAAW,EACXC,SAAU,EACV7a,OAAQ,GAIZvC,KAAKqd,cAAgB,EACrBrd,KAAKsd,gBAAkBxZ,KAAK+Y,IAAIld,EAAO2d,iBAAmB,IAAM,KAChEtd,KAAKud,cAAgB,CACjBC,YAAa,EACbC,gBAAiB,EAEzB,CAKA,OAAAnd,GACI,IAAIN,KAAK4c,YAIT,IAEInb,SAASb,iBAAiB,QAAUC,IAChCb,KAAK0d,aAAa7c,KACnB,GAEHb,KAAK4c,aAAc,EAEf5c,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,mDAErB,CAAE,MAAOrB,GACLM,QAAQN,MAAM,kCAAmCA,EACrD,CACJ,CAUA,YAAA2c,CAAa7c,GACT,IAEI,MAAMiC,EAAMC,KAAKD,MAGjB,GAFA9C,KAAKud,cAAcC,cAEf1a,EAAM9C,KAAKqd,cAAgBrd,KAAKsd,gBAQhC,OAPAtd,KAAKud,cAAcE,uBACfzd,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,gCAAiC,CAC1Cub,mBAAoB7a,EAAM9C,KAAKqd,cAC/BO,kBAAmB5d,KAAKsd,mBAMpCtd,KAAKqd,cAAgBva,EAGrB,MAAM+a,EAAa,CACftc,KAAM,QACN8F,IAAK1G,OAAO2G,SAASC,KACrBzC,UAAW/B,KAAKD,MAChBgb,UAAW,CACP9D,EAAGnZ,EAAMkd,MACT5D,EAAGtZ,EAAMmd,MACTC,cAAetd,OAAOmY,WACtBoF,eAAgBvd,OAAOqY,YACvBmF,gBAAiBne,KAAKoe,iBAAiBvd,EAAMoM,SAEjDrH,UAAW5F,KAAKD,eAAegI,gBAInC/H,KAAKid,gBAAgBC,QACrB,IACI,MAAMmB,EAAcre,KAAK+c,cAAcrE,YAEvC,GAAI2F,GAKA,GAHAR,EAAWQ,YAAcA,EACzBre,KAAKid,gBAAgBG,WAEjBpd,KAAKL,OAAOwC,MAAO,CACnB,MAAM0P,EAAO7R,KAAK+c,cAAcX,WAAWJ,aAAaqC,GACxDhd,QAAQe,KAAK,sCAAuC,CAChDkc,SAAUD,EAAYjS,OAAOiM,eAAiB,EAC9CkG,UAAW1M,EACX2M,QAAS3M,EAAO,MAAMyH,QAAQ,IAEtC,OAGAtZ,KAAKid,gBAAgBE,YAEjBnd,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,uCAGzB,CAAE,MAAOqc,GAELze,KAAKid,gBAAgB1a,SACjBvC,KAAKL,OAAOwC,OACZd,QAAQN,MAAM,yCAA0C0d,EAGhE,EAGcze,KAAKqF,aAAaqZ,SAASb,IAE3B7d,KAAKL,OAAOwC,OACtBd,QAAQe,KAAK,8CAErB,CAAE,MAAOrB,GAELM,QAAQN,MAAM,wCAAyCA,EAC3D,CACJ,CAUA,gBAAAqd,CAAiBvR,GACb,IAAKA,GAAWA,IAAYpL,SACxB,MAAO,GAGX,IACI,MAAMkd,EAAQ,GACd,IAAIC,EAAU/R,EACV0M,EAAQ,EACZ,MAAMtB,EAAW,EAEjB,KAAO2G,GAAWA,IAAYnd,UAAY8X,EAAQtB,GAAU,CACxD,IAAI4G,EAAWD,EAAQ1R,QAAQC,cAG/B,GAAIyR,EAAQxR,KAAOpN,KAAK8e,sBAAsBF,EAAQxR,IAAK,CACvDyR,GAAY,IAAIE,IAAIC,OAAOJ,EAAQxR,MACnCuR,EAAMM,QAAQJ,GACd,KACJ,CAGA,MAAMK,EAAUlf,KAAKmf,gBAAgBP,GACjCM,EAAQrc,OAAS,IACjBgc,GAAY,IAAIK,EAAQ/T,KAAK,QAIjC,MAAMiU,EAAWR,EAAQS,cACrB1c,MAAMmI,KAAK8T,EAAQS,cAAczE,UAAU3X,OACvC6X,GAASA,EAAM5N,UAAY0R,EAAQ1R,SACnC,GAER,GAAIkS,EAASvc,OAAS,EAAG,CAErBgc,GAAY,cADEO,EAASE,QAAQV,GAAW,IAE9C,CAEAD,EAAMM,QAAQJ,GACdD,EAAUA,EAAQS,cAClB9F,GACJ,CAEA,OAAOoF,EAAMxT,KAAK,MACtB,CAAE,MAEE,OAAO0B,EAAQK,QAAUL,EAAQK,QAAQC,cAAgB,SAC7D,CACJ,CAKA,eAAAgS,CAAgBtS,GACZ,IAAKA,EAAQ0S,WAA0C,IAA7B1S,EAAQ0S,UAAU1c,OACxC,MAAO,GAIX,OADgBF,MAAMmI,KAAK+B,EAAQ0S,WAE9Btc,OAAOuc,IAEAA,EAAIpW,MAAM,kDAKVoW,EAAIpW,MAAM,uBAKVpJ,KAAK8e,sBAAsBU,KAMlCxU,IAAIwU,GAAOT,IAAIC,OAAOQ,IACtBvN,MAAM,EAAG,EAClB,CAKA,qBAAA6M,CAAsBzT,GAWlB,MAV0B,CACtB,eACA,SACA,SACA,WACA,QACA,OACA,WAGqB+L,KAAKC,GAAWA,EAAQoI,KAAKpU,GAC1D,CAQA,kBAAAqU,GACI,MAAO,IACA1f,KAAKid,gBACR0C,gBAAiB3f,KAAK+c,cAAc/W,WAE5C,CAOA,gBAAA4Z,GACI,MAAO,IACA5f,KAAKud,cACRsC,aAAc7f,KAAKud,cAAcC,YAAc,GACxCxd,KAAKud,cAAcE,gBAAkBzd,KAAKud,cAAcC,YAAc,KAAKlE,QAAQ,GAAK,IACzF,KACNgE,gBAAiBtd,KAAKsd,gBAE9B,CAKA,OAAAwC,GACI,IAEQ9f,KAAK+c,eAAiB/c,KAAK+c,cAAcL,eACzC1c,KAAK+c,cAAcL,gBAGnB1c,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,iCAErB,CAAE,MAAOrB,GACLM,QAAQN,MAAM,+BAAgCA,EAClD,CACJ,ECrTG,MAAMgf,EAUT,WAAArgB,CAAYC,EAAS,IAEjBK,KAAKL,OAAS,CACVqgB,yBAA0Blc,KAAK8O,IAAIjT,EAAOqgB,0BAA4B,GAAI,IAC1EC,wBAAyBnc,KAAK8O,IAAIjT,EAAOsgB,yBAA2B,GAAI,IACxEC,wBAAyBpc,KAAK8O,IAAIjT,EAAOugB,yBAA2B,GAAI,IACxEC,uBAAwBrc,KAAK8O,IAAIjT,EAAOwgB,wBAA0B,GAAI,IACtEC,gBAAiBtc,KAAK8O,IAAIjT,EAAOygB,iBAAmB,EAAG,IACvDje,MAAOxC,EAAOwC,QAAS,GAI3BnC,KAAKqgB,OAAS,GACdrgB,KAAKsgB,uBAAwB,EAC7BtgB,KAAKugB,mBAAqB,KAC1BvgB,KAAKwgB,gBAAkB,KACvBxgB,KAAKygB,oBAAsB,EAG3BzgB,KAAKoM,MAAQ,CACTvG,YAAa,EACb6a,cAAe,EACfC,gBAAiB,EACjBC,kBAAmB,GAGnB5gB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,wCAAyCpC,KAAKL,OAEnE,CAaA,QAAA+e,CAAS7d,GACL,IACI,OAAKA,GAAUA,EAAMiE,WAMrBjE,EAAM6E,MAAQ1F,KAAKsgB,sBAAwB,cAAgB,eAC3Dzf,EAAMggB,WAAa9d,KAAKD,MAGxB9C,KAAKqgB,OAAOlX,KAAKtI,GACjBb,KAAKoM,MAAMvG,cAGP7F,KAAKsgB,uBACLtgB,KAAKygB,sBAGDzgB,KAAK8gB,uBACL9gB,KAAK+gB,iBAIT/gB,KAAKghB,iBAIThhB,KAAKihB,eAEE,IA5BH5f,QAAQe,KAAK,oDACN,EA4Bf,CAAE,MAAOrB,GAGL,OAFAM,QAAQN,MAAM,qCAAsCA,GACpDf,KAAKoM,MAAMsU,iBACJ,CACX,CACJ,CAeA,wBAAAQ,CAAyBC,GACrB,IACInhB,KAAKwgB,gBAAkBW,EAAarc,WAAa/B,KAAKD,MACtD9C,KAAKygB,oBAAsB,EAI3BzgB,KAAKqgB,OAAOlX,KAAK,CACb5H,KAAM,QACNmE,MAAO,QACPZ,UAAW9E,KAAKwgB,gBAChBK,WAAY9d,KAAKD,MACjBuE,IAAK1G,OAAO2G,SAASC,KACrB4Z,iBAEJnhB,KAAKoM,MAAMvG,cAGX7F,KAAKsgB,uBAAwB,EAEzBtgB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,8CAA+C,CACxDgf,QAASD,EAAaC,QACtBC,WAAYrhB,KAAKqgB,OAAOxd,OACxBye,cAAe,GAAGthB,KAAKL,OAAOugB,+BAA+BlgB,KAAKL,OAAOwgB,iCAGrF,CAAE,MAAOpf,GACLM,QAAQN,MAAM,sDAAuDA,EACzE,CACJ,CAKA,aAAAggB,GACI,IACI,IAAK/gB,KAAKsgB,sBACN,OAGJtgB,KAAKsgB,uBAAwB,EAEzBtgB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,8CAA+C,CACxDyD,YAAa7F,KAAKqgB,OAAOxd,OACzB0e,gBAAiBvhB,KAAKygB,qBAGlC,CAAE,MAAO1f,GACLM,QAAQN,MAAM,0CAA2CA,EAC7D,CACJ,CAWA,mBAAA+f,GACI,IAAK9gB,KAAKsgB,wBAA0BtgB,KAAKwgB,gBACrC,OAAO,EAGX,MACMgB,GADMze,KAAKD,MACa9C,KAAKwgB,iBAAmB,IAGtD,OAAIgB,GAAkBxhB,KAAKL,OAAOugB,yBAC1BlgB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,qCAAqCof,EAAelI,QAAQ,SAEtE,GAIPtZ,KAAKygB,qBAAuBzgB,KAAKL,OAAOwgB,yBACpCngB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,sCAAsCpC,KAAKygB,gCAErD,EAIf,CAKA,cAAAO,GACI,IACI,MACMS,EADM1e,KAAKD,MACgD,IAAvC9C,KAAKL,OAAOqgB,yBAGhC0B,EAAe1hB,KAAKqgB,OAAOpd,OAAOpC,GACpCA,EAAMggB,YAAcY,GAA8B,UAAhB5gB,EAAM6E,OAItCI,EAAc4b,EAAaze,OAAO0e,GAAgB,UAAXA,EAAEpgB,MACzCqgB,EAAcF,EAAaze,OAAO0e,GAAgB,UAAXA,EAAEpgB,MAGzCsgB,EAAe/b,EAAYmM,OAAOjS,KAAKL,OAAOsgB,yBAMpD,GAJAjgB,KAAKqgB,OAAS,IAAIuB,KAAgBC,GAC7BC,KAAK,CAACC,EAAG9W,IAAM8W,EAAElB,WAAa5V,EAAE4V,YAGjC7gB,KAAKqgB,OAAOxd,OAAS6e,EAAa7e,OAAQ,CAC1C,MAAMmf,EAAUN,EAAa7e,OAAS7C,KAAKqgB,OAAOxd,OAClD7C,KAAKoM,MAAMsU,eAAiBsB,CAChC,CACJ,CAAE,MAAOjhB,GACLM,QAAQN,MAAM,4CAA6CA,EAC/D,CACJ,CAOA,SAAAkhB,GACI,MAAO,IAAIjiB,KAAKqgB,OACpB,CAQA,gBAAA6B,CAAiBxc,GACb,OAAO1F,KAAKqgB,OAAOpd,OAAOpC,GAASA,EAAM6E,QAAUA,EACvD,CAKA,KAAA4I,GACI,IACItO,KAAKqgB,OAAS,GACdrgB,KAAKsgB,uBAAwB,EAC7BtgB,KAAKugB,mBAAqB,KAC1BvgB,KAAKwgB,gBAAkB,KACvBxgB,KAAKygB,oBAAsB,EAEvBzgB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,wBAErB,CAAE,MAAOrB,GACLM,QAAQN,MAAM,wCAAyCA,EAC3D,CACJ,CAOA,WAAAohB,GACI,OAAOniB,KAAKsgB,qBAChB,CAOA,QAAAta,GACI,MAAO,IACAhG,KAAKoM,MACRgW,aAAcpiB,KAAKqgB,OAAOxd,OAC1Bsf,YAAaniB,KAAKsgB,sBAClBG,oBAAqBzgB,KAAKygB,oBAElC,CAKA,WAAAQ,GACI,IAEI,MAAMoB,EAAkBriB,KAAKsiB,qBAC7BtiB,KAAKoM,MAAMwU,kBAAoByB,EAI3BA,EAD+C,KAA9BriB,KAAKL,OAAOygB,gBAAyB,OAEtDpgB,KAAKoM,MAAMuU,kBAEX3gB,KAAKqgB,OAASrgB,KAAKqgB,OAAOpO,OAAOnO,KAAKC,MAAM/D,KAAKqgB,OAAOxd,OAAS,IAEzE,CAAE,MAAO9B,GACLM,QAAQN,MAAM,wCAAyCA,EAC3D,CACJ,CAOA,kBAAAuhB,GACI,IAEI,OADa9f,KAAKyM,UAAUjP,KAAKqgB,QACrBxd,MAChB,CAAE,MACE,OAAO,CACX,CACJ,CAOA,SAAA6V,GACI,MAAO,CACH2H,OAAQrgB,KAAKqgB,OACbC,sBAAuBtgB,KAAKsgB,sBAC5BE,gBAAiBxgB,KAAKwgB,gBACtBC,oBAAqBzgB,KAAKygB,oBAC1BrU,MAAOpM,KAAKoM,MAEpB,CAQA,WAAAmW,CAAY/X,GACR,IACI,IAAKA,GAAwB,iBAATA,EAIhB,OAHIxK,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,yCAEV,EAGXpC,KAAKqgB,OAAS1d,MAAMC,QAAQ4H,EAAK6V,QAAU7V,EAAK6V,OAAS,GACzDrgB,KAAKsgB,wBAA0B9V,EAAK8V,sBACpCtgB,KAAKwgB,gBAAkBhW,EAAKgW,iBAAmB,KAC/CxgB,KAAKygB,oBAAsBjW,EAAKiW,qBAAuB,EAEnDjW,EAAK4B,OAA+B,iBAAf5B,EAAK4B,QAC1BpM,KAAKoM,MAAQ,IAAKpM,KAAKoM,SAAU5B,EAAK4B,QAK1C,IAAIoW,EAAgB,EAUpB,GATAxiB,KAAKqgB,OAASrgB,KAAKqgB,OAAOrV,IAAInK,GACrBA,EAAM6E,MAKJ7E,GAJH2hB,IAEO,IAAK3hB,EAAO6E,MAAO,kBAK9B1F,KAAKL,OAAOwC,MAAO,CACnB,MAAMsgB,EAAiBziB,KAAKqgB,OAAOqC,OAAO,CAACC,EAAK9hB,KAC5C8hB,EAAI9hB,EAAM6E,QAAUid,EAAI9hB,EAAM6E,QAAU,GAAK,EACtCid,GACR,CAAA,GAEHthB,QAAQe,KAAK,+CAAgD,CACzDyD,YAAa7F,KAAKqgB,OAAOxd,OACzB+f,eAAgBJ,EAChBC,iBACAN,YAAaniB,KAAKsgB,sBAClBuC,SAAU7iB,KAAKsiB,sBAEvB,CAEA,OAAO,CACX,CAAE,MAAOvhB,GAEL,OADAM,QAAQN,MAAM,uCAAwCA,IAC/C,CACX,CACJ,EC1YG,MAAM+hB,EAUT,WAAApjB,CAAY2F,EAActF,EAAgBgjB,EAAiBnjB,EAAY,KAAMD,EAAS,IAClFK,KAAKqF,aAAeA,EACpBrF,KAAKD,eAAiBA,EACtBC,KAAK+iB,gBAAkBA,EACvB/iB,KAAKJ,UAAYA,EACjBI,KAAKL,OAAS,CACVwC,MAAOxC,EAAOwC,QAAS,EACvB6gB,aAAcrjB,EAAOqjB,cAAgB,IAIzChjB,KAAK4c,aAAc,EACnB5c,KAAK4T,aAAe,IAAIqP,IACxBjjB,KAAKkjB,4BAA8B,KACnCljB,KAAKmjB,qBAAsB,EAC3BnjB,KAAKojB,yBAA2B,KAGhCpjB,KAAKoM,MAAQ,CACTiX,eAAgB,EAChBC,cAAe,EACfC,gBAAiB,EACjBC,oBAAqB,EACrBC,0BAA2B,EAC3BC,4BAA6B,GAG7B1jB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,4BAErB,CAKA,OAAA9B,GACI,GAAIN,KAAK4c,YACLvb,QAAQe,KAAK,yCAIjB,IAOIpC,KAAKkjB,4BAA8BS,YAAY,KAC3C3jB,KAAK4T,aAAatF,SACnB,KAEHtO,KAAK4c,aAAc,EAEf5c,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,2BAErB,CAAE,MAAOrB,GACLM,QAAQN,MAAM,oCAAqCA,EACvD,CACJ,CAKA,SAAA6iB,GACI,IACQ5jB,KAAKkjB,8BACLW,cAAc7jB,KAAKkjB,6BACnBljB,KAAKkjB,4BAA8B,MAGvCljB,KAAK4c,aAAc,EAEf5c,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,6BAErB,CAAE,MAAOrB,GACLM,QAAQN,MAAM,sCAAuCA,EACzD,CACJ,CAWA,iBAAMwE,CAAYxE,EAAO+iB,GACrB,IAII,GAHA9jB,KAAKoM,MAAMiX,iBAGPrjB,KAAK+jB,kBAAkBhjB,GAKvB,OAJAf,KAAKoM,MAAMkX,gBACPtjB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,gCAAiCrB,EAAME,SAEjD,KAIX,MAAM+iB,EAAmBhkB,KAAKikB,yBAAyBljB,GAGvD,GAAIf,KAAK4T,aAAa2C,IAAIyN,GAKtB,OAJAhkB,KAAKoM,MAAMoX,sBACPxjB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,4CAEV,KAIXpC,KAAK4T,aAAatG,IAAI0W,GAGtB,MAAM7C,EAAe,CACjBC,QAAS,KACTngB,QAASF,EAAME,SAAW,gBAC1BM,KAAMR,EAAMyC,MAAQ,QACpBsB,UAAW/B,KAAKD,MAChB8B,MAAO7D,EAAM6D,OAAS,GACtByC,IAAK1G,OAAO2G,SAASC,MAIzBvH,KAAKqF,aAAa6b,yBAAyBC,GAG3C,MAAMlc,EAASjF,KAAKqF,aAAa4c,YAkBjC,OAhBIjiB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,iCAAkC,CAC3C8hB,aAAc/C,EAAalgB,QAC3BkF,WAAYlB,EAAOpC,OACnBshB,YAAankB,KAAKqF,aAAa6c,iBAAiB,gBAAgBrf,OAChEuhB,WAAYpkB,KAAKqF,aAAa6c,iBAAiB,eAAerf,SAItE7C,KAAKoM,MAAMmX,kBAGPvjB,KAAK+iB,uBACC/iB,KAAK+iB,gBAAgB5B,EAAclc,EAAQ6e,GAG9C,CACH3C,eACAlc,SACAW,UAAW5F,KAAKD,eAAegI,eAC/BqE,MAAOpM,KAAKqF,aAAaW,WAEjC,CAAE,MAAOqe,GAEL,OADAhjB,QAAQN,MAAM,yCAA0CsjB,GACjD,IACX,CACJ,CAQA,iBAAAN,CAAkBhjB,GACd,IACI,IAAKA,IAAUA,EAAME,QACjB,OAAO,EAGX,MAAMA,EAAUF,EAAME,QAAQkM,cAG9B,IAAK,MAAMkK,KAAWrX,KAAKL,OAAOqjB,aAC9B,GAAI/hB,EAAQ2I,SAASyN,EAAQlK,eACzB,OAAO,EAKf,MAAMmX,EAAuB,CACzB,eACA,gBACA,gBACA,+BAGJ,IAAK,MAAMjN,KAAWiN,EAClB,GAAIrjB,EAAQ2I,SAASyN,GACjB,OAAO,EAIf,OAAO,CACX,CAAE,MACE,OAAO,CACX,CACJ,CAQA,wBAAA4M,CAAyBljB,GACrB,IACI,MAAME,EAAUF,EAAME,SAAW,GAC3B2D,EAAQ7D,EAAM6D,OAAS,GAM7B,MAAO,GAAG3D,KAHa2D,EAAMkE,MAAM,MAAM,IAAM,IAInD,CAAE,MACE,MAAO,GAAG/F,KAAKD,SAASgB,KAAKuG,UACjC,CACJ,CAoBA,4BAAMhE,CAAuBtF,GACzB,IAgBI,GAdIf,KAAKmjB,sBACDnjB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,6EAIbpC,KAAKojB,0BACLpjB,KAAKojB,2BAGTpjB,KAAKoM,MAAMsX,gCAIV1jB,KAAKqF,eAAiBrF,KAAKD,eAE5B,YADAsB,QAAQN,MAAM,yEAKlB,IAAKA,GAA0B,iBAAVA,EAEjB,YADAM,QAAQN,MAAM,8DAIlBf,KAAKmjB,qBAAsB,EAC3BnjB,KAAKoM,MAAMqX,4BAEPzjB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,wDAGjB,MAAM+e,EAAe,CACjBC,QAAS,KACTngB,QAASF,EAAME,SAAW,gBAC1BM,KAAMR,EAAMyC,MAAQ,QACpBsB,UAAW/B,KAAKD,MAChBuE,IAAK1G,OAAO2G,SAASC,MAKzB,MAA0D,mBAA/CvH,KAAKqF,aAAa6b,0BAGzB7f,QAAQN,MAAM,sEACdf,KAAKmjB,qBAAsB,KAH3BnjB,KAAKqF,aAAa6b,yBAAyBC,GAQxC,IAAIvK,QAASC,IAChB,IAAI0N,EAAwB,KACxBC,EAAgB,KAChBC,EAAoB,KAGxB,MAAM3E,EAAU,KAERyE,IACAV,cAAcU,GACdA,EAAwB,MAIxBC,IACA7jB,OAAO+jB,oBAAoB,eAAgBF,GAC3CA,EAAgB,MAGhBC,IACAhjB,SAASijB,oBAAoB,mBAAoBD,GACjDA,EAAoB,MAIxBzkB,KAAKmjB,qBAAsB,EAC3BnjB,KAAKojB,yBAA2B,MAIpCpjB,KAAKojB,yBAA2BtD,EAEhC,MAAM6E,EAAkB,CAACrjB,EAAS,aAC1BtB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,wDAAwDd,MAIzEwe,IAIA,IAAI8E,EAAiB,GAKrB,GAJI5kB,KAAKqF,cAA8D,mBAAvCrF,KAAKqF,aAAa6c,mBAC9C0C,EAAiB5kB,KAAKqF,aAAa6c,iBAAiB,gBAAkB,IAGtE0C,EAAe/hB,OAAS,EAAG,CAE3B,MAAMmS,EAAuB,gBAAX1T,GAAuC,gBAAXA,EAG9CtB,KAAK8U,oBAAoBqM,EAAcyD,EAAgB5P,EAC3D,MAAWhV,KAAKL,OAAOwC,OACnBd,QAAQe,KAAK,8CAGjByU,KAIJ0N,EAAwBZ,YAAY,KAChC,IAEI,IAAK3jB,KAAKqF,cAAiE,mBAA1CrF,KAAKqF,aAAayb,oBAE/C,YADA6D,EAAgB,sBAIhB3kB,KAAKqF,aAAayb,uBAClB6D,EAAgB,gBAExB,CAAE,MAAO5jB,GACLM,QAAQN,MAAM,kDAAmDA,GACjE4jB,EAAgB,cACpB,GACD,KAGHH,EAAgB,KACZG,EAAgB,gBAEpBhkB,OAAOC,iBAAiB,eAAgB4jB,EAAe,CAAEK,MAAM,IAG/DJ,EAAoB,KACiB,WAA7BhjB,SAASC,iBACTijB,EAAgB,gBAGxBljB,SAASb,iBAAiB,mBAAoB6jB,EAAmB,CAAEI,MAAM,IAIzErP,WAAW,KACHxV,KAAKmjB,sBACDnjB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,gEAEjBuiB,EAAgB,oBAErB,QAEX,CAAE,MAAO5jB,GACLM,QAAQN,MAAM,oDAAqDA,GACnEf,KAAKmjB,qBAAsB,EAC3BnjB,KAAKojB,yBAA2B,IACpC,CACJ,CASA,mBAAAtO,CAAoBqM,EAAclc,EAAQ+P,GAAY,GAClD,IACI,GAAsB,IAAlB/P,EAAOpC,OACP,OAKJ,GAAmB,IADAoC,EAAOhC,OAAO0e,GAAKA,GAAgB,UAAXA,EAAEpgB,MAAkBsB,OAO3D,YALI7C,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,oEAAqE,CAC9EyD,YAAaZ,EAAOpC,UAOhC,MAAMkS,EAAkB,CACpBnP,UAAW5F,KAAKD,eAAegI,eAC/B9C,OAAQA,EACR4b,YAAY,IAAI9d,MAAOiF,cACvBX,IAAK1G,OAAO2G,SAASC,MAIrBvH,KAAKJ,WAA2D,mBAAvCI,KAAKJ,UAAUkV,qBACxC9U,KAAKJ,UAAUkV,oBAAoBC,EAAiBC,GAAWxU,MAAMO,IACjEM,QAAQN,MAAM,+DAAgEA,KAG9Ef,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,qDAAsD,CAC/D+D,WAAYlB,EAAOpC,OACnB+C,UAAWmP,EAAgBnP,UAC3B2J,OAAQyF,EAAY,aAAe,YAKvChV,KAAK+iB,iBACL/iB,KAAK+iB,gBAAgB5B,EAAclc,EAAQ,CAAE6f,UAAU,IAGvD9kB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,oDAAqD,CAC9D+D,WAAYlB,EAAOpC,SAInC,CAAE,MAAO9B,GACLM,QAAQN,MAAM,iDAAkDA,EACpE,CACJ,CAOA,QAAAiF,GACI,MAAO,IACAhG,KAAKoM,MACRwQ,YAAa5c,KAAK4c,YAClBmI,kBAAmB/kB,KAAK4T,aAAa/B,KAE7C,CAOA,UAAAmT,CAAWC,GACHA,IAAYjlB,KAAK4c,YACjB5c,KAAKM,WACG2kB,GAAWjlB,KAAK4c,aACxB5c,KAAK4jB,WAEb,CAOA,SAAAsB,GACI,OAAOllB,KAAK4c,WAChB,ECjgBG,MAAMuI,EAMT,WAAAzlB,CAAYC,EAAS,IACjBK,KAAKL,OAAS,CACVylB,sBAAuBthB,KAAK8O,IAAIjT,EAAOylB,uBAAyB,GAAI,KACpEjjB,MAAOxC,EAAOwC,QAAS,GAI3BnC,KAAKqlB,uBAAyB,yBAC9BrlB,KAAKslB,6BAA+B,+BAGpCtlB,KAAK4F,UAAY,KACjB5F,KAAKulB,SAAW,CACZC,UAAW,KACXC,eAAgB,KAChBC,UAAW,EACXC,MAAO,IAIX3lB,KAAK4lB,aAED5lB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,6BAA8B,CACvCwD,UAAW5F,KAAK4F,UAChB2f,SAAUvlB,KAAKulB,UAG3B,CAKA,UAAAK,GACI,KAEmB5lB,KAAK6lB,eAEL7lB,KAAK8lB,mBAEhB9lB,KAAK+lB,mBAGL/lB,KAAKgmB,iBAIThmB,KAAKimB,cAActlB,OAAO2G,SAASC,MAGnCvH,KAAKkmB,6BACT,CAAE,MAAOnlB,GACLM,QAAQN,MAAM,wCAAyCA,GAEvDf,KAAK+lB,kBACT,CACJ,CAKA,gBAAAA,GACI,IACI/lB,KAAK4F,UAAY5F,KAAKgK,oBACtBhK,KAAKulB,SAAW,CACZC,UAAWziB,KAAKD,MAChB2iB,eAAgB1iB,KAAKD,MACrB4iB,UAAW,EACXC,MAAO,IAGX3lB,KAAKmmB,cAEDnmB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,sCAAuCpC,KAAK4F,UAEjE,CAAE,MAAO7E,GACLM,QAAQN,MAAM,gDAAiDA,EACnE,CACJ,CAOA,WAAA8kB,GACI,IACI,MAAMjgB,EAAY3D,aAAaC,QAAQlC,KAAKqlB,wBACtCe,EAAenkB,aAAaC,QAAQlC,KAAKslB,8BAE/C,IAAK1f,IAAcwgB,EACf,OAAO,EAGX,MAAMb,EAAW/iB,KAAKC,MAAM2jB,GAE5B,SAAKb,IAAaA,EAASC,aAI3BxlB,KAAK4F,UAAYA,EACjB5F,KAAKulB,SAAWA,EAEZvlB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,iCAAkC,CAC3CwD,YACAygB,IAAKrmB,KAAKsmB,mBAIX,EACX,CAAE,MAAOvlB,GAEL,OADAM,QAAQN,MAAM,0CAA2CA,IAClD,CACX,CACJ,CAKA,WAAAolB,GACI,IACIlkB,aAAasC,QAAQvE,KAAKqlB,uBAAwBrlB,KAAK4F,WACvD3D,aAAasC,QACTvE,KAAKslB,6BACL9iB,KAAKyM,UAAUjP,KAAKulB,UAE5B,CAAE,MAAOxkB,GACLM,QAAQN,MAAM,0CAA2CA,EAC7D,CACJ,CAOA,gBAAA+kB,GACI,IACI,IAAK9lB,KAAKulB,SAASE,eACf,OAAO,EAGX,MAAM3iB,EAAMC,KAAKD,MACXyjB,EAAevmB,KAAKulB,SAASE,eAGnC,OAAQ3iB,EAAMyjB,EAFwC,GAApCvmB,KAAKL,OAAOylB,sBAA6B,GAG/D,CAAE,MACE,OAAO,CACX,CACJ,CAKA,cAAAY,GACI,IACIhmB,KAAKulB,SAASE,eAAiB1iB,KAAKD,MACpC9C,KAAKmmB,aACT,CAAE,MAAOplB,GACLM,QAAQN,MAAM,6CAA8CA,EAChE,CACJ,CAQA,aAAAklB,CAAc5e,GACV,IAEIrH,KAAKulB,SAASG,YAGd1lB,KAAKulB,SAASI,MAAMxc,KAAK,CACrB9B,MACAvC,UAAW/B,KAAKD,QAGhB9C,KAAKulB,SAASI,MAAM9iB,OAAS,KAC7B7C,KAAKulB,SAASI,MAAQ3lB,KAAKulB,SAASI,MAAM1T,OAAO,KAIrDjS,KAAKgmB,iBAGL,MAAMQ,EAAY,CACdjlB,KAAM,iBACN8F,MACAvC,UAAW/B,KAAKD,MAChB4C,MAAO,eACPE,UAAW5F,KAAK4F,UAChB8f,UAAW1lB,KAAKulB,SAASG,WAU7B,OAPI1lB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,oCAAqC,CAC9CiF,MACAqe,UAAW1lB,KAAKulB,SAASG,YAI1Bc,CACX,CAAE,MAAOzlB,GAEL,OADAM,QAAQN,MAAM,6CAA8CA,GACrD,IACX,CACJ,CAKA,2BAAAmlB,GACI,IAEI,MAAMxY,EAAoBC,QAAQC,UAC5BC,EAAuBF,QAAQG,aAErCH,QAAQC,UAAY,IAAIG,KACpBL,EAAkBO,MAAMN,QAASI,GACjC/N,KAAKymB,0BAGT9Y,QAAQG,aAAe,IAAIC,KACvBF,EAAqBI,MAAMN,QAASI,GACpC/N,KAAKymB,0BAIT9lB,OAAOC,iBAAiB,WAAY,KAChCZ,KAAKymB,2BAIT9lB,OAAOC,iBAAiB,aAAc,KAClCZ,KAAKymB,0BAEb,CAAE,MAAO1lB,GACLM,QAAQN,MAAM,4DAA6DA,EAC/E,CACJ,CAKA,sBAAA0lB,GACI,IACI,MAAMpf,EAAM1G,OAAO2G,SAASC,KAExBvH,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,sCAAuCiF,GAIxDrH,KAAKimB,cAAc5e,EACvB,CAAE,MAAOtG,GACLM,QAAQN,MAAM,sDAAuDA,EACzE,CACJ,CAOA,YAAAgH,GACI,OAAO/H,KAAK4F,SAChB,CAOA,WAAA8gB,GACI,MAAO,IAAK1mB,KAAKulB,SACrB,CAOA,aAAAe,GACI,OAAKtmB,KAAKulB,SAASC,UAIZziB,KAAKD,MAAQ9C,KAAKulB,SAASC,UAHvB,CAIf,CAOA,iBAAAxb,GACI,IAEI,OAAIC,QAAUA,OAAOC,WACVD,OAAOC,aAIX,uCAAuCC,QAAQ,QAAUjG,IAC5D,MAAMkG,EAAoB,GAAhBtG,KAAKuG,SAAgB,EAE/B,OADgB,MAANnG,EAAYkG,EAAS,EAAJA,EAAU,GAC5BE,SAAS,KAE1B,CAAE,MAEE,MAAO,GAAGvH,KAAKD,SAASgB,KAAKuG,SAASC,SAAS,IAAI3B,UAAU,EAAG,KACpE,CACJ,CAKA,YAAAge,GACI,IACI1kB,aAAaI,WAAWrC,KAAKqlB,wBAC7BpjB,aAAaI,WAAWrC,KAAKslB,8BAE7BtlB,KAAK4F,UAAY,KACjB5F,KAAKulB,SAAW,CACZC,UAAW,KACXC,eAAgB,KAChBC,UAAW,EACXC,MAAO,IAGP3lB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,kCAErB,CAAE,MAAOrB,GACLM,QAAQN,MAAM,2CAA4CA,EAC9D,CACJ,CAKA,aAAA6lB,GACI,IACI5mB,KAAKgmB,iBAEDhmB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,mCAErB,CAAE,MAAOrB,GACLM,QAAQN,MAAM,4CAA6CA,EAC/D,CACJ,CAOA,cAAA8lB,GACI,MAAO,CACHjhB,UAAW5F,KAAK4F,UAChBygB,IAAKrmB,KAAKsmB,gBACVQ,WAAYhjB,KAAKC,MAAM/D,KAAKsmB,gBAAkB,IAAO,IACrDS,UAAW/mB,KAAK8lB,mBAChBJ,UAAW1lB,KAAKulB,SAASG,UACzBsB,YAAahnB,KAAKulB,SAASI,MAAM1T,OAAM,GACvCgV,eAAgBjnB,KAAKL,OAAOylB,sBAEpC,EC5XG,MAAM8B,EAMT,WAAAxnB,CAAYC,EAAS,IACjBK,KAAKL,OAAS,CACVygB,gBAAiBtc,KAAK8O,IAAIjT,EAAOygB,iBAAmB,EAAG,IACvDje,MAAOxC,EAAOwC,QAAS,GAI3BnC,KAAKmnB,mBAAqB,4BAC1BnnB,KAAKonB,qBAAuB,8BAG5BpnB,KAAKoM,MAAQ,CACTib,gBAAiB,EACjBC,YAAa,EACbC,gBAAiB,EACjBC,YAAa,EACbC,mBAAoB,EACpBC,aAAc,GAGd1nB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,0CAA2CpC,KAAKL,OAErE,CAQA,IAAAgoB,CAAKC,GACD,IACI,IAAKA,GAAoC,iBAAfA,EAEtB,OADAvmB,QAAQe,KAAK,wCACN,EAIX,MAAMylB,EAAgB7nB,KAAKgc,aAAa4L,GAClCE,EAA6C,KAA9B9nB,KAAKL,OAAOygB,gBAAyB,KAsC1D,OApCIyH,EAAgBC,IACZ9nB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,mCAAoC,CAC7CyP,KAAMgW,EACNhL,IAAKiL,EACLC,QAASF,EAAgB,KAAO,MAAMvO,QAAQ,KAKtDtZ,KAAK8f,UAGD+H,EAAgBC,IAChBF,EAAa5nB,KAAKgoB,YAAYJ,EAAYE,KAKlD7lB,aAAasC,QAAQvE,KAAKmnB,mBAAoB3kB,KAAKyM,UAAU2Y,IAG7D5nB,KAAKioB,aAAa,CACdC,QAASnlB,KAAKD,MACd+O,KAAMgW,IAGV7nB,KAAKoM,MAAMib,kBAEPrnB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,+BAAgC,CACzCyP,KAAMgW,EACN5iB,OAAQ2iB,EAAWvH,QAAQxd,QAAU,KAItC,CACX,CAAE,MAAO9B,GAGL,GAFAf,KAAKoM,MAAMkb,cAEQ,uBAAfvmB,EAAMyC,KAA+B,CACrCxD,KAAKoM,MAAMqb,qBAEPznB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,sDAIjBpC,KAAK8f,UAEL,IAEI,MAAMqI,EAAenoB,KAAKgoB,YACtBJ,EAC8B,KAA9B5nB,KAAKL,OAAOygB,gBAAyB,KAAO,GAShD,OANAne,aAAasC,QACTvE,KAAKmnB,mBACL3kB,KAAKyM,UAAUkZ,IAGnBnoB,KAAKoM,MAAMib,mBACJ,CACX,CAAE,MAEE,OADAhmB,QAAQN,MAAM,sDACP,CACX,CACJ,CAGA,OADAM,QAAQN,MAAM,yCAA0CA,IACjD,CACX,CACJ,CAOA,IAAAqnB,GACI,IACI,MAAM9lB,EAASL,aAAaC,QAAQlC,KAAKmnB,oBAEzC,IAAK7kB,EACD,OAAO,KAGX,MAAMslB,EAAaplB,KAAKC,MAAMH,GAE9B,OAAKslB,GAAoC,iBAAfA,EAKrBjlB,MAAMC,QAAQglB,EAAWvH,SAK9BrgB,KAAKoM,MAAMmb,kBAEPvnB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,gCAAiC,CAC1C6C,OAAQ2iB,EAAWvH,OAAOxd,OAC1Bsf,YAAayF,EAAWtH,wBAIzBsH,IAbHvmB,QAAQe,KAAK,4CACN,MANA,IAmBf,CAAE,MAAOrB,GAGL,OAFAf,KAAKoM,MAAMob,cACXnmB,QAAQN,MAAM,yCAA0CA,GACjD,IACX,CACJ,CAKA,KAAAuN,GACI,IACIrM,aAAaI,WAAWrC,KAAKmnB,oBAC7BllB,aAAaI,WAAWrC,KAAKonB,sBAEzBpnB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,iCAErB,CAAE,MAAOrB,GACLM,QAAQN,MAAM,0CAA2CA,EAC7D,CACJ,CAKA,OAAA+e,GACI,IAEI,MAAMyF,EAAWvlB,KAAKqoB,eAEtB,GAAI9C,GAAYA,EAAS2C,QAAS,CAC9B,MAAM7B,EAAMtjB,KAAKD,MAAQyiB,EAAS2C,QAG9B7B,EAFW,QAGXrmB,KAAKsO,QACLtO,KAAKoM,MAAMsb,eAEP1nB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,wCAAyC,CAClDkmB,UAAWjC,EAAM,IAAO,GAAK,IAAI/M,QAAQ,KAIzD,CACJ,CAAE,MAAOvY,GACLM,QAAQN,MAAM,kCAAmCA,EACrD,CACJ,CAOA,YAAAknB,CAAa1C,GACT,IACItjB,aAAasC,QACTvE,KAAKonB,qBACL5kB,KAAKyM,UAAUsW,GAEvB,CAAE,MAAOxkB,GAEDf,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,2CAA4CrB,EAEjE,CACJ,CAOA,YAAAsnB,GACI,IACI,MAAM/lB,EAASL,aAAaC,QAAQlC,KAAKonB,sBAEzC,OAAK9kB,EAIEE,KAAKC,MAAMH,GAHP,IAIf,CAAE,MACE,OAAO,IACX,CACJ,CASA,WAAA0lB,CAAYJ,EAAYE,GACpB,IACI,IAAKF,EAAWvH,SAAW1d,MAAMC,QAAQglB,EAAWvH,QAChD,OAAOuH,EAIX,MAAMW,EAAS,IAAKX,GACd3iB,EAAS,IAAI2iB,EAAWvH,QAG9B,KAAOrgB,KAAKgc,aAAauM,GAAUT,GAAgB7iB,EAAOpC,OAAS,GAAG,CAElE,MAAM2lB,EAAUvjB,EAAOoJ,QAGvB,GAAIma,GAA6B,UAAlBA,EAAQ9iB,MAAmB,CACtCT,EAAOga,QAAQuJ,GACf,KACJ,CAEAD,EAAOlI,OAASpb,CACpB,CAWA,OATIjF,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,gCAAiC,CAC1CqmB,eAAgBb,EAAWvH,OAAOxd,OAClC6lB,aAAczjB,EAAOpC,OACrB8lB,aAAc3oB,KAAKgc,aAAa4L,GAChCgB,WAAY5oB,KAAKgc,aAAauM,KAI/BA,CACX,CAAE,MAAOxnB,GAEL,OADAM,QAAQN,MAAM,0CAA2CA,GAClD6mB,CACX,CACJ,CAQA,YAAA5L,CAAaxR,GACT,IAEI,OADahI,KAAKyM,UAAUzE,GAChB3H,MAChB,CAAE,MACE,OAAO,CACX,CACJ,CAOA,YAAAgmB,GACI,IACI,MAAMC,EAAU,yBACVC,EAAW,IAAIC,OAAO,MAE5B,IAAIC,EAAY,EACZC,EAAO,EAGX,IAAK,MAAMtd,KAAO3J,aACV4J,OAAOqD,UAAUiI,eAAerI,KAAK7M,aAAc2J,KACnDsd,GAAQjnB,aAAa2J,GAAK/I,OAAS+I,EAAI/I,QAK/C,IACI,IAAK,IAAI0I,EAAI,EAAGA,EAAI,IAAOA,IACvBtJ,aAAasC,QAAQukB,EAASC,EAASC,OAAOzd,IAC9C0d,EAAgB,KAAJ1d,CAEpB,CAAE,MAEF,CAAC,QACGtJ,aAAaI,WAAWymB,EAC5B,CAEA,MAAO,CACHK,UAAWD,EACXE,QAASF,EAAO,KAAO,MAAM5P,QAAQ,GACrC+P,aAAcJ,EAAY,KAAO,MAAM3P,QAAQ,GAC/CgQ,UAAWJ,EAAOD,GAAa,KAAO,MAAM3P,QAAQ,GAE5D,CAAE,MACE,MAAO,CACH6P,UAAW,EACXC,OAAQ,UACRC,YAAa,UACbC,QAAS,UAEjB,CACJ,CAOA,QAAAtjB,GACI,MAAMujB,EAAYvpB,KAAK6oB,eAEvB,MAAO,IACA7oB,KAAKoM,SACLmd,EACHnJ,gBAAiBpgB,KAAKL,OAAOygB,gBAErC,CAOA,WAAAoJ,GACI,IACI,MAAMV,EAAU,mBAGhB,OAFA7mB,aAAasC,QAAQukB,EAAS,QAC9B7mB,aAAaI,WAAWymB,IACjB,CACX,CAAE,MACE,OAAO,CACX,CACJ,ECjXJ,MAAMW,EA+BF,WAAA/pB,CAAYC,GAER,IAAKA,IAAWA,EAAOqT,IACnB,MAAM,IAAIhS,MAAM,gFAGpB,IAAKrB,EAAOoT,OACR,MAAM,IAAI/R,MAAM,6DAGpBhB,KAAKL,OAAS,CAEVwC,OAAO,EACP4U,YAAa,CAAC,WAAY,QAAS,UAAW,UAG9C2S,sBAAsB,EACtB1J,yBAA0B,GAC1BC,wBAAyB,GACzBC,wBAAyB,GACzBC,uBAAwB,GACxBrD,mBAAoB,IACpBE,gBAAiB,QACjBoI,sBAAuB,GACvBhF,gBAAiB,EACjBuJ,WAAW,EAGXvW,+BAAgC,EAChCC,wBAAyB,IACzBE,oBAAqB,GACrBC,qBAAsB,MACtBE,qBAAsB,GACtBC,sBAAuB,KACvBI,sBAAuB,OAGpBpU,GAIPK,KAAKJ,UAAY,IAAIkT,EAAU9S,KAAKL,QAIpCK,KAAKH,YAAc,IAAI2M,EACnB,GACA,CAACzL,EAAOmE,KAEAlF,KAAKL,QAAUK,KAAKL,OAAOwC,OAC3Bd,QAAQe,KAAK,+DAAgErB,GAEjFf,KAAKc,iBAAiBC,EAAOmE,KAKrClF,KAAKD,eAAiB,KACtBC,KAAKqF,aAAe,KACpBrF,KAAK4pB,eAAiB,KACtB5pB,KAAKF,cAAgB,KACrBE,KAAK6pB,QAAU,KAEX7pB,KAAKL,OAAO+pB,sBACZ1pB,KAAK8pB,0BAIT9pB,KAAK+pB,OAAS,IAAItqB,EACdO,KAAKL,OACLK,KAAKJ,UACLI,KAAKH,YACLG,KAAKF,cACLE,KAAKD,gBAGTC,KAAKgqB,aAAc,CACvB,CAKA,uBAAAF,GACI,IAEI9pB,KAAKD,eAAiB,IAAIolB,EAAe,CACrCC,sBAAuBplB,KAAKL,OAAOylB,sBACnCjjB,MAAOnC,KAAKL,OAAOwC,QAIvBnC,KAAKqF,aAAe,IAAI0a,EAAa,CACjCC,yBAA0BhgB,KAAKL,OAAOqgB,yBACtCC,wBAAyBjgB,KAAKL,OAAOsgB,wBACrCC,wBAAyBlgB,KAAKL,OAAOugB,wBACrCC,uBAAwBngB,KAAKL,OAAOwgB,uBACpCC,gBAAiBpgB,KAAKL,OAAOygB,gBAC7Bje,MAAOnC,KAAKL,OAAOwC,QAIvBnC,KAAK4pB,eAAiB,IAAI1C,EAAe,CACrC9G,gBAAiBpgB,KAAKL,OAAOygB,gBAC7Bje,MAAOnC,KAAKL,OAAOwC,QAIvBnC,KAAKF,cAAgB,IAAIgjB,EACrB9iB,KAAKqF,aACLrF,KAAKD,eACLC,KAAKiqB,oBAAoBC,KAAKlqB,MAC9BA,KAAKJ,UACL,CACIuC,MAAOnC,KAAKL,OAAOwC,MACnB6gB,aAAc,KAKtBhjB,KAAK6pB,QAAU,IAAIlN,EACf3c,KAAKqF,aACLrF,KAAKD,eACLC,KAAKL,QAIT,MAAMwqB,EAAcnqB,KAAK4pB,eAAexB,OACpC+B,IACAnqB,KAAKqF,aAAakd,YAAY4H,GAC1BnqB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,4DAA6D,CACtE6C,OAAQklB,EAAY9J,QAAQxd,QAAU,KAK9C7C,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,gDAErB,CAAE,MAAOrB,GACLM,QAAQN,MAAM,yDAA0DA,GAExEf,KAAKL,OAAO+pB,sBAAuB,CACvC,CACJ,CAgBA,yBAAMO,CAAoB9I,EAAclc,EAAQ6e,GAC5C,IACQ9jB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,+CAAgD,CACzD8hB,aAAc/C,EAAalgB,QAC3BkF,WAAYlB,EAAOpC,OACnB+C,UAAW5F,KAAKD,eAAegI,iBAKvC,MAAM+R,EAAa9Z,KAAKqF,aAAaqT,YACrC1Y,KAAK4pB,eAAejC,KAAK7N,EAC7B,CAAE,MAAO/Y,GACLM,QAAQN,MAAM,kDAAmDA,EACrE,CACJ,CAUA,IAAAqpB,GACI,GAAIpqB,KAAKgqB,YACL3oB,QAAQe,KAAK,8CA0CjB,GApCApC,KAAKH,YAAYS,UAGbN,KAAKL,OAAO+pB,sBAAwB1pB,KAAK6pB,UACzC7pB,KAAK6pB,QAAQvpB,UACbN,KAAKF,cAAcQ,UAInBN,KAAKqqB,mBAAqB1G,YAAY,KAClC3jB,KAAKsqB,uBACN,KAGH3pB,OAAOC,iBAAiB,eAAgB,KACpCZ,KAAKsqB,wBAIT7oB,SAASb,iBAAiB,mBAAoB,KACT,WAA7Ba,SAASC,iBACT1B,KAAKsqB,wBAITtqB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,yFAMrBpC,KAAK+pB,OAAOzpB,UAEZN,KAAKgqB,aAAc,EAEfhqB,KAAKL,OAAOwC,MAAO,CACnB,MAAMooB,EAAc5pB,OAAO6D,kBAAkBgL,UACvCzM,KAAKD,MAAQnC,OAAO6D,iBAAiBgL,UACrC,UAENnO,QAAQe,KAAK,gCAAiC,CAC1C+E,YAAanH,KAAKL,OAAOwH,YACzBC,QAASpH,KAAKL,OAAOyH,QACrBsiB,qBAAsB1pB,KAAKL,OAAO+pB,qBAClC9jB,UAAW5F,KAAKD,gBAAgBgI,eAChCwiB,YAAaA,EAAc,KAC3BC,eAAgB7pB,OAAO6D,kBAAkBjC,QAAQM,QAAU,GAEnE,CACJ,CAKA,mBAAAynB,GACI,IACI,GAAItqB,KAAKqF,cAAgBrF,KAAK4pB,eAAgB,CAC1C,MAAM9P,EAAa9Z,KAAKqF,aAAaqT,YACrC1Y,KAAK4pB,eAAejC,KAAK7N,GAErB9Z,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,kDAErB,CACJ,CAAE,MAAOrB,GACLM,QAAQN,MAAM,2CAA4CA,EAC9D,CACJ,CAUA,gBAAAD,CAAiBC,EAAOmE,EAAU,IAC9BlF,KAAK+pB,OAAOjpB,iBAAiBC,EAAOmE,EACxC,CASA,cAAAuB,CAAexF,EAASyF,EAAQ,OAAQxB,EAAU,CAAA,GAC9ClF,KAAK+pB,OAAOtjB,eAAexF,EAASyF,EAAOxB,EAC/C,CAYA,aAAAulB,CAAcrc,GACVpO,KAAKH,YAAYyN,IAAIc,EACzB,CAUA,OAAArC,CAAQC,GACJhM,KAAK+pB,OAAOhe,QAAQC,EACxB,CAOA,OAAAC,CAAQ/L,GACJF,KAAK+pB,OAAO9d,QAAQ/L,EACxB,CAOA,QAAAgM,CAAS/L,GACLH,KAAK+pB,OAAO7d,SAAS/L,EACzB,CAUA,iBAAIuqB,GACA,OAAK1qB,KAAKL,OAAOgqB,UAIV,CAIHgB,OAAQ,KACC3qB,KAAKL,OAAO+pB,uBACb1pB,KAAKL,OAAO+pB,sBAAuB,EAG9B1pB,KAAK6pB,UACN7pB,KAAK8pB,0BACD9pB,KAAKgqB,aAAehqB,KAAK6pB,UACzB7pB,KAAK6pB,QAAQvpB,UACbN,KAAKF,cAAcQ,YAIvBN,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,+CAQzBwoB,QAAS,KACD5qB,KAAKL,OAAO+pB,uBACZ1pB,KAAKL,OAAO+pB,sBAAuB,EAG/B1pB,KAAKqqB,qBACLxG,cAAc7jB,KAAKqqB,oBACnBrqB,KAAKqqB,mBAAqB,MAI1BrqB,KAAK6pB,SACL7pB,KAAK6pB,QAAQ/J,UAEb9f,KAAKF,eACLE,KAAKF,cAAc8jB,YAEvB5jB,KAAKsqB,sBAEDtqB,KAAKL,OAAOwC,OACZd,QAAQe,KAAK,gDASzB8iB,UAAW,IACAllB,KAAKL,OAAO+pB,qBAOvB1jB,SAAU,IACDhG,KAAKL,OAAO+pB,qBAIV,CACHzE,SAAS,EACTrf,UAAW5F,KAAKD,gBAAgBgI,eAChC8iB,WAAY7qB,KAAKD,gBAAgBumB,gBACjCvgB,YAAa/F,KAAKqF,cAAcW,WAChC8kB,aAAc9qB,KAAK4pB,gBAAgB5jB,WACnCiX,gBAAiBjd,KAAK6pB,SAASnK,qBAC/BnC,cAAevd,KAAK6pB,SAASjK,mBAC7BmL,mBAAoB/qB,KAAKF,eAAekG,YAXjC,CAAEif,SAAS,IApEnB,IAmFf,EAOkB,oBAAXtkB,SACPA,OAAO8oB,kBAAoBA"}