{"version":3,"file":"logger.js","sources":["../src/client.js","../src/breadcrumbs.js","../src/circuit-breaker.js","../src/storage-queue.js","../src/rate-limiter.js","../src/transport.js","../src/heatmap.js","../src/index.js"],"sourcesContent":["/**\n * Client for capturing errors and sending to platform\n *\n * RESILIENCE FEATURES:\n * - Beacon API for page unload events (ensures critical errors are sent)\n * - All error handling wrapped in try-catch\n * - Never crashes on logging errors\n */\nexport class Client {\n    constructor(config, transport, breadcrumbs) {\n        this.config = config;\n        this.transport = transport;\n        this.breadcrumbs = breadcrumbs;\n        this.userContext = null;\n        this.tags = {};\n        this.extra = {};\n        this.pendingBeaconErrors = [];\n    }\n\n    /**\n   * Install global error handlers\n   */\n    install() {\n        try {\n            // Handle uncaught errors\n            window.addEventListener('error', (event) => {\n                try {\n                    this.captureException(event.error || new Error(event.message), {\n                        extra: {\n                            filename: event.filename,\n                            lineno: event.lineno,\n                            colno: event.colno,\n                        },\n                    });\n                } catch (error) {\n                    // Never crash on error handling\n                    console.error('ApplicationLogger: Failed to capture error', error);\n                }\n            });\n\n            // Handle unhandled promise rejections\n            window.addEventListener('unhandledrejection', (event) => {\n                try {\n                    this.captureException(event.reason, {\n                        extra: {\n                            type: 'unhandledrejection',\n                        },\n                    });\n                } catch (error) {\n                    console.error('ApplicationLogger: Failed to capture rejection', error);\n                }\n            });\n\n            // Use Beacon API for page unload to ensure critical errors are sent\n            window.addEventListener('beforeunload', () => {\n                this.flushBeaconErrors();\n            });\n\n            // Also try on visibilitychange (for mobile)\n            document.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'hidden') {\n                    this.flushBeaconErrors();\n                }\n            });\n\n            // Track breadcrumbs\n            this.breadcrumbs.install();\n        } catch (error) {\n            // Installation failure should never crash the app\n            console.error('ApplicationLogger: Failed to install', error);\n        }\n    }\n\n    /**\n   * Capture exception\n   */\n    captureException(error, options = {}) {\n        const payload = this.buildPayload(error, 'error', options);\n        this.transport.send(payload);\n    }\n\n    /**\n   * Capture message\n   */\n    captureMessage(message, level = 'info', options = {}) {\n        const payload = this.buildPayload(new Error(message), level, options);\n        this.transport.send(payload);\n    }\n\n    /**\n   * Build error payload matching API expectations\n   *\n   * API expects flat structure with snake_case field names:\n   * {type, message, file, line, stack_trace, level, environment, ...}\n   */\n    buildPayload(error, level, options = {}) {\n        try {\n            const stackTrace = this.parseStackTrace(error);\n            const firstFrame = stackTrace.length > 0 ? stackTrace[0] : null;\n\n            // Build payload matching exact API format\n            const payload = {\n                // Required fields (flat structure, not nested)\n                type: error.name || 'Error',\n                message: error.message || 'Unknown error',\n                file: firstFrame?.file || options.extra?.filename || 'unknown',\n                line: firstFrame?.line || options.extra?.lineno || 0,\n                stack_trace: stackTrace,\n\n                // Optional fields (snake_case to match API)\n                level: level || 'error',\n                environment: this.config.environment || 'production',\n                release: this.config.release || null,\n                url: window.location.href,\n                http_method: this.detectHttpMethod(),\n                http_status_code: this.extractHttpStatusCode(error, options),\n                session_hash: this.getSessionHash(),\n                timestamp: new Date().toISOString(),\n                runtime: `JavaScript ${this.getBrowserInfo()}`,\n                user_agent: navigator.userAgent,\n                breadcrumbs: this.breadcrumbs.get(),\n                context: { ...this.extra, ...options.extra },\n                tags: { ...this.tags, ...options.tags },\n            };\n\n            // Clean up null values to reduce payload size\n            return this.removeNullValues(payload);\n        } catch (error) {\n            // If payload building completely fails, return minimal payload\n            console.error('ApplicationLogger: Failed to build payload', error);\n            return {\n                type: 'Error',\n                message: 'Failed to build error payload',\n                file: 'unknown',\n                line: 0,\n                stack_trace: [],\n                level: 'error',\n            };\n        }\n    }\n\n    /**\n   * Parse error stack trace with cross-browser support\n   *\n   * Returns array of frames matching API format:\n   * [{file, line, function, class, column}, ...]\n   */\n    parseStackTrace(error) {\n        if (!error.stack) {\n            return [{\n                file: 'unknown',\n                line: 0,\n                function: 'unknown',\n            }];\n        }\n\n        try {\n            const lines = error.stack.split('\\n');\n            const frames = [];\n\n            for (const line of lines) {\n                const frame = this.parseStackLine(line.trim());\n                if (frame) {\n                    frames.push(frame);\n                }\n            }\n\n            return frames.length > 0 ? frames : [{\n                file: 'unknown',\n                line: 0,\n                function: 'unknown',\n            }];\n        } catch {\n            return [{\n                file: 'unknown',\n                line: 0,\n                function: 'unknown',\n            }];\n        }\n    }\n\n    /**\n   * Parse a single stack trace line (cross-browser)\n   *\n   * Handles formats from Chrome, Firefox, Safari, Edge\n   */\n    parseStackLine(line) {\n        if (!line) {\n            return null;\n        }\n\n        // Chrome/V8: \"at functionName (file.js:line:col)\"\n        let match = line.match(/at\\s+(.+?)\\s+\\((.+?):(\\d+):(\\d+)\\)/);\n        if (match) {\n            return {\n                function: match[1].trim(),\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Chrome/V8 anonymous: \"at file.js:line:col\"\n        match = line.match(/at\\s+(.+?):(\\d+):(\\d+)/);\n        if (match) {\n            return {\n                function: 'anonymous',\n                file: match[1],\n                line: parseInt(match[2], 10),\n                column: parseInt(match[3], 10),\n            };\n        }\n\n        // Firefox: \"functionName@file.js:line:col\"\n        match = line.match(/(.+?)@(.+?):(\\d+):(\\d+)/);\n        if (match) {\n            return {\n                function: match[1] || 'anonymous',\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Safari/Firefox (no column): \"functionName@file.js:line\"\n        match = line.match(/(?:(.+)@)?(.+?):(\\d+)$/);\n        if (match) {\n            return {\n                function: match[1] || 'anonymous',\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: null,\n            };\n        }\n\n        // Edge legacy: \"at functionName (file.js:line:col)\"\n        match = line.match(/at\\s+(.+?)\\s+\\[(.+?):(\\d+):(\\d+)\\]/);\n        if (match) {\n            return {\n                function: match[1].trim(),\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Could not parse this line\n        return null;\n    }\n\n    /**\n   * Detect HTTP method for current page load\n   */\n    detectHttpMethod() {\n        try {\n            // Try to detect from performance API\n            const navigation = performance.getEntriesByType('navigation')[0];\n            if (navigation && navigation.type) {\n                // Navigation types: navigate, reload, back_forward, prerender\n                return 'GET'; // Page loads are always GET\n            }\n        } catch {\n            // Performance API not available\n        }\n\n        // Default to GET (most common for page loads)\n        return 'GET';\n    }\n\n    /**\n     * Extract HTTP status code from error context.\n     *\n     * Attempts to extract status code from:\n     * 1. Error object's status property (fetch Response)\n     * 2. Options extra data (manually passed)\n     * 3. Error message parsing (e.g., \"HTTP 404 Not Found\")\n     *\n     * @param {Error} error - The error object\n     * @param {Object} options - Additional options passed to captureException\n     * @returns {number|null} HTTP status code or null if not available\n     */\n    extractHttpStatusCode(error, options = {}) {\n        try {\n            // Check if error has status property (fetch Response errors)\n            if (error.status && typeof error.status === 'number') {\n                return error.status;\n            }\n\n            // Check if status was passed in options\n            if (options.httpStatusCode && typeof options.httpStatusCode === 'number') {\n                return options.httpStatusCode;\n            }\n\n            // Check extra context for status code\n            if (options.extra?.http_status_code && typeof options.extra.http_status_code === 'number') {\n                return options.extra.http_status_code;\n            }\n\n            if (options.extra?.httpStatusCode && typeof options.extra.httpStatusCode === 'number') {\n                return options.extra.httpStatusCode;\n            }\n\n            // Try to parse status code from error message (e.g., \"HTTP 404 Not Found\")\n            if (error.message) {\n                const match = error.message.match(/HTTP\\s+(\\d{3})/i);\n                if (match) {\n                    const status = parseInt(match[1], 10);\n                    if (status >= 100 && status < 600) {\n                        return status;\n                    }\n                }\n            }\n\n            // No HTTP status code available\n            return null;\n        } catch {\n            // If extraction fails, return null\n            return null;\n        }\n    }\n\n    /**\n   * Get browser info from user agent\n   */\n    getBrowserInfo() {\n        const ua = navigator.userAgent;\n\n        if (ua.includes('Chrome') && !ua.includes('Edge')) {\n            return 'Chrome';\n        }\n        if (ua.includes('Firefox')) {\n            return 'Firefox';\n        }\n        if (ua.includes('Safari') && !ua.includes('Chrome')) {\n            return 'Safari';\n        }\n        if (ua.includes('Edge') || ua.includes('Edg/')) {\n            return 'Edge';\n        }\n        if (ua.includes('MSIE') || ua.includes('Trident/')) {\n            return 'IE';\n        }\n\n        return 'Unknown';\n    }\n\n    /**\n     * Get session hash for GDPR-compliant session tracking\n     *\n     * Priority:\n     * 1. Use sessionHash from config if provided by server (Symfony bundle)\n     * 2. Generate from sessionStorage if available\n     * 3. Return null (errors will be tracked without session linkage)\n     *\n     * @returns {string|null} SHA-256 hash of session ID (64 hex chars)\n     */\n    getSessionHash() {\n        try {\n            // 1. Check if server provided session hash (Symfony bundle sets this)\n            if (this.config.sessionHash) {\n                return this.config.sessionHash;\n            }\n\n            // 2. Try to get/generate from sessionStorage\n            if (typeof sessionStorage !== 'undefined') {\n                let sessionId = sessionStorage.getItem('_app_logger_session_id');\n\n                if (!sessionId) {\n                    // Generate new session ID for this browser session\n                    sessionId = this.generateSessionId();\n                    sessionStorage.setItem('_app_logger_session_id', sessionId);\n                }\n\n                // Generate SHA-256 hash synchronously (simple implementation)\n                return this.sha256(sessionId);\n            }\n\n            // 3. No session tracking available\n            return null;\n        } catch {\n            // If session tracking fails, return null (errors still captured)\n            return null;\n        }\n    }\n\n    /**\n     * Generate a unique session ID for client-side session tracking\n     *\n     * @returns {string} Random session ID\n     */\n    generateSessionId() {\n        // Use crypto.randomUUID if available (modern browsers)\n        if (crypto && crypto.randomUUID) {\n            return crypto.randomUUID();\n        }\n\n        // Fallback: Generate random string\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = Math.random() * 16 | 0;\n            const v = c === 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n\n    /**\n     * Simple synchronous SHA-256 implementation\n     *\n     * This is a simplified hash function for client-side session hashing.\n     * While not cryptographically secure for production use, it's sufficient\n     * for generating consistent session hashes for tracking purposes.\n     *\n     * @param {string} str - String to hash\n     * @returns {string} 64-character hexadecimal hash\n     */\n    sha256(str) {\n        // Simple djb2-like hash (not real SHA-256, but consistent and sufficient)\n        let hash = 5381;\n        for (let i = 0; i < str.length; i++) {\n            hash = ((hash << 5) + hash) + str.charCodeAt(i);\n        }\n\n        // Convert to hex and pad to 64 characters for consistency with PHP hash('sha256')\n        // This is a simplified version - for production, consider using Web Crypto API\n        const hex = Math.abs(hash).toString(16);\n        return hex.padStart(64, '0');\n    }\n\n    /**\n   * Remove null/undefined values from object to reduce payload size\n   */\n    removeNullValues(obj) {\n        const cleaned = {};\n\n        for (const [key, value] of Object.entries(obj)) {\n            if (value !== null && value !== undefined) {\n                cleaned[key] = value;\n            }\n        }\n\n        return cleaned;\n    }\n\n    setUser(user) {\n        this.userContext = user;\n    }\n\n    setTags(tags) {\n        this.tags = { ...this.tags, ...tags };\n    }\n\n    setExtra(extra) {\n        this.extra = { ...this.extra, ...extra };\n    }\n\n    /**\n     * Flush pending errors using Beacon API\n     * Called on page unload to ensure critical errors are sent\n     */\n    flushBeaconErrors() {\n        try {\n            // Check if Beacon API is available\n            if (!navigator.sendBeacon) {\n                return;\n            }\n\n            // Get transport stats to check for pending errors\n            const stats = this.transport.getStats();\n\n            if (stats.storedErrors === 0 && stats.queueSize === 0) {\n                return; // Nothing to flush\n            }\n\n            // Delegate to transport's beacon flush method\n            this.transport.flushWithBeacon();\n        } catch {\n            // Never crash on flush - but this is our last chance to send errors\n            // So we silently fail\n        }\n    }\n}\n","/**\n * Breadcrumb collector for tracking user actions\n */\nexport class BreadcrumbCollector {\n    constructor(maxBreadcrumbs = 50) {\n        this.breadcrumbs = [];\n        this.maxBreadcrumbs = maxBreadcrumbs;\n    }\n\n    /**\n   * Install automatic breadcrumb tracking\n   */\n    install() {\n    // Track clicks\n        document.addEventListener('click', (event) => {\n            const target = event.target;\n            const tagName = target.tagName.toLowerCase();\n            let message = `Clicked ${tagName}`;\n\n            if (target.id) {\n                message += `#${target.id}`;\n            } else if (target.className) {\n                message += `.${target.className.split(' ')[0]}`;\n            }\n\n            this.add({\n                type: 'ui',\n                category: 'click',\n                message,\n                data: {\n                    tag: tagName,\n                    id: target.id,\n                    class: target.className,\n                },\n            });\n        }, true);\n\n        // Track navigation\n        const originalPushState = history.pushState;\n        const originalReplaceState = history.replaceState;\n\n        history.pushState = (...args) => {\n            this.add({\n                type: 'navigation',\n                category: 'navigation',\n                message: `Navigated to ${args[2]}`,\n                data: { to: args[2] },\n            });\n            return originalPushState.apply(history, args);\n        };\n\n        history.replaceState = (...args) => {\n            this.add({\n                type: 'navigation',\n                category: 'navigation',\n                message: `Replaced state ${args[2]}`,\n                data: { to: args[2] },\n            });\n            return originalReplaceState.apply(history, args);\n        };\n\n        // Track console messages\n        this.wrapConsole();\n\n        // Track fetch requests\n        this.wrapFetch();\n    }\n\n    /**\n   * Add a breadcrumb\n   */\n    add(breadcrumb) {\n        this.breadcrumbs.push({\n            timestamp: new Date().toISOString(),\n            level: breadcrumb.level || 'info',\n            ...breadcrumb,\n        });\n\n        // Limit breadcrumbs\n        if (this.breadcrumbs.length > this.maxBreadcrumbs) {\n            this.breadcrumbs.shift();\n        }\n    }\n\n    /**\n   * Get all breadcrumbs\n   */\n    get() {\n        return this.breadcrumbs;\n    }\n\n    /**\n   * Clear breadcrumbs\n   */\n    clear() {\n        this.breadcrumbs = [];\n    }\n\n    /**\n   * Wrap console methods for breadcrumb tracking\n   */\n    wrapConsole() {\n        const levels = ['log', 'info', 'warn', 'error', 'debug'];\n\n        levels.forEach(level => {\n            // eslint-disable-next-line no-console\n            const original = console[level];\n            // eslint-disable-next-line no-console\n            console[level] = (...args) => {\n                this.add({\n                    type: 'console',\n                    category: 'console',\n                    message: args.join(' '),\n                    level: level === 'log' ? 'info' : level,\n                    data: { arguments: args },\n                });\n                return original.apply(console, args);\n            };\n        });\n    }\n\n    /**\n   * Wrap fetch for HTTP request breadcrumbs\n   */\n    wrapFetch() {\n        const originalFetch = window.fetch;\n\n        window.fetch = async (...args) => {\n            const url = typeof args[0] === 'string' ? args[0] : args[0].url;\n            const method = args[1]?.method || 'GET';\n            const startTime = Date.now();\n\n            try {\n                const response = await originalFetch.apply(window, args);\n                const duration = Date.now() - startTime;\n\n                this.add({\n                    type: 'http',\n                    category: 'fetch',\n                    message: `${method} ${url}`,\n                    data: {\n                        url,\n                        method,\n                        status_code: response.status,\n                        duration,\n                    },\n                    level: response.ok ? 'info' : 'warning',\n                });\n\n                return response;\n            } catch (error) {\n                const duration = Date.now() - startTime;\n\n                this.add({\n                    type: 'http',\n                    category: 'fetch',\n                    message: `${method} ${url} failed`,\n                    data: {\n                        url,\n                        method,\n                        error: error.message,\n                        duration,\n                    },\n                    level: 'error',\n                });\n\n                throw error;\n            }\n        };\n    }\n}\n","/**\n * Circuit Breaker for JavaScript\n *\n * Implements the circuit breaker pattern to prevent repeated calls to a failing service.\n * Uses sessionStorage to persist state across page reloads within the same session.\n *\n * States:\n * - CLOSED: Normal operation, requests go through\n * - OPEN: Service is down, requests are blocked immediately\n * - HALF_OPEN: Testing if service has recovered\n */\nexport class CircuitBreaker {\n    static STATE_CLOSED = 'closed';\n    static STATE_OPEN = 'open';\n    static STATE_HALF_OPEN = 'half_open';\n\n    constructor(config = {}) {\n        this.failureThreshold = config.failureThreshold || 5;\n        this.timeout = config.timeout || 60000; // 60 seconds in milliseconds\n        this.storageKey = 'app_logger_circuit_breaker';\n\n        this.loadState();\n    }\n\n    /**\n     * Check if circuit is open (service down, reject requests)\n     */\n    isOpen() {\n        // Check if we should transition from OPEN to HALF_OPEN\n        if (this.state === CircuitBreaker.STATE_OPEN && this.shouldAttemptReset()) {\n            this.halfOpen();\n        }\n\n        return this.state === CircuitBreaker.STATE_OPEN;\n    }\n\n    /**\n     * Check if circuit is in half-open state\n     */\n    isHalfOpen() {\n        return this.state === CircuitBreaker.STATE_HALF_OPEN;\n    }\n\n    /**\n     * Record a successful request\n     */\n    recordSuccess() {\n        if (this.state === CircuitBreaker.STATE_HALF_OPEN) {\n            // Success in half-open = circuit closes (service recovered)\n            this.close();\n        } else if (this.state === CircuitBreaker.STATE_CLOSED) {\n            // Reset failure count on success\n            this.failureCount = 0;\n            this.saveState();\n        }\n    }\n\n    /**\n     * Record a failed request\n     */\n    recordFailure() {\n        if (this.state === CircuitBreaker.STATE_HALF_OPEN) {\n            // Failure in half-open = circuit opens again\n            this.open();\n        } else if (this.state === CircuitBreaker.STATE_CLOSED) {\n            this.failureCount++;\n\n            if (this.failureCount >= this.failureThreshold) {\n                this.open();\n            } else {\n                this.saveState();\n            }\n        }\n    }\n\n    /**\n     * Get current state for monitoring/debugging\n     */\n    getState() {\n        return {\n            state: this.state,\n            failureCount: this.failureCount,\n            openedAt: this.openedAt,\n        };\n    }\n\n    /**\n     * Manually reset circuit breaker\n     */\n    reset() {\n        this.close();\n    }\n\n    /**\n     * Transition to CLOSED state\n     */\n    close() {\n        this.state = CircuitBreaker.STATE_CLOSED;\n        this.failureCount = 0;\n        this.openedAt = null;\n        this.saveState();\n    }\n\n    /**\n     * Transition to OPEN state\n     */\n    open() {\n        this.state = CircuitBreaker.STATE_OPEN;\n        this.openedAt = Date.now();\n        this.saveState();\n    }\n\n    /**\n     * Transition to HALF_OPEN state\n     */\n    halfOpen() {\n        this.state = CircuitBreaker.STATE_HALF_OPEN;\n        this.saveState();\n    }\n\n    /**\n     * Check if enough time has passed to attempt reset\n     */\n    shouldAttemptReset() {\n        if (!this.openedAt) {\n            return false;\n        }\n\n        return (Date.now() - this.openedAt) >= this.timeout;\n    }\n\n    /**\n     * Load state from sessionStorage\n     */\n    loadState() {\n        try {\n            const stored = sessionStorage.getItem(this.storageKey);\n\n            if (stored) {\n                const state = JSON.parse(stored);\n                this.state = state.state || CircuitBreaker.STATE_CLOSED;\n                this.failureCount = state.failureCount || 0;\n                this.openedAt = state.openedAt || null;\n            } else {\n                this.state = CircuitBreaker.STATE_CLOSED;\n                this.failureCount = 0;\n                this.openedAt = null;\n            }\n        } catch {\n            // If storage fails, default to closed state\n            this.state = CircuitBreaker.STATE_CLOSED;\n            this.failureCount = 0;\n            this.openedAt = null;\n        }\n    }\n\n    /**\n     * Save state to sessionStorage\n     */\n    saveState() {\n        try {\n            const state = {\n                state: this.state,\n                failureCount: this.failureCount,\n                openedAt: this.openedAt,\n            };\n\n            sessionStorage.setItem(this.storageKey, JSON.stringify(state));\n        } catch {\n            // Storage failure should never crash the app\n            // Circuit breaker still works in-memory for this page\n        }\n    }\n}\n","/**\n * Local Storage Queue\n *\n * Buffers failed error submissions in localStorage for later retry.\n * Used when the API is unreachable or circuit breaker is open.\n *\n * Features:\n * - FIFO queue with size limits\n * - Automatic expiration of old errors\n * - Safe storage operations (never crash on quota exceeded)\n */\nexport class StorageQueue {\n    constructor(config = {}) {\n        this.storageKey = 'app_logger_queue';\n        this.maxSize = config.maxSize || 50; // Max errors to store\n        this.maxAge = config.maxAge || 86400000; // 24 hours in milliseconds\n    }\n\n    /**\n     * Add an error to the queue\n     */\n    enqueue(payload) {\n        try {\n            const queue = this.getQueue();\n\n            // Add timestamp for expiration\n            const item = {\n                payload,\n                timestamp: Date.now(),\n            };\n\n            queue.push(item);\n\n            // Limit queue size (FIFO - remove oldest)\n            if (queue.length > this.maxSize) {\n                queue.shift();\n            }\n\n            this.saveQueue(queue);\n        } catch (error) {\n            // Storage failures should never crash the app\n            // Common causes: quota exceeded, private browsing mode\n            console.warn('ApplicationLogger: Failed to queue error', error);\n        }\n    }\n\n    /**\n     * Get next error from queue (FIFO)\n     */\n    dequeue() {\n        try {\n            const queue = this.getQueue();\n\n            if (queue.length === 0) {\n                return null;\n            }\n\n            const item = queue.shift();\n            this.saveQueue(queue);\n\n            return item.payload;\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Get all queued errors\n     */\n    getAll() {\n        const queue = this.getQueue();\n        return queue.map(item => item.payload);\n    }\n\n    /**\n     * Get queue size\n     */\n    size() {\n        const queue = this.getQueue();\n        return queue.length;\n    }\n\n    /**\n     * Clear the queue\n     */\n    clear() {\n        try {\n            localStorage.removeItem(this.storageKey);\n        } catch {\n            // Ignore\n        }\n    }\n\n    /**\n     * Get queue from localStorage with expiration cleanup\n     */\n    getQueue() {\n        try {\n            const stored = localStorage.getItem(this.storageKey);\n\n            if (!stored) {\n                return [];\n            }\n\n            const queue = JSON.parse(stored);\n\n            if (!Array.isArray(queue)) {\n                return [];\n            }\n\n            // Remove expired items\n            const now = Date.now();\n            const filtered = queue.filter(item => {\n                return item.timestamp && (now - item.timestamp) < this.maxAge;\n            });\n\n            // If we removed expired items, save the cleaned queue\n            if (filtered.length !== queue.length) {\n                this.saveQueue(filtered);\n            }\n\n            return filtered;\n        } catch {\n            return [];\n        }\n    }\n\n    /**\n     * Save queue to localStorage\n     */\n    saveQueue(queue) {\n        try {\n            localStorage.setItem(this.storageKey, JSON.stringify(queue));\n        } catch (error) {\n            // Handle quota exceeded or other storage errors\n            if (error.name === 'QuotaExceededError') {\n                // Try to make space by removing oldest items\n                const halfSize = Math.floor(queue.length / 2);\n                const trimmed = queue.slice(-halfSize);\n\n                try {\n                    localStorage.setItem(this.storageKey, JSON.stringify(trimmed));\n                } catch {\n                    // If still failing, clear the queue\n                    this.clear();\n                }\n            }\n        }\n    }\n}\n","/**\n * Rate Limiter\n *\n * Prevents error storms by limiting the number of errors sent per minute.\n * Uses token bucket algorithm for smooth rate limiting.\n *\n * This is critical for resilience - prevents overwhelming the API\n * and consuming excessive bandwidth during error cascades.\n */\nexport class RateLimiter {\n    constructor(config = {}) {\n        this.maxTokens = config.maxTokens || 10; // Max errors per window\n        this.refillRate = config.refillRate || 1; // Tokens per second\n        this.tokens = this.maxTokens;\n        this.lastRefill = Date.now();\n    }\n\n    /**\n     * Check if request is allowed\n     */\n    isAllowed() {\n        this.refillTokens();\n        return this.tokens > 0;\n    }\n\n    /**\n     * Consume a token (record an error sent)\n     */\n    consume() {\n        if (!this.isAllowed()) {\n            return false;\n        }\n\n        this.tokens--;\n        return true;\n    }\n\n    /**\n     * Refill tokens based on time elapsed\n     */\n    refillTokens() {\n        const now = Date.now();\n        const elapsed = (now - this.lastRefill) / 1000; // Convert to seconds\n        const tokensToAdd = Math.floor(elapsed * this.refillRate);\n\n        if (tokensToAdd > 0) {\n            this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);\n            this.lastRefill = now;\n        }\n    }\n\n    /**\n     * Get current token count (for debugging)\n     */\n    getTokens() {\n        this.refillTokens();\n        return this.tokens;\n    }\n\n    /**\n     * Reset rate limiter\n     */\n    reset() {\n        this.tokens = this.maxTokens;\n        this.lastRefill = Date.now();\n    }\n}\n","import { CircuitBreaker } from './circuit-breaker.js';\nimport { StorageQueue } from './storage-queue.js';\nimport { RateLimiter } from './rate-limiter.js';\n\n/**\n * Transport layer for sending errors to the platform\n *\n * RESILIENCE FEATURES:\n * - 3-second timeout with AbortController\n * - Circuit breaker prevents repeated calls to failing service\n * - Smart retry with exponential backoff\n * - Local storage queue for offline errors\n * - Rate limiting to prevent error storms\n * - Deduplication to avoid duplicate errors\n */\nexport class Transport {\n    constructor(config) {\n        this.config = config;\n        this.apiKey = config.apiKey; // Store API key separately (not in DSN)\n        this.dsn = this.parseDsn(config.dsn);\n        this.queue = [];\n        this.sending = false;\n\n        // Initialize resilience components\n        this.circuitBreaker = new CircuitBreaker({\n            failureThreshold: 5,\n            timeout: 60000, // 60 seconds\n        });\n\n        this.storageQueue = new StorageQueue({\n            maxSize: 50,\n            maxAge: 86400000, // 24 hours\n        });\n\n        this.rateLimiter = new RateLimiter({\n            maxTokens: 10, // Max 10 errors per minute\n            refillRate: 0.167, // Refill ~10 tokens per minute\n        });\n\n        // Deduplication cache\n        this.recentErrors = new Map();\n        this.deduplicationWindow = 5000; // 5 seconds\n\n        // Try to flush stored errors on init\n        this.flushStoredErrors();\n    }\n\n    /**\n   * Parse DSN into components\n   *\n   * DSN format: {protocol}://{host}/{projectId}\n   * Example: https://localhost:8111/b6d8ed85-c0af-4c02-b6bb-bfb0f3609b37\n   *\n   * Note: API key is NOT in the DSN. It's passed separately via config.apiKey.\n   */\n    parseDsn(dsn) {\n        if (!dsn) {\n            throw new Error('DSN is required');\n        }\n\n        try {\n            const url = new URL(dsn);\n            const projectId = url.pathname.replace(/^\\//, ''); // Remove leading slash\n\n            if (!projectId) {\n                throw new Error('DSN must include a project ID in the path');\n            }\n\n            return {\n                protocol: url.protocol.replace(':', ''),\n                host: url.host,\n                projectId: projectId,\n                endpoint: `${url.protocol}//${url.host}/api/errors/ingest`,\n            };\n        } catch (error) {\n            throw new Error(`Invalid DSN format: ${error.message}. Expected: https://host/project-id`);\n        }\n    }\n\n    /**\n   * Send error payload to platform\n   */\n    async send(payload) {\n        try {\n            // Scrub sensitive data\n            const scrubbedPayload = this.scrubSensitiveData(payload);\n\n            // Check for duplicates\n            if (this.isDuplicate(scrubbedPayload)) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Duplicate error ignored');\n                }\n                return;\n            }\n\n            // Check rate limit\n            if (!this.rateLimiter.consume()) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Rate limit exceeded, error queued');\n                }\n                this.storageQueue.enqueue(scrubbedPayload);\n                return;\n            }\n\n            // Add to queue\n            this.queue.push(scrubbedPayload);\n\n            // Process queue\n            if (!this.sending) {\n                await this.processQueue();\n            }\n        } catch (error) {\n            // Never crash on send errors\n            console.error('ApplicationLogger: Send failed', error);\n        }\n    }\n\n    /**\n   * Process queued errors\n   */\n    async processQueue() {\n        if (this.queue.length === 0 || this.sending) {\n            return;\n        }\n\n        this.sending = true;\n\n        while (this.queue.length > 0) {\n            const payload = this.queue.shift();\n\n            try {\n                await this.sendToApi(payload);\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Error sent successfully');\n                }\n            } catch {\n                // Error already handled in sendToApi\n                // Don't re-queue here as sendToApi handles storage\n            }\n        }\n\n        this.sending = false;\n    }\n\n    /**\n   * Send payload to API with timeout and retry\n   */\n    async sendToApi(payload, attempt = 0) {\n        // Check circuit breaker\n        if (this.circuitBreaker.isOpen()) {\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Circuit breaker is open, error queued to storage');\n            }\n            this.storageQueue.enqueue(payload);\n            return;\n        }\n\n        // Create AbortController for timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 3000); // 3-second timeout\n\n        try {\n            const response = await fetch(this.dsn.endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey, // Use separate API key, not from DSN\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify(payload),\n                signal: controller.signal,\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n\n            // Success!\n            this.circuitBreaker.recordSuccess();\n\n            // Try to flush stored errors on success\n            this.flushStoredErrors();\n\n            return response.json();\n        } catch (error) {\n            clearTimeout(timeoutId);\n\n            // Handle timeout\n            if (error.name === 'AbortError') {\n                this.circuitBreaker.recordFailure();\n\n                if (this.config.debug) {\n                    console.error('ApplicationLogger: Request timeout');\n                }\n\n                this.storageQueue.enqueue(payload);\n                return;\n            }\n\n            // Handle network errors with retry\n            if (attempt < 2) {\n                // Exponential backoff: 1s, 2s\n                const delay = Math.pow(2, attempt) * 1000;\n                await this.delay(delay);\n\n                return this.sendToApi(payload, attempt + 1);\n            }\n\n            // Max retries reached\n            this.circuitBreaker.recordFailure();\n\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Max retries reached', error);\n            }\n\n            this.storageQueue.enqueue(payload);\n        }\n    }\n\n    /**\n   * Check if error is a duplicate\n   */\n    isDuplicate(payload) {\n        try {\n            // Create hash from error signature\n            const signature = JSON.stringify({\n                type: payload.exception?.type,\n                message: payload.exception?.value,\n                stack: payload.exception?.stacktrace?.frames?.slice(0, 3), // Top 3 frames\n            });\n\n            const hash = this.simpleHash(signature);\n\n            // Check if we've seen this recently\n            if (this.recentErrors.has(hash)) {\n                return true;\n            }\n\n            // Add to recent errors\n            this.recentErrors.set(hash, Date.now());\n\n            // Clean up old entries\n            const now = Date.now();\n            for (const [key, timestamp] of this.recentErrors) {\n                if (now - timestamp > this.deduplicationWindow) {\n                    this.recentErrors.delete(key);\n                }\n            }\n\n            return false;\n        } catch {\n            return false; // If deduplication fails, allow the error through\n        }\n    }\n\n    /**\n   * Simple hash function\n   */\n    simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            const char = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // Convert to 32bit integer\n        }\n        return hash.toString();\n    }\n\n    /**\n   * Flush errors from storage queue\n   */\n    async flushStoredErrors() {\n        try {\n            const queueSize = this.storageQueue.size();\n\n            if (queueSize === 0) {\n                return;\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Flushing ${queueSize} stored errors`);\n            }\n\n            // Limit flush to 5 errors at a time to avoid overwhelming\n            const limit = Math.min(queueSize, 5);\n\n            for (let i = 0; i < limit; i++) {\n                const payload = this.storageQueue.dequeue();\n\n                if (payload) {\n                    // Add to queue (but don't recurse infinitely)\n                    this.queue.push(payload);\n                }\n            }\n\n            // Process the queue\n            if (!this.sending && this.queue.length > 0) {\n                await this.processQueue();\n            }\n        } catch (error) {\n            // Never crash on flush\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Flush failed', error);\n            }\n        }\n    }\n\n    /**\n   * Delay helper for retry backoff\n   */\n    delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    /**\n   * Scrub sensitive data from payload\n   */\n    scrubSensitiveData(payload) {\n        const scrubFields = this.config.scrubFields || [];\n        const scrubPatterns = [\n            ...scrubFields,\n            'password',\n            'passwd',\n            'pwd',\n            'secret',\n            'api_key',\n            'apikey',\n            'token',\n            'auth',\n            'authorization',\n            'private_key',\n            'access_token',\n            'refresh_token',\n        ];\n\n        // Deep clone payload\n        const scrubbed = JSON.parse(JSON.stringify(payload));\n\n        // Recursively scrub object\n        const scrubObject = (obj) => {\n            if (!obj || typeof obj !== 'object') {\n                return obj;\n            }\n\n            for (const key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    // Check if key matches scrub pattern\n                    const shouldScrub = scrubPatterns.some(pattern =>\n                        key.toLowerCase().includes(pattern.toLowerCase()),\n                    );\n\n                    if (shouldScrub) {\n                        obj[key] = '[REDACTED]';\n                    } else if (typeof obj[key] === 'object') {\n                        scrubObject(obj[key]);\n                    }\n                }\n            }\n\n            return obj;\n        };\n\n        return scrubObject(scrubbed);\n    }\n\n    /**\n     * Send session event to API\n     */\n    async sendSessionEvent(sessionId, eventData) {\n        if (!sessionId || !eventData) {\n            return;\n        }\n\n        try {\n            const url = `${this.dsn.protocol}://${this.dsn.host}/api/v1/sessions/${sessionId}/events`;\n\n            const response = await fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey,\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify(eventData),\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}`);\n            }\n\n            return response.json();\n        } catch (error) {\n            // Silently fail - session tracking is non-critical\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Failed to send session event', error);\n            }\n        }\n    }\n\n    /**\n     * Send heatmap click data to API (batch)\n     */\n    async sendHeatmap(sessionId, clicks) {\n        if (!sessionId || !clicks || clicks.length === 0) {\n            return;\n        }\n\n        try {\n            const url = `${this.dsn.protocol}://${this.dsn.host}/api/v1/sessions/${sessionId}/heatmap`;\n\n            const response = await fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey,\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify({ clicks }),\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}`);\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Sent ${clicks.length} heatmap clicks`);\n            }\n\n            return response.json();\n        } catch (error) {\n            // Silently fail - heatmap tracking is non-critical\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Failed to send heatmap data', error);\n            }\n        }\n    }\n\n    /**\n   * Get stats for monitoring\n   */\n    getStats() {\n        return {\n            queueSize: this.queue.length,\n            storedErrors: this.storageQueue.size(),\n            circuitBreaker: this.circuitBreaker.getState(),\n            rateLimitTokens: this.rateLimiter.getTokens(),\n        };\n    }\n\n    /**\n   * Flush pending errors using Beacon API\n   * Called on page unload to ensure errors are sent even as page closes\n   */\n    flushWithBeacon() {\n        try {\n            // Get all stored errors (from offline queue)\n            const storedErrors = this.storageQueue.getAll();\n\n            // Also include current queue\n            const allErrors = [...this.queue, ...storedErrors];\n\n            if (allErrors.length === 0) {\n                return;\n            }\n\n            // Limit to 10 most recent errors to avoid payload size issues\n            const errorsToSend = allErrors.slice(-10);\n\n            // Beacon API has limitations with headers, so we include DSN in body\n            const beaconPayload = {\n                dsn: this.config.dsn,\n                errors: errorsToSend,\n            };\n\n            const blob = new Blob([JSON.stringify(beaconPayload)], {\n                type: 'application/json',\n            });\n\n            // Try to send via Beacon API\n            const sent = navigator.sendBeacon(this.dsn.endpoint, blob);\n\n            if (sent) {\n                // Successfully queued for sending\n                // Clear the storage queue and current queue\n                this.storageQueue.clear();\n                this.queue = [];\n\n                if (this.config.debug) {\n                    console.warn(`ApplicationLogger: Flushed ${errorsToSend.length} errors via Beacon API`);\n                }\n            }\n        } catch (error) {\n            // Beacon flush failed - errors remain in storage for next session\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Beacon flush failed', error);\n            }\n        }\n    }\n}\n","/**\n * Heatmap Tracker - Captures user clicks and interactions\n *\n * FEATURES:\n * - Click coordinate tracking with viewport dimensions\n * - Element selector generation (CSS selectors)\n * - Debouncing to prevent API flooding\n * - Batch sending for efficiency\n * - Privacy-respecting (no PII in selectors)\n */\nexport class HeatmapTracker {\n    constructor(transport, config) {\n        this.transport = transport;\n        this.config = config;\n        this.clickQueue = [];\n        this.batchSize = config.heatmapBatchSize || 10;\n        this.batchTimeout = config.heatmapBatchTimeout || 5000; // 5 seconds\n        this.batchTimer = null;\n        this.isInstalled = false;\n        this.sessionId = null;\n    }\n\n    /**\n     * Install click tracking listeners\n     */\n    install(sessionId) {\n        if (this.isInstalled) {\n            return;\n        }\n\n        this.sessionId = sessionId;\n\n        try {\n            // Track clicks\n            document.addEventListener('click', (event) => {\n                this.captureClick(event);\n            }, true);\n\n            // Flush on page unload\n            window.addEventListener('beforeunload', () => {\n                this.flush();\n            });\n\n            // Flush on visibility change (mobile)\n            document.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'hidden') {\n                    this.flush();\n                }\n            });\n\n            this.isInstalled = true;\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to install heatmap tracker', error);\n        }\n    }\n\n    /**\n     * Capture click event\n     */\n    captureClick(event) {\n        try {\n            const clickData = {\n                type: 'click',\n                url: window.location.href,\n                x: event.pageX,\n                y: event.pageY,\n                viewport_width: window.innerWidth,\n                viewport_height: window.innerHeight,\n                element_selector: this.generateSelector(event.target),\n                timestamp: new Date().toISOString(),\n                session_id: this.sessionId,\n            };\n\n            this.clickQueue.push(clickData);\n\n            // Send batch if queue is full\n            if (this.clickQueue.length >= this.batchSize) {\n                this.flush();\n            } else {\n                // Schedule batch send\n                this.scheduleBatchSend();\n            }\n        } catch (error) {\n            // Never crash on tracking\n            console.error('ApplicationLogger: Failed to capture click', error);\n        }\n    }\n\n    /**\n     * Generate CSS selector for element\n     *\n     * Creates a unique but privacy-respecting selector:\n     * - Uses tag name, ID, classes\n     * - Limits depth to 5 levels\n     * - Removes sensitive attributes (data-*, ng-*, etc.)\n     */\n    generateSelector(element) {\n        if (!element || element === document) {\n            return '';\n        }\n\n        try {\n            const parts = [];\n            let current = element;\n            let depth = 0;\n            const maxDepth = 5;\n\n            while (current && current !== document && depth < maxDepth) {\n                let selector = current.tagName.toLowerCase();\n\n                // Add ID if available (most specific)\n                if (current.id && !this.containsSensitiveData(current.id)) {\n                    selector += `#${CSS.escape(current.id)}`;\n                    parts.unshift(selector);\n                    break; // ID is unique, stop here\n                }\n\n                // Add classes (filter out utility/dynamic classes)\n                const classes = this.getCleanClasses(current);\n                if (classes.length > 0) {\n                    selector += `.${classes.join('.')}`;\n                }\n\n                // Add nth-child if needed for uniqueness\n                const siblings = current.parentElement ?\n                    Array.from(current.parentElement.children).filter(\n                        child => child.tagName === current.tagName,\n                    ) : [];\n\n                if (siblings.length > 1) {\n                    const index = siblings.indexOf(current) + 1;\n                    selector += `:nth-child(${index})`;\n                }\n\n                parts.unshift(selector);\n                current = current.parentElement;\n                depth++;\n            }\n\n            return parts.join(' > ');\n        } catch {\n            // If selector generation fails, return basic info\n            return element.tagName ? element.tagName.toLowerCase() : 'unknown';\n        }\n    }\n\n    /**\n     * Get cleaned class list (remove utility and sensitive classes)\n     */\n    getCleanClasses(element) {\n        if (!element.classList || element.classList.length === 0) {\n            return [];\n        }\n\n        const classes = Array.from(element.classList);\n        return classes\n            .filter(cls => {\n                // Filter out utility classes (Tailwind, Bootstrap, etc.)\n                if (cls.match(/^(active|hover|focus|disabled|hidden|show)$/)) {\n                    return false;\n                }\n\n                // Filter out generated classes\n                if (cls.match(/^(ng-|v-|data-|_)/)) {\n                    return false;\n                }\n\n                // Filter out classes that look like they contain sensitive data\n                if (this.containsSensitiveData(cls)) {\n                    return false;\n                }\n\n                return true;\n            })\n            .map(cls => CSS.escape(cls))\n            .slice(0, 3); // Limit to 3 classes\n    }\n\n    /**\n     * Check if string contains potentially sensitive data\n     */\n    containsSensitiveData(str) {\n        const sensitivePatterns = [\n            /user[-_]?id/i,\n            /email/i,\n            /token/i,\n            /session/i,\n            /auth/i,\n            /key/i,\n            /\\d{10,}/,  // Long numbers (could be IDs)\n        ];\n\n        return sensitivePatterns.some(pattern => pattern.test(str));\n    }\n\n    /**\n     * Schedule batch send with timeout\n     */\n    scheduleBatchSend() {\n        // Clear existing timer\n        if (this.batchTimer) {\n            clearTimeout(this.batchTimer);\n        }\n\n        // Schedule new timer\n        this.batchTimer = setTimeout(() => {\n            this.flush();\n        }, this.batchTimeout);\n    }\n\n    /**\n     * Flush click queue (send all pending clicks)\n     */\n    flush() {\n        if (this.clickQueue.length === 0) {\n            return;\n        }\n\n        try {\n            // Clear timer\n            if (this.batchTimer) {\n                clearTimeout(this.batchTimer);\n                this.batchTimer = null;\n            }\n\n            // Get clicks to send\n            const clicksToSend = [...this.clickQueue];\n            this.clickQueue = [];\n\n            // Send to heatmap API\n            this.sendHeatmapData(clicksToSend);\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to flush heatmap data', error);\n        }\n    }\n\n    /**\n     * Send heatmap data to API\n     */\n    async sendHeatmapData(clicks) {\n        if (!this.sessionId || clicks.length === 0) {\n            return;\n        }\n\n        try {\n            // Use transport's sendHeatmap method if available, otherwise use regular send\n            if (this.transport.sendHeatmap) {\n                await this.transport.sendHeatmap(this.sessionId, clicks);\n            } else {\n                // Fallback: send as regular events\n                const events = clicks.map(click => ({\n                    type: 'HEATMAP_CLICK',\n                    url: click.url,\n                    timestamp: click.timestamp,\n                    data: click,\n                }));\n\n                for (const event of events) {\n                    await this.transport.sendSessionEvent(this.sessionId, event);\n                }\n            }\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to send heatmap data', error);\n        }\n    }\n\n    /**\n     * Get current queue size for monitoring\n     */\n    getQueueSize() {\n        return this.clickQueue.length;\n    }\n}\n","/**\n * Application Logger JavaScript SDK\n *\n * Captures JavaScript errors and sends them to the Application Logger platform.\n * Integrated with Symfony bundle for seamless error tracking.\n *\n * @module ApplicationLogger\n */\n\nimport { Client } from './client.js';\nimport { BreadcrumbCollector } from './breadcrumbs.js';\nimport { Transport } from './transport.js';\nimport { HeatmapTracker } from './heatmap.js';\n\n/**\n * Main ApplicationLogger class\n */\nclass ApplicationLogger {\n    /**\n   * @param {Object} config Configuration options\n   * @param {string} config.dsn Data Source Name (project endpoint URL)\n   * @param {string} config.apiKey API Key for authentication\n   * @param {string} [config.sessionId] Session ID for tracking (provided by server)\n   * @param {string} [config.release] Application version/release\n   * @param {string} [config.environment] Environment (production, staging, etc.)\n   * @param {boolean} [config.debug=false] Enable debug logging\n   * @param {boolean} [config.enableHeatmap=true] Enable heatmap click tracking\n   * @param {number} [config.heatmapBatchSize=10] Heatmap batch size\n   * @param {number} [config.heatmapBatchTimeout=5000] Heatmap batch timeout (ms)\n   * @param {string[]} [config.scrubFields] Additional fields to scrub\n   */\n    constructor(config) {\n        // Validate required configuration\n        if (!config || !config.dsn) {\n            throw new Error('ApplicationLogger: DSN is required. Expected format: https://host/project-id');\n        }\n\n        if (!config.apiKey) {\n            throw new Error('ApplicationLogger: API Key is required for authentication');\n        }\n\n        this.config = {\n            debug: false,\n            scrubFields: ['password', 'token', 'api_key', 'secret'],\n            enableHeatmap: true,\n            heatmapBatchSize: 10,\n            heatmapBatchTimeout: 5000,\n            ...config,\n        };\n\n        this.transport = new Transport(this.config);\n        this.breadcrumbs = new BreadcrumbCollector();\n        this.client = new Client(this.config, this.transport, this.breadcrumbs);\n        this.heatmap = new HeatmapTracker(this.transport, this.config);\n        this.initialized = false;\n    }\n\n    /**\n   * Initialize the SDK and start capturing errors\n   */\n    init() {\n        if (this.initialized) {\n            console.warn('ApplicationLogger already initialized');\n            return;\n        }\n\n        this.client.install();\n\n        // Install heatmap tracking if enabled and session ID is provided\n        if (this.config.enableHeatmap && this.config.sessionId) {\n            this.heatmap.install(this.config.sessionId);\n\n            if (this.config.debug) {\n                // eslint-disable-next-line no-console\n                console.log('ApplicationLogger: Heatmap tracking enabled');\n            }\n        }\n\n        this.initialized = true;\n\n        if (this.config.debug) {\n            // eslint-disable-next-line no-console\n            console.log('ApplicationLogger initialized', this.config);\n        }\n    }\n\n    /**\n   * Manually capture an exception\n   *\n   * @param {Error} error The error to capture\n   * @param {Object} [options] Additional options\n   * @param {Object} [options.tags] Key-value tags\n   * @param {Object} [options.extra] Additional context data\n   */\n    captureException(error, options = {}) {\n        this.client.captureException(error, options);\n    }\n\n    /**\n   * Manually capture a message\n   *\n   * @param {string} message The message to capture\n   * @param {string} [level='info'] Log level\n   * @param {Object} [options] Additional options\n   */\n    captureMessage(message, level = 'info', options = {}) {\n        this.client.captureMessage(message, level, options);\n    }\n\n    /**\n   * Add a breadcrumb\n   *\n   * @param {Object} breadcrumb Breadcrumb data\n   * @param {string} breadcrumb.type Breadcrumb type (navigation, http, user, etc.)\n   * @param {string} breadcrumb.category Category\n   * @param {string} breadcrumb.message Message\n   * @param {Object} [breadcrumb.data] Additional data\n   * @param {string} [breadcrumb.level='info'] Log level\n   */\n    addBreadcrumb(breadcrumb) {\n        this.breadcrumbs.add(breadcrumb);\n    }\n\n    /**\n   * Set user context\n   *\n   * @param {Object} user User data\n   * @param {string} [user.id] User ID\n   * @param {string} [user.email] User email\n   * @param {string} [user.username] Username\n   */\n    setUser(user) {\n        this.client.setUser(user);\n    }\n\n    /**\n   * Set tags\n   *\n   * @param {Object} tags Key-value tags\n   */\n    setTags(tags) {\n        this.client.setTags(tags);\n    }\n\n    /**\n   * Set extra context\n   *\n   * @param {Object} extra Key-value extra data\n   */\n    setExtra(extra) {\n        this.client.setExtra(extra);\n    }\n}\n\n// Export for ES modules\nexport default ApplicationLogger;\n\n// Export for UMD (window.ApplicationLogger)\nif (typeof window !== 'undefined') {\n    window.ApplicationLogger = ApplicationLogger;\n}\n"],"names":["Client","constructor","config","transport","breadcrumbs","this","userContext","tags","extra","pendingBeaconErrors","install","window","addEventListener","event","captureException","error","Error","message","filename","lineno","colno","console","reason","type","flushBeaconErrors","document","visibilityState","options","payload","buildPayload","send","captureMessage","level","stackTrace","parseStackTrace","firstFrame","length","name","file","line","stack_trace","environment","release","url","location","href","http_method","detectHttpMethod","http_status_code","extractHttpStatusCode","session_hash","getSessionHash","timestamp","Date","toISOString","runtime","getBrowserInfo","user_agent","navigator","userAgent","get","context","removeNullValues","stack","function","lines","split","frames","frame","parseStackLine","trim","push","match","parseInt","column","navigation","performance","getEntriesByType","status","httpStatusCode","ua","includes","sessionHash","sessionStorage","sessionId","getItem","generateSessionId","setItem","sha256","crypto","randomUUID","replace","c","r","Math","random","toString","str","hash","i","charCodeAt","abs","padStart","obj","cleaned","key","value","Object","entries","setUser","user","setTags","setExtra","sendBeacon","stats","getStats","storedErrors","queueSize","flushWithBeacon","BreadcrumbCollector","maxBreadcrumbs","target","tagName","toLowerCase","id","className","add","category","data","tag","class","originalPushState","history","pushState","originalReplaceState","replaceState","args","to","apply","wrapConsole","wrapFetch","breadcrumb","shift","clear","forEach","original","join","arguments","originalFetch","fetch","async","method","startTime","now","response","duration","status_code","ok","CircuitBreaker","static","failureThreshold","timeout","storageKey","loadState","isOpen","state","STATE_OPEN","shouldAttemptReset","halfOpen","isHalfOpen","STATE_HALF_OPEN","recordSuccess","close","STATE_CLOSED","failureCount","saveState","recordFailure","open","getState","openedAt","reset","stored","JSON","parse","stringify","StorageQueue","maxSize","maxAge","enqueue","queue","getQueue","item","saveQueue","warn","dequeue","getAll","map","size","localStorage","removeItem","Array","isArray","filtered","filter","halfSize","floor","trimmed","slice","RateLimiter","maxTokens","refillRate","tokens","lastRefill","isAllowed","refillTokens","consume","elapsed","tokensToAdd","min","getTokens","Transport","apiKey","dsn","parseDsn","sending","circuitBreaker","storageQueue","rateLimiter","recentErrors","Map","deduplicationWindow","flushStoredErrors","URL","projectId","pathname","protocol","host","endpoint","scrubbedPayload","scrubSensitiveData","isDuplicate","debug","processQueue","sendToApi","attempt","controller","AbortController","timeoutId","setTimeout","abort","headers","body","signal","clearTimeout","statusText","json","delay","pow","signature","exception","stacktrace","simpleHash","has","set","delete","limit","ms","Promise","resolve","scrubPatterns","scrubFields","scrubbed","scrubObject","prototype","hasOwnProperty","call","some","pattern","sendSessionEvent","eventData","sendHeatmap","clicks","rateLimitTokens","allErrors","errorsToSend","beaconPayload","errors","blob","Blob","HeatmapTracker","clickQueue","batchSize","heatmapBatchSize","batchTimeout","heatmapBatchTimeout","batchTimer","isInstalled","captureClick","flush","clickData","x","pageX","y","pageY","viewport_width","innerWidth","viewport_height","innerHeight","element_selector","generateSelector","session_id","scheduleBatchSend","element","parts","current","depth","maxDepth","selector","containsSensitiveData","CSS","escape","unshift","classes","getCleanClasses","siblings","parentElement","from","children","child","indexOf","classList","cls","test","clicksToSend","sendHeatmapData","events","click","getQueueSize","ApplicationLogger","enableHeatmap","client","heatmap","initialized","init","log","addBreadcrumb"],"mappings":"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"}