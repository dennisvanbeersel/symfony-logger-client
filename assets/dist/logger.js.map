{"version":3,"file":"logger.js","sources":["../src/client.js","../src/breadcrumbs.js","../src/circuit-breaker.js","../src/storage-queue.js","../src/rate-limiter.js","../src/transport.js","../src/heatmap.js","../src/index.js"],"sourcesContent":["/**\n * Client for capturing errors and sending to platform\n *\n * RESILIENCE FEATURES:\n * - Beacon API for page unload events (ensures critical errors are sent)\n * - All error handling wrapped in try-catch\n * - Never crashes on logging errors\n */\nexport class Client {\n    constructor(config, transport, breadcrumbs) {\n        this.config = config;\n        this.transport = transport;\n        this.breadcrumbs = breadcrumbs;\n        this.userContext = null;\n        this.tags = {};\n        this.extra = {};\n        this.pendingBeaconErrors = [];\n    }\n\n    /**\n   * Install global error handlers\n   */\n    install() {\n        try {\n            // Handle uncaught errors\n            window.addEventListener('error', (event) => {\n                try {\n                    this.captureException(event.error || new Error(event.message), {\n                        extra: {\n                            filename: event.filename,\n                            lineno: event.lineno,\n                            colno: event.colno,\n                        },\n                    });\n                } catch (error) {\n                    // Never crash on error handling\n                    console.error('ApplicationLogger: Failed to capture error', error);\n                }\n            });\n\n            // Handle unhandled promise rejections\n            window.addEventListener('unhandledrejection', (event) => {\n                try {\n                    this.captureException(event.reason, {\n                        extra: {\n                            type: 'unhandledrejection',\n                        },\n                    });\n                } catch (error) {\n                    console.error('ApplicationLogger: Failed to capture rejection', error);\n                }\n            });\n\n            // Use Beacon API for page unload to ensure critical errors are sent\n            window.addEventListener('beforeunload', () => {\n                this.flushBeaconErrors();\n            });\n\n            // Also try on visibilitychange (for mobile)\n            document.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'hidden') {\n                    this.flushBeaconErrors();\n                }\n            });\n\n            // Track breadcrumbs\n            this.breadcrumbs.install();\n        } catch (error) {\n            // Installation failure should never crash the app\n            console.error('ApplicationLogger: Failed to install', error);\n        }\n    }\n\n    /**\n   * Capture exception\n   */\n    captureException(error, options = {}) {\n        const payload = this.buildPayload(error, 'error', options);\n        this.transport.send(payload);\n    }\n\n    /**\n   * Capture message\n   */\n    captureMessage(message, level = 'info', options = {}) {\n        const payload = this.buildPayload(new Error(message), level, options);\n        this.transport.send(payload);\n    }\n\n    /**\n   * Build error payload matching API expectations\n   *\n   * API expects flat structure with snake_case field names:\n   * {type, message, file, line, stack_trace, level, environment, ...}\n   */\n    buildPayload(error, level, options = {}) {\n        try {\n            const stackTrace = this.parseStackTrace(error);\n            const firstFrame = stackTrace.length > 0 ? stackTrace[0] : null;\n\n            // Build payload matching exact API format\n            const payload = {\n                // Required fields (flat structure, not nested)\n                type: error.name || 'Error',\n                message: error.message || 'Unknown error',\n                file: firstFrame?.file || options.extra?.filename || 'unknown',\n                line: firstFrame?.line || options.extra?.lineno || 0,\n                stack_trace: stackTrace,\n\n                // Optional fields (snake_case to match API)\n                level: level || 'error',\n                source: 'frontend',\n                environment: this.config.environment || 'production',\n                release: this.config.release || null,\n                url: window.location.href,\n                http_method: this.detectHttpMethod(),\n                http_status_code: this.extractHttpStatusCode(error, options),\n                session_hash: this.getSessionHash(),\n                timestamp: new Date().toISOString(),\n                runtime: `JavaScript ${this.getBrowserInfo()}`,\n                user_agent: navigator.userAgent,\n                breadcrumbs: this.breadcrumbs.get(),\n                context: { ...this.extra, ...options.extra },\n                tags: { ...this.tags, ...options.tags },\n            };\n\n            // Clean up null values to reduce payload size\n            return this.removeNullValues(payload);\n        } catch (error) {\n            // If payload building completely fails, return minimal payload\n            console.error('ApplicationLogger: Failed to build payload', error);\n            return {\n                type: 'Error',\n                message: 'Failed to build error payload',\n                file: 'unknown',\n                line: 0,\n                stack_trace: [],\n                level: 'error',\n            };\n        }\n    }\n\n    /**\n   * Parse error stack trace with cross-browser support\n   *\n   * Returns array of frames matching API format:\n   * [{file, line, function, class, column}, ...]\n   */\n    parseStackTrace(error) {\n        if (!error.stack) {\n            return [{\n                file: 'unknown',\n                line: 0,\n                function: 'unknown',\n            }];\n        }\n\n        try {\n            const lines = error.stack.split('\\n');\n            const frames = [];\n\n            for (const line of lines) {\n                const frame = this.parseStackLine(line.trim());\n                if (frame) {\n                    frames.push(frame);\n                }\n            }\n\n            return frames.length > 0 ? frames : [{\n                file: 'unknown',\n                line: 0,\n                function: 'unknown',\n            }];\n        } catch {\n            return [{\n                file: 'unknown',\n                line: 0,\n                function: 'unknown',\n            }];\n        }\n    }\n\n    /**\n   * Parse a single stack trace line (cross-browser)\n   *\n   * Handles formats from Chrome, Firefox, Safari, Edge\n   */\n    parseStackLine(line) {\n        if (!line) {\n            return null;\n        }\n\n        // Chrome/V8: \"at functionName (file.js:line:col)\"\n        let match = line.match(/at\\s+(.+?)\\s+\\((.+?):(\\d+):(\\d+)\\)/);\n        if (match) {\n            return {\n                function: match[1].trim(),\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Chrome/V8 anonymous: \"at file.js:line:col\"\n        match = line.match(/at\\s+(.+?):(\\d+):(\\d+)/);\n        if (match) {\n            return {\n                function: 'anonymous',\n                file: match[1],\n                line: parseInt(match[2], 10),\n                column: parseInt(match[3], 10),\n            };\n        }\n\n        // Firefox: \"functionName@file.js:line:col\"\n        match = line.match(/(.+?)@(.+?):(\\d+):(\\d+)/);\n        if (match) {\n            return {\n                function: match[1] || 'anonymous',\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Safari/Firefox (no column): \"functionName@file.js:line\"\n        match = line.match(/(?:(.+)@)?(.+?):(\\d+)$/);\n        if (match) {\n            return {\n                function: match[1] || 'anonymous',\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: null,\n            };\n        }\n\n        // Edge legacy: \"at functionName (file.js:line:col)\"\n        match = line.match(/at\\s+(.+?)\\s+\\[(.+?):(\\d+):(\\d+)\\]/);\n        if (match) {\n            return {\n                function: match[1].trim(),\n                file: match[2],\n                line: parseInt(match[3], 10),\n                column: parseInt(match[4], 10),\n            };\n        }\n\n        // Could not parse this line\n        return null;\n    }\n\n    /**\n   * Detect HTTP method for current page load\n   */\n    detectHttpMethod() {\n        try {\n            // Try to detect from performance API\n            const navigation = performance.getEntriesByType('navigation')[0];\n            if (navigation && navigation.type) {\n                // Navigation types: navigate, reload, back_forward, prerender\n                return 'GET'; // Page loads are always GET\n            }\n        } catch {\n            // Performance API not available\n        }\n\n        // Default to GET (most common for page loads)\n        return 'GET';\n    }\n\n    /**\n     * Extract HTTP status code from error context.\n     *\n     * Attempts to extract status code from:\n     * 1. Error object's status property (fetch Response)\n     * 2. Options extra data (manually passed)\n     * 3. Error message parsing (e.g., \"HTTP 404 Not Found\")\n     *\n     * @param {Error} error - The error object\n     * @param {Object} options - Additional options passed to captureException\n     * @returns {number|null} HTTP status code or null if not available\n     */\n    extractHttpStatusCode(error, options = {}) {\n        try {\n            // Check if error has status property (fetch Response errors)\n            if (error.status && typeof error.status === 'number') {\n                return error.status;\n            }\n\n            // Check if status was passed in options\n            if (options.httpStatusCode && typeof options.httpStatusCode === 'number') {\n                return options.httpStatusCode;\n            }\n\n            // Check extra context for status code\n            if (options.extra?.http_status_code && typeof options.extra.http_status_code === 'number') {\n                return options.extra.http_status_code;\n            }\n\n            if (options.extra?.httpStatusCode && typeof options.extra.httpStatusCode === 'number') {\n                return options.extra.httpStatusCode;\n            }\n\n            // Try to parse status code from error message (e.g., \"HTTP 404 Not Found\")\n            if (error.message) {\n                const match = error.message.match(/HTTP\\s+(\\d{3})/i);\n                if (match) {\n                    const status = parseInt(match[1], 10);\n                    if (status >= 100 && status < 600) {\n                        return status;\n                    }\n                }\n            }\n\n            // No HTTP status code available\n            return null;\n        } catch {\n            // If extraction fails, return null\n            return null;\n        }\n    }\n\n    /**\n   * Get browser info from user agent\n   */\n    getBrowserInfo() {\n        const ua = navigator.userAgent;\n\n        if (ua.includes('Chrome') && !ua.includes('Edge')) {\n            return 'Chrome';\n        }\n        if (ua.includes('Firefox')) {\n            return 'Firefox';\n        }\n        if (ua.includes('Safari') && !ua.includes('Chrome')) {\n            return 'Safari';\n        }\n        if (ua.includes('Edge') || ua.includes('Edg/')) {\n            return 'Edge';\n        }\n        if (ua.includes('MSIE') || ua.includes('Trident/')) {\n            return 'IE';\n        }\n\n        return 'Unknown';\n    }\n\n    /**\n     * Get session hash for GDPR-compliant session tracking\n     *\n     * Priority:\n     * 1. Use sessionHash from config if provided by server (Symfony bundle)\n     * 2. Generate from sessionStorage if available\n     * 3. Return null (errors will be tracked without session linkage)\n     *\n     * @returns {string|null} SHA-256 hash of session ID (64 hex chars)\n     */\n    getSessionHash() {\n        try {\n            // 1. Check if server provided session hash (Symfony bundle sets this)\n            if (this.config.sessionHash) {\n                return this.config.sessionHash;\n            }\n\n            // 2. Try to get/generate from sessionStorage\n            if (typeof sessionStorage !== 'undefined') {\n                let sessionId = sessionStorage.getItem('_app_logger_session_id');\n\n                if (!sessionId) {\n                    // Generate new session ID for this browser session\n                    sessionId = this.generateSessionId();\n                    sessionStorage.setItem('_app_logger_session_id', sessionId);\n                }\n\n                // Generate SHA-256 hash synchronously (simple implementation)\n                return this.sha256(sessionId);\n            }\n\n            // 3. No session tracking available\n            return null;\n        } catch {\n            // If session tracking fails, return null (errors still captured)\n            return null;\n        }\n    }\n\n    /**\n     * Generate a unique session ID for client-side session tracking\n     *\n     * @returns {string} Random session ID\n     */\n    generateSessionId() {\n        // Use crypto.randomUUID if available (modern browsers)\n        if (crypto && crypto.randomUUID) {\n            return crypto.randomUUID();\n        }\n\n        // Fallback: Generate random string\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = Math.random() * 16 | 0;\n            const v = c === 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n\n    /**\n     * Simple synchronous SHA-256 implementation\n     *\n     * This is a simplified hash function for client-side session hashing.\n     * While not cryptographically secure for production use, it's sufficient\n     * for generating consistent session hashes for tracking purposes.\n     *\n     * @param {string} str - String to hash\n     * @returns {string} 64-character hexadecimal hash\n     */\n    sha256(str) {\n        // Simple djb2-like hash (not real SHA-256, but consistent and sufficient)\n        let hash = 5381;\n        for (let i = 0; i < str.length; i++) {\n            hash = ((hash << 5) + hash) + str.charCodeAt(i);\n        }\n\n        // Convert to hex and pad to 64 characters for consistency with PHP hash('sha256')\n        // This is a simplified version - for production, consider using Web Crypto API\n        const hex = Math.abs(hash).toString(16);\n        return hex.padStart(64, '0');\n    }\n\n    /**\n   * Remove null/undefined values from object to reduce payload size\n   */\n    removeNullValues(obj) {\n        const cleaned = {};\n\n        for (const [key, value] of Object.entries(obj)) {\n            if (value !== null && value !== undefined) {\n                cleaned[key] = value;\n            }\n        }\n\n        return cleaned;\n    }\n\n    setUser(user) {\n        this.userContext = user;\n    }\n\n    setTags(tags) {\n        this.tags = { ...this.tags, ...tags };\n    }\n\n    setExtra(extra) {\n        this.extra = { ...this.extra, ...extra };\n    }\n\n    /**\n     * Flush pending errors using Beacon API\n     * Called on page unload to ensure critical errors are sent\n     */\n    flushBeaconErrors() {\n        try {\n            // Check if Beacon API is available\n            if (!navigator.sendBeacon) {\n                return;\n            }\n\n            // Get transport stats to check for pending errors\n            const stats = this.transport.getStats();\n\n            if (stats.storedErrors === 0 && stats.queueSize === 0) {\n                return; // Nothing to flush\n            }\n\n            // Delegate to transport's beacon flush method\n            this.transport.flushWithBeacon();\n        } catch {\n            // Never crash on flush - but this is our last chance to send errors\n            // So we silently fail\n        }\n    }\n}\n","/**\n * Breadcrumb collector for tracking user actions\n */\nexport class BreadcrumbCollector {\n    constructor(maxBreadcrumbs = 50) {\n        this.breadcrumbs = [];\n        this.maxBreadcrumbs = maxBreadcrumbs;\n    }\n\n    /**\n   * Install automatic breadcrumb tracking\n   */\n    install() {\n    // Track clicks\n        document.addEventListener('click', (event) => {\n            const target = event.target;\n            const tagName = target.tagName.toLowerCase();\n            let message = `Clicked ${tagName}`;\n\n            // Get className as string (handle SVG elements)\n            const getClassName = (element) => {\n                if (!element.className) return '';\n                // For SVG elements, className is an SVGAnimatedString\n                if (typeof element.className === 'object' && element.className.baseVal !== undefined) {\n                    return element.className.baseVal;\n                }\n                // For HTML elements, className is a string\n                return element.className;\n            };\n\n            const className = getClassName(target);\n\n            if (target.id) {\n                message += `#${target.id}`;\n            } else if (className) {\n                const firstClass = className.split(' ')[0];\n                if (firstClass) {\n                    message += `.${firstClass}`;\n                }\n            }\n\n            this.add({\n                type: 'ui',\n                category: 'click',\n                message,\n                data: {\n                    tag: tagName,\n                    id: target.id,\n                    class: className,\n                },\n            });\n        }, true);\n\n        // Track navigation\n        const originalPushState = history.pushState;\n        const originalReplaceState = history.replaceState;\n\n        history.pushState = (...args) => {\n            this.add({\n                type: 'navigation',\n                category: 'navigation',\n                message: `Navigated to ${args[2]}`,\n                data: { to: args[2] },\n            });\n            return originalPushState.apply(history, args);\n        };\n\n        history.replaceState = (...args) => {\n            this.add({\n                type: 'navigation',\n                category: 'navigation',\n                message: `Replaced state ${args[2]}`,\n                data: { to: args[2] },\n            });\n            return originalReplaceState.apply(history, args);\n        };\n\n        // Track console messages\n        this.wrapConsole();\n\n        // Track fetch requests\n        this.wrapFetch();\n    }\n\n    /**\n   * Add a breadcrumb\n   */\n    add(breadcrumb) {\n        this.breadcrumbs.push({\n            timestamp: new Date().toISOString(),\n            level: breadcrumb.level || 'info',\n            ...breadcrumb,\n        });\n\n        // Limit breadcrumbs\n        if (this.breadcrumbs.length > this.maxBreadcrumbs) {\n            this.breadcrumbs.shift();\n        }\n    }\n\n    /**\n   * Get all breadcrumbs\n   */\n    get() {\n        return this.breadcrumbs;\n    }\n\n    /**\n   * Clear breadcrumbs\n   */\n    clear() {\n        this.breadcrumbs = [];\n    }\n\n    /**\n   * Wrap console methods for breadcrumb tracking\n   */\n    wrapConsole() {\n        const levels = ['log', 'info', 'warn', 'error', 'debug'];\n\n        levels.forEach(level => {\n            // eslint-disable-next-line no-console\n            const original = console[level];\n            // eslint-disable-next-line no-console\n            console[level] = (...args) => {\n                this.add({\n                    type: 'console',\n                    category: 'console',\n                    message: args.join(' '),\n                    level: level === 'log' ? 'info' : level,\n                    data: { arguments: args },\n                });\n                return original.apply(console, args);\n            };\n        });\n    }\n\n    /**\n   * Wrap fetch for HTTP request breadcrumbs\n   */\n    wrapFetch() {\n        const originalFetch = window.fetch;\n\n        window.fetch = async (...args) => {\n            const url = typeof args[0] === 'string' ? args[0] : args[0].url;\n            const method = args[1]?.method || 'GET';\n            const startTime = Date.now();\n\n            try {\n                const response = await originalFetch.apply(window, args);\n                const duration = Date.now() - startTime;\n\n                this.add({\n                    type: 'http',\n                    category: 'fetch',\n                    message: `${method} ${url}`,\n                    data: {\n                        url,\n                        method,\n                        status_code: response.status,\n                        duration,\n                    },\n                    level: response.ok ? 'info' : 'warning',\n                });\n\n                return response;\n            } catch (error) {\n                const duration = Date.now() - startTime;\n\n                this.add({\n                    type: 'http',\n                    category: 'fetch',\n                    message: `${method} ${url} failed`,\n                    data: {\n                        url,\n                        method,\n                        error: error.message,\n                        duration,\n                    },\n                    level: 'error',\n                });\n\n                throw error;\n            }\n        };\n    }\n}\n","/**\n * Circuit Breaker for JavaScript\n *\n * Implements the circuit breaker pattern to prevent repeated calls to a failing service.\n * Uses sessionStorage to persist state across page reloads within the same session.\n *\n * States:\n * - CLOSED: Normal operation, requests go through\n * - OPEN: Service is down, requests are blocked immediately\n * - HALF_OPEN: Testing if service has recovered\n */\nexport class CircuitBreaker {\n    static STATE_CLOSED = 'closed';\n    static STATE_OPEN = 'open';\n    static STATE_HALF_OPEN = 'half_open';\n\n    constructor(config = {}) {\n        this.failureThreshold = config.failureThreshold || 5;\n        this.timeout = config.timeout || 60000; // 60 seconds in milliseconds\n        this.storageKey = 'app_logger_circuit_breaker';\n\n        this.loadState();\n    }\n\n    /**\n     * Check if circuit is open (service down, reject requests)\n     */\n    isOpen() {\n        // Check if we should transition from OPEN to HALF_OPEN\n        if (this.state === CircuitBreaker.STATE_OPEN && this.shouldAttemptReset()) {\n            this.halfOpen();\n        }\n\n        return this.state === CircuitBreaker.STATE_OPEN;\n    }\n\n    /**\n     * Check if circuit is in half-open state\n     */\n    isHalfOpen() {\n        return this.state === CircuitBreaker.STATE_HALF_OPEN;\n    }\n\n    /**\n     * Record a successful request\n     */\n    recordSuccess() {\n        if (this.state === CircuitBreaker.STATE_HALF_OPEN) {\n            // Success in half-open = circuit closes (service recovered)\n            this.close();\n        } else if (this.state === CircuitBreaker.STATE_CLOSED) {\n            // Reset failure count on success\n            this.failureCount = 0;\n            this.saveState();\n        }\n    }\n\n    /**\n     * Record a failed request\n     */\n    recordFailure() {\n        if (this.state === CircuitBreaker.STATE_HALF_OPEN) {\n            // Failure in half-open = circuit opens again\n            this.open();\n        } else if (this.state === CircuitBreaker.STATE_CLOSED) {\n            this.failureCount++;\n\n            if (this.failureCount >= this.failureThreshold) {\n                this.open();\n            } else {\n                this.saveState();\n            }\n        }\n    }\n\n    /**\n     * Get current state for monitoring/debugging\n     */\n    getState() {\n        return {\n            state: this.state,\n            failureCount: this.failureCount,\n            openedAt: this.openedAt,\n        };\n    }\n\n    /**\n     * Manually reset circuit breaker\n     */\n    reset() {\n        this.close();\n    }\n\n    /**\n     * Transition to CLOSED state\n     */\n    close() {\n        this.state = CircuitBreaker.STATE_CLOSED;\n        this.failureCount = 0;\n        this.openedAt = null;\n        this.saveState();\n    }\n\n    /**\n     * Transition to OPEN state\n     */\n    open() {\n        this.state = CircuitBreaker.STATE_OPEN;\n        this.openedAt = Date.now();\n        this.saveState();\n    }\n\n    /**\n     * Transition to HALF_OPEN state\n     */\n    halfOpen() {\n        this.state = CircuitBreaker.STATE_HALF_OPEN;\n        this.saveState();\n    }\n\n    /**\n     * Check if enough time has passed to attempt reset\n     */\n    shouldAttemptReset() {\n        if (!this.openedAt) {\n            return false;\n        }\n\n        return (Date.now() - this.openedAt) >= this.timeout;\n    }\n\n    /**\n     * Load state from sessionStorage\n     */\n    loadState() {\n        try {\n            const stored = sessionStorage.getItem(this.storageKey);\n\n            if (stored) {\n                const state = JSON.parse(stored);\n                this.state = state.state || CircuitBreaker.STATE_CLOSED;\n                this.failureCount = state.failureCount || 0;\n                this.openedAt = state.openedAt || null;\n            } else {\n                this.state = CircuitBreaker.STATE_CLOSED;\n                this.failureCount = 0;\n                this.openedAt = null;\n            }\n        } catch {\n            // If storage fails, default to closed state\n            this.state = CircuitBreaker.STATE_CLOSED;\n            this.failureCount = 0;\n            this.openedAt = null;\n        }\n    }\n\n    /**\n     * Save state to sessionStorage\n     */\n    saveState() {\n        try {\n            const state = {\n                state: this.state,\n                failureCount: this.failureCount,\n                openedAt: this.openedAt,\n            };\n\n            sessionStorage.setItem(this.storageKey, JSON.stringify(state));\n        } catch {\n            // Storage failure should never crash the app\n            // Circuit breaker still works in-memory for this page\n        }\n    }\n}\n","/**\n * Local Storage Queue\n *\n * Buffers failed error submissions in localStorage for later retry.\n * Used when the API is unreachable or circuit breaker is open.\n *\n * Features:\n * - FIFO queue with size limits\n * - Automatic expiration of old errors\n * - Safe storage operations (never crash on quota exceeded)\n */\nexport class StorageQueue {\n    constructor(config = {}) {\n        this.storageKey = 'app_logger_queue';\n        this.maxSize = config.maxSize || 50; // Max errors to store\n        this.maxAge = config.maxAge || 86400000; // 24 hours in milliseconds\n    }\n\n    /**\n     * Add an error to the queue\n     */\n    enqueue(payload) {\n        try {\n            const queue = this.getQueue();\n\n            // Add timestamp for expiration\n            const item = {\n                payload,\n                timestamp: Date.now(),\n            };\n\n            queue.push(item);\n\n            // Limit queue size (FIFO - remove oldest)\n            if (queue.length > this.maxSize) {\n                queue.shift();\n            }\n\n            this.saveQueue(queue);\n        } catch (error) {\n            // Storage failures should never crash the app\n            // Common causes: quota exceeded, private browsing mode\n            console.warn('ApplicationLogger: Failed to queue error', error);\n        }\n    }\n\n    /**\n     * Get next error from queue (FIFO)\n     */\n    dequeue() {\n        try {\n            const queue = this.getQueue();\n\n            if (queue.length === 0) {\n                return null;\n            }\n\n            const item = queue.shift();\n            this.saveQueue(queue);\n\n            return item.payload;\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Get all queued errors\n     */\n    getAll() {\n        const queue = this.getQueue();\n        return queue.map(item => item.payload);\n    }\n\n    /**\n     * Get queue size\n     */\n    size() {\n        const queue = this.getQueue();\n        return queue.length;\n    }\n\n    /**\n     * Clear the queue\n     */\n    clear() {\n        try {\n            localStorage.removeItem(this.storageKey);\n        } catch {\n            // Ignore\n        }\n    }\n\n    /**\n     * Get queue from localStorage with expiration cleanup\n     */\n    getQueue() {\n        try {\n            const stored = localStorage.getItem(this.storageKey);\n\n            if (!stored) {\n                return [];\n            }\n\n            const queue = JSON.parse(stored);\n\n            if (!Array.isArray(queue)) {\n                return [];\n            }\n\n            // Remove expired items\n            const now = Date.now();\n            const filtered = queue.filter(item => {\n                return item.timestamp && (now - item.timestamp) < this.maxAge;\n            });\n\n            // If we removed expired items, save the cleaned queue\n            if (filtered.length !== queue.length) {\n                this.saveQueue(filtered);\n            }\n\n            return filtered;\n        } catch {\n            return [];\n        }\n    }\n\n    /**\n     * Save queue to localStorage\n     */\n    saveQueue(queue) {\n        try {\n            localStorage.setItem(this.storageKey, JSON.stringify(queue));\n        } catch (error) {\n            // Handle quota exceeded or other storage errors\n            if (error.name === 'QuotaExceededError') {\n                // Try to make space by removing oldest items\n                const halfSize = Math.floor(queue.length / 2);\n                const trimmed = queue.slice(-halfSize);\n\n                try {\n                    localStorage.setItem(this.storageKey, JSON.stringify(trimmed));\n                } catch {\n                    // If still failing, clear the queue\n                    this.clear();\n                }\n            }\n        }\n    }\n}\n","/**\n * Rate Limiter\n *\n * Prevents error storms by limiting the number of errors sent per minute.\n * Uses token bucket algorithm for smooth rate limiting.\n *\n * This is critical for resilience - prevents overwhelming the API\n * and consuming excessive bandwidth during error cascades.\n */\nexport class RateLimiter {\n    constructor(config = {}) {\n        this.maxTokens = config.maxTokens || 10; // Max errors per window\n        this.refillRate = config.refillRate || 1; // Tokens per second\n        this.tokens = this.maxTokens;\n        this.lastRefill = Date.now();\n    }\n\n    /**\n     * Check if request is allowed\n     */\n    isAllowed() {\n        this.refillTokens();\n        return this.tokens > 0;\n    }\n\n    /**\n     * Consume a token (record an error sent)\n     */\n    consume() {\n        if (!this.isAllowed()) {\n            return false;\n        }\n\n        this.tokens--;\n        return true;\n    }\n\n    /**\n     * Refill tokens based on time elapsed\n     */\n    refillTokens() {\n        const now = Date.now();\n        const elapsed = (now - this.lastRefill) / 1000; // Convert to seconds\n        const tokensToAdd = Math.floor(elapsed * this.refillRate);\n\n        if (tokensToAdd > 0) {\n            this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);\n            this.lastRefill = now;\n        }\n    }\n\n    /**\n     * Get current token count (for debugging)\n     */\n    getTokens() {\n        this.refillTokens();\n        return this.tokens;\n    }\n\n    /**\n     * Reset rate limiter\n     */\n    reset() {\n        this.tokens = this.maxTokens;\n        this.lastRefill = Date.now();\n    }\n}\n","import { CircuitBreaker } from './circuit-breaker.js';\nimport { StorageQueue } from './storage-queue.js';\nimport { RateLimiter } from './rate-limiter.js';\n\n/**\n * Transport layer for sending errors to the platform\n *\n * RESILIENCE FEATURES:\n * - 3-second timeout with AbortController\n * - Circuit breaker prevents repeated calls to failing service\n * - Smart retry with exponential backoff\n * - Local storage queue for offline errors\n * - Rate limiting to prevent error storms\n * - Deduplication to avoid duplicate errors\n */\nexport class Transport {\n    constructor(config) {\n        this.config = config;\n        this.apiKey = config.apiKey; // Store API key separately (not in DSN)\n        this.dsn = this.parseDsn(config.dsn);\n        this.queue = [];\n        this.sending = false;\n\n        // Initialize resilience components\n        this.circuitBreaker = new CircuitBreaker({\n            failureThreshold: 5,\n            timeout: 60000, // 60 seconds\n        });\n\n        this.storageQueue = new StorageQueue({\n            maxSize: 50,\n            maxAge: 86400000, // 24 hours\n        });\n\n        this.rateLimiter = new RateLimiter({\n            maxTokens: 10, // Max 10 errors per minute\n            refillRate: 0.167, // Refill ~10 tokens per minute\n        });\n\n        // Deduplication cache\n        this.recentErrors = new Map();\n        this.deduplicationWindow = 5000; // 5 seconds\n\n        // Try to flush stored errors on init\n        this.flushStoredErrors();\n    }\n\n    /**\n   * Parse DSN into components\n   *\n   * DSN format: {protocol}://{host}/{projectId}\n   * Example: https://localhost:8111/b6d8ed85-c0af-4c02-b6bb-bfb0f3609b37\n   *\n   * Note: API key is NOT in the DSN. It's passed separately via config.apiKey.\n   */\n    parseDsn(dsn) {\n        if (!dsn) {\n            throw new Error('DSN is required');\n        }\n\n        try {\n            const url = new URL(dsn);\n            const projectId = url.pathname.replace(/^\\//, ''); // Remove leading slash\n\n            if (!projectId) {\n                throw new Error('DSN must include a project ID in the path');\n            }\n\n            return {\n                protocol: url.protocol.replace(':', ''),\n                host: url.host,\n                projectId: projectId,\n                endpoint: `${url.protocol}//${url.host}/api/errors/ingest`,\n            };\n        } catch (error) {\n            throw new Error(`Invalid DSN format: ${error.message}. Expected: https://host/project-id`);\n        }\n    }\n\n    /**\n   * Send error payload to platform\n   */\n    async send(payload) {\n        try {\n            // Scrub sensitive data\n            const scrubbedPayload = this.scrubSensitiveData(payload);\n\n            // Check for duplicates\n            if (this.isDuplicate(scrubbedPayload)) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Duplicate error ignored');\n                }\n                return;\n            }\n\n            // Check rate limit\n            if (!this.rateLimiter.consume()) {\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Rate limit exceeded, error queued');\n                }\n                this.storageQueue.enqueue(scrubbedPayload);\n                return;\n            }\n\n            // Add to queue\n            this.queue.push(scrubbedPayload);\n\n            // Process queue\n            if (!this.sending) {\n                await this.processQueue();\n            }\n        } catch (error) {\n            // Never crash on send errors\n            console.error('ApplicationLogger: Send failed', error);\n        }\n    }\n\n    /**\n   * Process queued errors\n   */\n    async processQueue() {\n        if (this.queue.length === 0 || this.sending) {\n            return;\n        }\n\n        this.sending = true;\n\n        while (this.queue.length > 0) {\n            const payload = this.queue.shift();\n\n            try {\n                await this.sendToApi(payload);\n\n                if (this.config.debug) {\n                    console.warn('ApplicationLogger: Error sent successfully');\n                }\n            } catch {\n                // Error already handled in sendToApi\n                // Don't re-queue here as sendToApi handles storage\n            }\n        }\n\n        this.sending = false;\n    }\n\n    /**\n   * Send payload to API with timeout and retry\n   */\n    async sendToApi(payload, attempt = 0) {\n        // Check circuit breaker\n        if (this.circuitBreaker.isOpen()) {\n            if (this.config.debug) {\n                console.warn('ApplicationLogger: Circuit breaker is open, error queued to storage');\n            }\n            this.storageQueue.enqueue(payload);\n            return;\n        }\n\n        // Create AbortController for timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 3000); // 3-second timeout\n\n        try {\n            const response = await fetch(this.dsn.endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey, // Use separate API key, not from DSN\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify(payload),\n                signal: controller.signal,\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n\n            // Success!\n            this.circuitBreaker.recordSuccess();\n\n            // Try to flush stored errors on success\n            this.flushStoredErrors();\n\n            return response.json();\n        } catch (error) {\n            clearTimeout(timeoutId);\n\n            // Handle timeout\n            if (error.name === 'AbortError') {\n                this.circuitBreaker.recordFailure();\n\n                if (this.config.debug) {\n                    console.error('ApplicationLogger: Request timeout');\n                }\n\n                this.storageQueue.enqueue(payload);\n                return;\n            }\n\n            // Handle network errors with retry\n            if (attempt < 2) {\n                // Exponential backoff: 1s, 2s\n                const delay = Math.pow(2, attempt) * 1000;\n                await this.delay(delay);\n\n                return this.sendToApi(payload, attempt + 1);\n            }\n\n            // Max retries reached\n            this.circuitBreaker.recordFailure();\n\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Max retries reached', error);\n            }\n\n            this.storageQueue.enqueue(payload);\n        }\n    }\n\n    /**\n   * Check if error is a duplicate\n   */\n    isDuplicate(payload) {\n        try {\n            // Create hash from error signature\n            const signature = JSON.stringify({\n                type: payload.exception?.type,\n                message: payload.exception?.value,\n                stack: payload.exception?.stacktrace?.frames?.slice(0, 3), // Top 3 frames\n            });\n\n            const hash = this.simpleHash(signature);\n\n            // Check if we've seen this recently\n            if (this.recentErrors.has(hash)) {\n                return true;\n            }\n\n            // Add to recent errors\n            this.recentErrors.set(hash, Date.now());\n\n            // Clean up old entries\n            const now = Date.now();\n            for (const [key, timestamp] of this.recentErrors) {\n                if (now - timestamp > this.deduplicationWindow) {\n                    this.recentErrors.delete(key);\n                }\n            }\n\n            return false;\n        } catch {\n            return false; // If deduplication fails, allow the error through\n        }\n    }\n\n    /**\n   * Simple hash function\n   */\n    simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            const char = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // Convert to 32bit integer\n        }\n        return hash.toString();\n    }\n\n    /**\n   * Flush errors from storage queue\n   */\n    async flushStoredErrors() {\n        try {\n            const queueSize = this.storageQueue.size();\n\n            if (queueSize === 0) {\n                return;\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Flushing ${queueSize} stored errors`);\n            }\n\n            // Limit flush to 5 errors at a time to avoid overwhelming\n            const limit = Math.min(queueSize, 5);\n\n            for (let i = 0; i < limit; i++) {\n                const payload = this.storageQueue.dequeue();\n\n                if (payload) {\n                    // Add to queue (but don't recurse infinitely)\n                    this.queue.push(payload);\n                }\n            }\n\n            // Process the queue\n            if (!this.sending && this.queue.length > 0) {\n                await this.processQueue();\n            }\n        } catch (error) {\n            // Never crash on flush\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Flush failed', error);\n            }\n        }\n    }\n\n    /**\n   * Delay helper for retry backoff\n   */\n    delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    /**\n   * Scrub sensitive data from payload\n   */\n    scrubSensitiveData(payload) {\n        const scrubFields = this.config.scrubFields || [];\n        const scrubPatterns = [\n            ...scrubFields,\n            'password',\n            'passwd',\n            'pwd',\n            'secret',\n            'api_key',\n            'apikey',\n            'token',\n            'auth',\n            'authorization',\n            'private_key',\n            'access_token',\n            'refresh_token',\n        ];\n\n        // Deep clone payload\n        const scrubbed = JSON.parse(JSON.stringify(payload));\n\n        // Recursively scrub object\n        const scrubObject = (obj) => {\n            if (!obj || typeof obj !== 'object') {\n                return obj;\n            }\n\n            for (const key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    // Check if key matches scrub pattern\n                    const shouldScrub = scrubPatterns.some(pattern =>\n                        key.toLowerCase().includes(pattern.toLowerCase()),\n                    );\n\n                    if (shouldScrub) {\n                        obj[key] = '[REDACTED]';\n                    } else if (typeof obj[key] === 'object') {\n                        scrubObject(obj[key]);\n                    }\n                }\n            }\n\n            return obj;\n        };\n\n        return scrubObject(scrubbed);\n    }\n\n    /**\n     * Send session event to API\n     */\n    async sendSessionEvent(sessionId, eventData) {\n        if (!sessionId || !eventData) {\n            return;\n        }\n\n        try {\n            const url = `${this.dsn.protocol}://${this.dsn.host}/api/v1/sessions/${sessionId}/events`;\n\n            const response = await fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey,\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify(eventData),\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}`);\n            }\n\n            return response.json();\n        } catch (error) {\n            // Silently fail - session tracking is non-critical\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Failed to send session event', error);\n            }\n        }\n    }\n\n    /**\n     * Send heatmap click data to API (batch)\n     */\n    async sendHeatmap(sessionId, clicks) {\n        if (!sessionId || !clicks || clicks.length === 0) {\n            return;\n        }\n\n        try {\n            const url = `${this.dsn.protocol}://${this.dsn.host}/api/v1/sessions/${sessionId}/heatmap`;\n\n            const response = await fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': this.apiKey,\n                    'User-Agent': 'ApplicationLogger-JS-SDK/1.0',\n                },\n                body: JSON.stringify({ clicks }),\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}`);\n            }\n\n            if (this.config.debug) {\n                console.warn(`ApplicationLogger: Sent ${clicks.length} heatmap clicks`);\n            }\n\n            return response.json();\n        } catch (error) {\n            // Silently fail - heatmap tracking is non-critical\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Failed to send heatmap data', error);\n            }\n        }\n    }\n\n    /**\n   * Get stats for monitoring\n   */\n    getStats() {\n        return {\n            queueSize: this.queue.length,\n            storedErrors: this.storageQueue.size(),\n            circuitBreaker: this.circuitBreaker.getState(),\n            rateLimitTokens: this.rateLimiter.getTokens(),\n        };\n    }\n\n    /**\n   * Flush pending errors using Beacon API\n   * Called on page unload to ensure errors are sent even as page closes\n   */\n    flushWithBeacon() {\n        try {\n            // Get all stored errors (from offline queue)\n            const storedErrors = this.storageQueue.getAll();\n\n            // Also include current queue\n            const allErrors = [...this.queue, ...storedErrors];\n\n            if (allErrors.length === 0) {\n                return;\n            }\n\n            // Limit to 10 most recent errors to avoid payload size issues\n            const errorsToSend = allErrors.slice(-10);\n\n            // Beacon API has limitations with headers, so we include DSN in body\n            const beaconPayload = {\n                dsn: this.config.dsn,\n                errors: errorsToSend,\n            };\n\n            const blob = new Blob([JSON.stringify(beaconPayload)], {\n                type: 'application/json',\n            });\n\n            // Try to send via Beacon API\n            const sent = navigator.sendBeacon(this.dsn.endpoint, blob);\n\n            if (sent) {\n                // Successfully queued for sending\n                // Clear the storage queue and current queue\n                this.storageQueue.clear();\n                this.queue = [];\n\n                if (this.config.debug) {\n                    console.warn(`ApplicationLogger: Flushed ${errorsToSend.length} errors via Beacon API`);\n                }\n            }\n        } catch (error) {\n            // Beacon flush failed - errors remain in storage for next session\n            if (this.config.debug) {\n                console.error('ApplicationLogger: Beacon flush failed', error);\n            }\n        }\n    }\n}\n","/**\n * Heatmap Tracker - Captures user clicks and interactions\n *\n * FEATURES:\n * - Click coordinate tracking with viewport dimensions\n * - Element selector generation (CSS selectors)\n * - Debouncing to prevent API flooding\n * - Batch sending for efficiency\n * - Privacy-respecting (no PII in selectors)\n */\nexport class HeatmapTracker {\n    constructor(transport, config) {\n        this.transport = transport;\n        this.config = config;\n        this.clickQueue = [];\n        this.batchSize = config.heatmapBatchSize || 10;\n        this.batchTimeout = config.heatmapBatchTimeout || 5000; // 5 seconds\n        this.batchTimer = null;\n        this.isInstalled = false;\n        this.sessionId = null;\n    }\n\n    /**\n     * Install click tracking listeners\n     */\n    install(sessionId) {\n        if (this.isInstalled) {\n            return;\n        }\n\n        this.sessionId = sessionId;\n\n        try {\n            // Track clicks\n            document.addEventListener('click', (event) => {\n                this.captureClick(event);\n            }, true);\n\n            // Flush on page unload\n            window.addEventListener('beforeunload', () => {\n                this.flush();\n            });\n\n            // Flush on visibility change (mobile)\n            document.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'hidden') {\n                    this.flush();\n                }\n            });\n\n            this.isInstalled = true;\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to install heatmap tracker', error);\n        }\n    }\n\n    /**\n     * Capture click event\n     */\n    captureClick(event) {\n        try {\n            const clickData = {\n                type: 'click',\n                url: window.location.href,\n                x: event.pageX,\n                y: event.pageY,\n                viewport_width: window.innerWidth,\n                viewport_height: window.innerHeight,\n                element_selector: this.generateSelector(event.target),\n                timestamp: new Date().toISOString(),\n                session_id: this.sessionId,\n            };\n\n            this.clickQueue.push(clickData);\n\n            // Send batch if queue is full\n            if (this.clickQueue.length >= this.batchSize) {\n                this.flush();\n            } else {\n                // Schedule batch send\n                this.scheduleBatchSend();\n            }\n        } catch (error) {\n            // Never crash on tracking\n            console.error('ApplicationLogger: Failed to capture click', error);\n        }\n    }\n\n    /**\n     * Generate CSS selector for element\n     *\n     * Creates a unique but privacy-respecting selector:\n     * - Uses tag name, ID, classes\n     * - Limits depth to 5 levels\n     * - Removes sensitive attributes (data-*, ng-*, etc.)\n     */\n    generateSelector(element) {\n        if (!element || element === document) {\n            return '';\n        }\n\n        try {\n            const parts = [];\n            let current = element;\n            let depth = 0;\n            const maxDepth = 5;\n\n            while (current && current !== document && depth < maxDepth) {\n                let selector = current.tagName.toLowerCase();\n\n                // Add ID if available (most specific)\n                if (current.id && !this.containsSensitiveData(current.id)) {\n                    selector += `#${CSS.escape(current.id)}`;\n                    parts.unshift(selector);\n                    break; // ID is unique, stop here\n                }\n\n                // Add classes (filter out utility/dynamic classes)\n                const classes = this.getCleanClasses(current);\n                if (classes.length > 0) {\n                    selector += `.${classes.join('.')}`;\n                }\n\n                // Add nth-child if needed for uniqueness\n                const siblings = current.parentElement ?\n                    Array.from(current.parentElement.children).filter(\n                        child => child.tagName === current.tagName,\n                    ) : [];\n\n                if (siblings.length > 1) {\n                    const index = siblings.indexOf(current) + 1;\n                    selector += `:nth-child(${index})`;\n                }\n\n                parts.unshift(selector);\n                current = current.parentElement;\n                depth++;\n            }\n\n            return parts.join(' > ');\n        } catch {\n            // If selector generation fails, return basic info\n            return element.tagName ? element.tagName.toLowerCase() : 'unknown';\n        }\n    }\n\n    /**\n     * Get cleaned class list (remove utility and sensitive classes)\n     */\n    getCleanClasses(element) {\n        if (!element.classList || element.classList.length === 0) {\n            return [];\n        }\n\n        const classes = Array.from(element.classList);\n        return classes\n            .filter(cls => {\n                // Filter out utility classes (Tailwind, Bootstrap, etc.)\n                if (cls.match(/^(active|hover|focus|disabled|hidden|show)$/)) {\n                    return false;\n                }\n\n                // Filter out generated classes\n                if (cls.match(/^(ng-|v-|data-|_)/)) {\n                    return false;\n                }\n\n                // Filter out classes that look like they contain sensitive data\n                if (this.containsSensitiveData(cls)) {\n                    return false;\n                }\n\n                return true;\n            })\n            .map(cls => CSS.escape(cls))\n            .slice(0, 3); // Limit to 3 classes\n    }\n\n    /**\n     * Check if string contains potentially sensitive data\n     */\n    containsSensitiveData(str) {\n        const sensitivePatterns = [\n            /user[-_]?id/i,\n            /email/i,\n            /token/i,\n            /session/i,\n            /auth/i,\n            /key/i,\n            /\\d{10,}/,  // Long numbers (could be IDs)\n        ];\n\n        return sensitivePatterns.some(pattern => pattern.test(str));\n    }\n\n    /**\n     * Schedule batch send with timeout\n     */\n    scheduleBatchSend() {\n        // Clear existing timer\n        if (this.batchTimer) {\n            clearTimeout(this.batchTimer);\n        }\n\n        // Schedule new timer\n        this.batchTimer = setTimeout(() => {\n            this.flush();\n        }, this.batchTimeout);\n    }\n\n    /**\n     * Flush click queue (send all pending clicks)\n     */\n    flush() {\n        if (this.clickQueue.length === 0) {\n            return;\n        }\n\n        try {\n            // Clear timer\n            if (this.batchTimer) {\n                clearTimeout(this.batchTimer);\n                this.batchTimer = null;\n            }\n\n            // Get clicks to send\n            const clicksToSend = [...this.clickQueue];\n            this.clickQueue = [];\n\n            // Send to heatmap API\n            this.sendHeatmapData(clicksToSend);\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to flush heatmap data', error);\n        }\n    }\n\n    /**\n     * Send heatmap data to API\n     */\n    async sendHeatmapData(clicks) {\n        if (!this.sessionId || clicks.length === 0) {\n            return;\n        }\n\n        try {\n            // Use transport's sendHeatmap method if available, otherwise use regular send\n            if (this.transport.sendHeatmap) {\n                await this.transport.sendHeatmap(this.sessionId, clicks);\n            } else {\n                // Fallback: send as regular events\n                const events = clicks.map(click => ({\n                    type: 'HEATMAP_CLICK',\n                    url: click.url,\n                    timestamp: click.timestamp,\n                    data: click,\n                }));\n\n                for (const event of events) {\n                    await this.transport.sendSessionEvent(this.sessionId, event);\n                }\n            }\n        } catch (error) {\n            console.error('ApplicationLogger: Failed to send heatmap data', error);\n        }\n    }\n\n    /**\n     * Get current queue size for monitoring\n     */\n    getQueueSize() {\n        return this.clickQueue.length;\n    }\n}\n","/**\n * Application Logger JavaScript SDK\n *\n * Captures JavaScript errors and sends them to the Application Logger platform.\n * Integrated with Symfony bundle for seamless error tracking.\n *\n * @module ApplicationLogger\n */\n\nimport { Client } from './client.js';\nimport { BreadcrumbCollector } from './breadcrumbs.js';\nimport { Transport } from './transport.js';\nimport { HeatmapTracker } from './heatmap.js';\n\n/**\n * Main ApplicationLogger class\n */\nclass ApplicationLogger {\n    /**\n   * @param {Object} config Configuration options\n   * @param {string} config.dsn Data Source Name (project endpoint URL)\n   * @param {string} config.apiKey API Key for authentication\n   * @param {string} [config.sessionId] Session ID for tracking (provided by server)\n   * @param {string} [config.release] Application version/release\n   * @param {string} [config.environment] Environment (production, staging, etc.)\n   * @param {boolean} [config.debug=false] Enable debug logging\n   * @param {boolean} [config.enableHeatmap=true] Enable heatmap click tracking\n   * @param {number} [config.heatmapBatchSize=10] Heatmap batch size\n   * @param {number} [config.heatmapBatchTimeout=5000] Heatmap batch timeout (ms)\n   * @param {string[]} [config.scrubFields] Additional fields to scrub\n   */\n    constructor(config) {\n        // Validate required configuration\n        if (!config || !config.dsn) {\n            throw new Error('ApplicationLogger: DSN is required. Expected format: https://host/project-id');\n        }\n\n        if (!config.apiKey) {\n            throw new Error('ApplicationLogger: API Key is required for authentication');\n        }\n\n        this.config = {\n            debug: false,\n            scrubFields: ['password', 'token', 'api_key', 'secret'],\n            enableHeatmap: true,\n            heatmapBatchSize: 10,\n            heatmapBatchTimeout: 5000,\n            ...config,\n        };\n\n        this.transport = new Transport(this.config);\n        this.breadcrumbs = new BreadcrumbCollector();\n        this.client = new Client(this.config, this.transport, this.breadcrumbs);\n        this.heatmap = new HeatmapTracker(this.transport, this.config);\n        this.initialized = false;\n    }\n\n    /**\n   * Initialize the SDK and start capturing errors\n   */\n    init() {\n        if (this.initialized) {\n            console.warn('ApplicationLogger already initialized');\n            return;\n        }\n\n        this.client.install();\n\n        // Install heatmap tracking if enabled and session ID is provided\n        if (this.config.enableHeatmap && this.config.sessionId) {\n            this.heatmap.install(this.config.sessionId);\n\n            if (this.config.debug) {\n                // eslint-disable-next-line no-console\n                console.log('ApplicationLogger: Heatmap tracking enabled');\n            }\n        }\n\n        this.initialized = true;\n\n        if (this.config.debug) {\n            // eslint-disable-next-line no-console\n            console.log('ApplicationLogger initialized', this.config);\n        }\n    }\n\n    /**\n   * Manually capture an exception\n   *\n   * @param {Error} error The error to capture\n   * @param {Object} [options] Additional options\n   * @param {Object} [options.tags] Key-value tags\n   * @param {Object} [options.extra] Additional context data\n   */\n    captureException(error, options = {}) {\n        this.client.captureException(error, options);\n    }\n\n    /**\n   * Manually capture a message\n   *\n   * @param {string} message The message to capture\n   * @param {string} [level='info'] Log level\n   * @param {Object} [options] Additional options\n   */\n    captureMessage(message, level = 'info', options = {}) {\n        this.client.captureMessage(message, level, options);\n    }\n\n    /**\n   * Add a breadcrumb\n   *\n   * @param {Object} breadcrumb Breadcrumb data\n   * @param {string} breadcrumb.type Breadcrumb type (navigation, http, user, etc.)\n   * @param {string} breadcrumb.category Category\n   * @param {string} breadcrumb.message Message\n   * @param {Object} [breadcrumb.data] Additional data\n   * @param {string} [breadcrumb.level='info'] Log level\n   */\n    addBreadcrumb(breadcrumb) {\n        this.breadcrumbs.add(breadcrumb);\n    }\n\n    /**\n   * Set user context\n   *\n   * @param {Object} user User data\n   * @param {string} [user.id] User ID\n   * @param {string} [user.email] User email\n   * @param {string} [user.username] Username\n   */\n    setUser(user) {\n        this.client.setUser(user);\n    }\n\n    /**\n   * Set tags\n   *\n   * @param {Object} tags Key-value tags\n   */\n    setTags(tags) {\n        this.client.setTags(tags);\n    }\n\n    /**\n   * Set extra context\n   *\n   * @param {Object} extra Key-value extra data\n   */\n    setExtra(extra) {\n        this.client.setExtra(extra);\n    }\n}\n\n// Export for ES modules\nexport default ApplicationLogger;\n\n// Export for UMD (window.ApplicationLogger)\nif (typeof window !== 'undefined') {\n    window.ApplicationLogger = ApplicationLogger;\n}\n"],"names":["Client","constructor","config","transport","breadcrumbs","this","userContext","tags","extra","pendingBeaconErrors","install","window","addEventListener","event","captureException","error","Error","message","filename","lineno","colno","console","reason","type","flushBeaconErrors","document","visibilityState","options","payload","buildPayload","send","captureMessage","level","stackTrace","parseStackTrace","firstFrame","length","name","file","line","stack_trace","source","environment","release","url","location","href","http_method","detectHttpMethod","http_status_code","extractHttpStatusCode","session_hash","getSessionHash","timestamp","Date","toISOString","runtime","getBrowserInfo","user_agent","navigator","userAgent","get","context","removeNullValues","stack","function","lines","split","frames","frame","parseStackLine","trim","push","match","parseInt","column","navigation","performance","getEntriesByType","status","httpStatusCode","ua","includes","sessionHash","sessionStorage","sessionId","getItem","generateSessionId","setItem","sha256","crypto","randomUUID","replace","c","r","Math","random","toString","str","hash","i","charCodeAt","abs","padStart","obj","cleaned","key","value","Object","entries","setUser","user","setTags","setExtra","sendBeacon","stats","getStats","storedErrors","queueSize","flushWithBeacon","BreadcrumbCollector","maxBreadcrumbs","target","tagName","toLowerCase","className","element","undefined","baseVal","id","firstClass","add","category","data","tag","class","originalPushState","history","pushState","originalReplaceState","replaceState","args","to","apply","wrapConsole","wrapFetch","breadcrumb","shift","clear","forEach","original","join","arguments","originalFetch","fetch","async","method","startTime","now","response","duration","status_code","ok","CircuitBreaker","static","failureThreshold","timeout","storageKey","loadState","isOpen","state","STATE_OPEN","shouldAttemptReset","halfOpen","isHalfOpen","STATE_HALF_OPEN","recordSuccess","close","STATE_CLOSED","failureCount","saveState","recordFailure","open","getState","openedAt","reset","stored","JSON","parse","stringify","StorageQueue","maxSize","maxAge","enqueue","queue","getQueue","item","saveQueue","warn","dequeue","getAll","map","size","localStorage","removeItem","Array","isArray","filtered","filter","halfSize","floor","trimmed","slice","RateLimiter","maxTokens","refillRate","tokens","lastRefill","isAllowed","refillTokens","consume","elapsed","tokensToAdd","min","getTokens","Transport","apiKey","dsn","parseDsn","sending","circuitBreaker","storageQueue","rateLimiter","recentErrors","Map","deduplicationWindow","flushStoredErrors","URL","projectId","pathname","protocol","host","endpoint","scrubbedPayload","scrubSensitiveData","isDuplicate","debug","processQueue","sendToApi","attempt","controller","AbortController","timeoutId","setTimeout","abort","headers","body","signal","clearTimeout","statusText","json","delay","pow","signature","exception","stacktrace","simpleHash","has","set","delete","limit","ms","Promise","resolve","scrubPatterns","scrubFields","scrubbed","scrubObject","prototype","hasOwnProperty","call","some","pattern","sendSessionEvent","eventData","sendHeatmap","clicks","rateLimitTokens","allErrors","errorsToSend","beaconPayload","errors","blob","Blob","HeatmapTracker","clickQueue","batchSize","heatmapBatchSize","batchTimeout","heatmapBatchTimeout","batchTimer","isInstalled","captureClick","flush","clickData","x","pageX","y","pageY","viewport_width","innerWidth","viewport_height","innerHeight","element_selector","generateSelector","session_id","scheduleBatchSend","parts","current","depth","maxDepth","selector","containsSensitiveData","CSS","escape","unshift","classes","getCleanClasses","siblings","parentElement","from","children","child","indexOf","classList","cls","test","clicksToSend","sendHeatmapData","events","click","getQueueSize","ApplicationLogger","enableHeatmap","client","heatmap","initialized","init","log","addBreadcrumb"],"mappings":"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"}